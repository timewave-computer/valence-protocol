#[cfg(not(feature = "library"))]
use cosmwasm_std::entry_point;
use cosmwasm_std::{to_json_binary, Binary, Deps, DepsMut, Env, MessageInfo, Response, StdResult};
use sp1_verifier::{Groth16Verifier, GROTH16_VK_BYTES};

use crate::{
    error::ContractError,
    msg::{ExecuteMsg, InstantiateMsg, QueryMsg},
};

const CONTRACT_NAME: &str = env!("CARGO_PKG_NAME");
const CONTRACT_VERSION: &str = env!("CARGO_PKG_VERSION");

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn instantiate(
    deps: DepsMut,
    _env: Env,
    _info: MessageInfo,
    _msg: InstantiateMsg,
) -> Result<Response, ContractError> {
    cw2::set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;

    Ok(Response::new().add_attribute("action", "instantiate_verification_gateway"))
}

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn execute(
    _deps: DepsMut,
    _env: Env,
    _info: MessageInfo,
    _msg: ExecuteMsg,
) -> StdResult<Response> {
    unimplemented!("This contract does not handle any execute messages, only queries")
}

#[cfg_attr(not(feature = "library"), entry_point)]
pub fn query(_deps: Deps, _env: Env, msg: QueryMsg) -> StdResult<Binary> {
    match msg {
        QueryMsg::VerifyProof { vk, proof, inputs } => {
            to_json_binary(&verify_proof(&vk, proof, inputs)?)
        }
    }
}

fn verify_proof(vk: &Binary, proof: Binary, inputs: Binary) -> StdResult<bool> {
    // Get the VK as a String
    let sp1_vkey_hash = String::from_utf8(vk.to_vec()).map_err(|e| {
        cosmwasm_std::StdError::generic_err(format!("Failed to parse vk hash: {}", e))
    })?;

    Groth16Verifier::verify(
        proof.as_slice(),
        inputs.as_slice(),
        &sp1_vkey_hash,
        &GROTH16_VK_BYTES,
    )
    .map_err(|e| {
        cosmwasm_std::StdError::generic_err(format!(
            "Failed to verify SP1 proof with vk hash {}: {}",
            sp1_vkey_hash, e
        ))
    })?;

    Ok(true)
}

#[cfg(test)]
mod tests {
    use cosmwasm_std::Binary;
    use sp1_sdk::{HashableKey, SP1ProofWithPublicValues, SP1VerifyingKey};
    use sp1_verifier::{Groth16Verifier, GROTH16_VK_BYTES};

    use crate::contract::verify_proof;

    #[test]
    fn test_verify_proof() {
        // Real sample proof and vk
        // Source: https://github.com/timewave-computer/valence-coprocessor/tree/main/crates/runtime/sp1/assets/sample-groth16-proof
        let hello_vk: Vec<u8> = vec![
            247, 175, 73, 83, 248, 124, 155, 118, 188, 222, 112, 16, 154, 197, 124, 39, 216, 36,
            21, 4, 254, 93, 176, 74, 70, 187, 241, 95, 132, 12, 187, 42, 116, 20, 32, 0, 0, 25,
            157, 98, 247, 153, 40, 58, 162, 118, 164, 33, 74, 106, 108, 97, 21, 92, 90, 90, 192,
            89, 179, 83, 13, 35, 41, 75, 167, 84, 81, 19, 230, 116, 44, 47, 76, 166, 34, 72, 61,
            244, 28, 5, 156, 145, 50, 80, 149, 103, 107, 76, 184, 202, 91, 55, 2, 0, 0, 0, 0, 0, 0,
            0, 7, 0, 0, 0, 0, 0, 0, 0, 80, 114, 111, 103, 114, 97, 109, 19, 0, 0, 0, 0, 0, 0, 0, 1,
            0, 0, 0, 14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 66,
            121, 116, 101, 16, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
            0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 80, 114, 111, 103, 114,
            97, 109, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 66, 121, 116, 101, 1, 0, 0, 0,
            0, 0, 0, 0,
        ];

        let hello_proof: Vec<u8> = vec![
            3, 0, 0, 0, 75, 0, 0, 0, 0, 0, 0, 0, 50, 56, 48, 53, 52, 50, 57, 54, 53, 57, 50, 51,
            52, 57, 52, 51, 54, 54, 50, 51, 52, 52, 51, 53, 53, 48, 56, 51, 48, 50, 54, 48, 53, 48,
            51, 48, 49, 56, 50, 53, 52, 49, 57, 55, 55, 54, 48, 53, 57, 56, 56, 57, 51, 50, 57, 52,
            54, 54, 49, 50, 50, 51, 55, 51, 48, 52, 55, 57, 48, 55, 51, 51, 52, 54, 53, 76, 0, 0,
            0, 0, 0, 0, 0, 53, 52, 48, 54, 50, 48, 50, 57, 51, 50, 54, 57, 48, 49, 57, 57, 49, 50,
            50, 48, 56, 51, 49, 48, 54, 56, 55, 55, 57, 54, 57, 53, 55, 52, 54, 51, 49, 55, 57, 52,
            48, 52, 48, 56, 50, 50, 57, 50, 55, 55, 49, 53, 55, 56, 50, 57, 48, 48, 55, 49, 49, 54,
            50, 56, 52, 53, 52, 54, 53, 56, 56, 54, 57, 57, 52, 55, 0, 2, 0, 0, 0, 0, 0, 0, 48, 98,
            101, 98, 98, 52, 98, 57, 57, 55, 57, 54, 51, 57, 99, 48, 98, 55, 54, 55, 101, 48, 49,
            53, 49, 50, 50, 53, 102, 54, 56, 54, 50, 98, 101, 98, 48, 55, 55, 56, 49, 48, 56, 101,
            51, 56, 49, 53, 97, 49, 56, 48, 100, 98, 49, 98, 54, 50, 56, 98, 57, 54, 57, 51, 50,
            57, 99, 56, 53, 49, 57, 49, 54, 53, 52, 97, 98, 102, 55, 48, 51, 99, 49, 55, 57, 54,
            101, 52, 99, 52, 101, 56, 99, 97, 100, 48, 99, 97, 54, 51, 102, 55, 56, 102, 101, 55,
            57, 97, 100, 51, 57, 102, 51, 49, 51, 98, 54, 54, 57, 57, 56, 102, 101, 51, 51, 102,
            55, 99, 49, 102, 98, 52, 98, 57, 100, 55, 57, 50, 51, 56, 53, 49, 51, 53, 57, 57, 97,
            99, 97, 98, 98, 51, 48, 52, 53, 55, 101, 49, 49, 52, 97, 56, 52, 98, 53, 49, 52, 52,
            97, 52, 48, 50, 50, 48, 51, 52, 99, 97, 54, 48, 98, 53, 57, 51, 53, 97, 52, 53, 99,
            100, 48, 49, 50, 56, 49, 101, 54, 50, 49, 57, 101, 54, 48, 50, 99, 56, 49, 52, 51, 51,
            53, 97, 97, 98, 49, 99, 97, 48, 48, 56, 56, 48, 56, 51, 50, 56, 53, 57, 55, 55, 57, 99,
            98, 50, 56, 52, 102, 97, 56, 54, 54, 51, 53, 97, 51, 101, 101, 53, 48, 98, 101, 101,
            101, 97, 100, 54, 48, 52, 57, 51, 101, 100, 48, 99, 55, 97, 55, 49, 50, 54, 98, 49, 99,
            52, 97, 50, 54, 51, 53, 50, 53, 50, 48, 56, 97, 99, 98, 54, 98, 56, 97, 102, 99, 98,
            54, 56, 53, 52, 98, 99, 57, 49, 57, 49, 102, 54, 51, 99, 99, 51, 53, 56, 55, 52, 53,
            97, 102, 49, 99, 54, 48, 98, 102, 55, 98, 100, 56, 53, 57, 53, 53, 102, 48, 102, 51,
            51, 99, 51, 54, 57, 100, 53, 97, 100, 55, 98, 54, 97, 56, 49, 56, 56, 54, 102, 49, 55,
            57, 55, 53, 102, 57, 102, 56, 100, 101, 55, 48, 53, 50, 53, 53, 102, 53, 98, 56, 101,
            48, 57, 97, 101, 56, 55, 55, 50, 50, 98, 102, 101, 57, 55, 101, 102, 99, 55, 99, 100,
            53, 57, 49, 54, 100, 97, 55, 55, 48, 51, 101, 49, 99, 102, 100, 56, 54, 98, 54, 50, 57,
            57, 99, 100, 53, 55, 101, 49, 54, 102, 102, 54, 54, 52, 97, 56, 48, 98, 49, 53, 101,
            52, 98, 51, 54, 56, 48, 53, 51, 48, 102, 51, 50, 48, 98, 53, 49, 54, 48, 54, 101, 57,
            98, 100, 56, 51, 98, 101, 56, 56, 97, 50, 100, 55, 48, 53, 57, 56, 50, 52, 101, 102,
            102, 53, 98, 52, 102, 98, 97, 53, 102, 54, 48, 99, 98, 51, 55, 99, 57, 51, 101, 53, 52,
            101, 100, 54, 51, 55, 101, 98, 97, 97, 99, 100, 101, 55, 136, 2, 0, 0, 0, 0, 0, 0, 48,
            98, 101, 98, 98, 52, 98, 57, 57, 55, 57, 54, 51, 57, 99, 48, 98, 55, 54, 55, 101, 48,
            49, 53, 49, 50, 50, 53, 102, 54, 56, 54, 50, 98, 101, 98, 48, 55, 55, 56, 49, 48, 56,
            101, 51, 56, 49, 53, 97, 49, 56, 48, 100, 98, 49, 98, 54, 50, 56, 98, 57, 54, 57, 51,
            50, 57, 99, 56, 53, 49, 57, 49, 54, 53, 52, 97, 98, 102, 55, 48, 51, 99, 49, 55, 57,
            54, 101, 52, 99, 52, 101, 56, 99, 97, 100, 48, 99, 97, 54, 51, 102, 55, 56, 102, 101,
            55, 57, 97, 100, 51, 57, 102, 51, 49, 51, 98, 54, 54, 57, 57, 56, 102, 101, 51, 51,
            102, 55, 99, 49, 102, 98, 52, 98, 57, 100, 55, 57, 50, 51, 56, 53, 49, 51, 53, 57, 57,
            97, 99, 97, 98, 98, 51, 48, 52, 53, 55, 101, 49, 49, 52, 97, 56, 52, 98, 53, 49, 52,
            52, 97, 52, 48, 50, 50, 48, 51, 52, 99, 97, 54, 48, 98, 53, 57, 51, 53, 97, 52, 53, 99,
            100, 48, 49, 50, 56, 49, 101, 54, 50, 49, 57, 101, 54, 48, 50, 99, 56, 49, 52, 51, 51,
            53, 97, 97, 98, 49, 99, 97, 48, 48, 56, 56, 48, 56, 51, 50, 56, 53, 57, 55, 55, 57, 99,
            98, 50, 56, 52, 102, 97, 56, 54, 54, 51, 53, 97, 51, 101, 101, 53, 48, 98, 101, 101,
            101, 97, 100, 54, 48, 52, 57, 51, 101, 100, 48, 99, 55, 97, 55, 49, 50, 54, 98, 49, 99,
            52, 97, 50, 54, 51, 53, 50, 53, 50, 48, 56, 97, 99, 98, 54, 98, 56, 97, 102, 99, 98,
            54, 56, 53, 52, 98, 99, 57, 49, 57, 49, 102, 54, 51, 99, 99, 51, 53, 56, 55, 52, 53,
            97, 102, 49, 99, 54, 48, 98, 102, 55, 98, 100, 56, 53, 57, 53, 53, 102, 48, 102, 51,
            51, 99, 51, 54, 57, 100, 53, 97, 100, 55, 98, 54, 97, 56, 49, 56, 56, 54, 102, 49, 55,
            57, 55, 53, 102, 57, 102, 56, 100, 101, 55, 48, 53, 50, 53, 53, 102, 53, 98, 56, 101,
            48, 57, 97, 101, 56, 55, 55, 50, 50, 98, 102, 101, 57, 55, 101, 102, 99, 55, 99, 100,
            53, 57, 49, 54, 100, 97, 55, 55, 48, 51, 101, 49, 99, 102, 100, 56, 54, 98, 54, 50, 57,
            57, 99, 100, 53, 55, 101, 49, 54, 102, 102, 54, 54, 52, 97, 56, 48, 98, 49, 53, 101,
            52, 98, 51, 54, 56, 48, 53, 51, 48, 102, 51, 50, 48, 98, 53, 49, 54, 48, 54, 101, 57,
            98, 100, 56, 51, 98, 101, 56, 56, 97, 50, 100, 55, 48, 53, 57, 56, 50, 52, 101, 102,
            102, 53, 98, 52, 102, 98, 97, 53, 102, 54, 48, 99, 98, 51, 55, 99, 57, 51, 101, 53, 52,
            101, 100, 54, 51, 55, 101, 98, 97, 97, 99, 100, 101, 55, 48, 48, 48, 48, 48, 48, 48,
            48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
            48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
            48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
            48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
            48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48,
            48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 17, 182,
            160, 157, 99, 210, 85, 173, 66, 94, 227, 167, 246, 33, 29, 94, 198, 63, 189, 233, 128,
            91, 64, 85, 28, 49, 54, 39, 91, 111, 78, 180, 8, 0, 0, 0, 0, 0, 0, 0, 43, 0, 0, 0, 0,
            0, 0, 0, 11, 0, 0, 0, 0, 0, 0, 0, 118, 52, 46, 48, 46, 48, 45, 114, 99, 46, 51, 0,
        ];

        let sp1_proof: SP1ProofWithPublicValues = bincode::deserialize(&hello_proof).unwrap();
        let sp1_vk: SP1VerifyingKey = bincode::deserialize(&hello_vk).unwrap();
        let sp1_vk_hash = sp1_vk.bytes32();

        Groth16Verifier::verify(
            &sp1_proof.bytes(),
            sp1_proof.public_values.as_slice(),
            &sp1_vk_hash,
            &GROTH16_VK_BYTES,
        )
        .unwrap();

        // Wrap in Binary
        let vk = Binary::new(sp1_vk_hash.as_bytes().to_vec());
        let proof = Binary::new(sp1_proof.bytes().to_vec());
        let inputs = Binary::new(sp1_proof.public_values.as_slice().to_vec());

        verify_proof(&vk, proof, inputs).unwrap();
    }
}
