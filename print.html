<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Valence Protocol Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Valence Protocol Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/timewave-computer/valence-protocol" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <blockquote>
<p>üöß This in-progress document contains information about the design of a cross-chain automation system.</p>
</blockquote>
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>The <strong>Valence Protocol</strong> is a framework designed to help you build <em>trust-minimized applications</em>, called <strong>Valence programs</strong>, executing across multiple chains.
Valence programs are:</p>
<ul>
<li><strong>Easy to understand</strong> and <strong>quick to deploy</strong>: a program can be set up with a configuration file and no code.</li>
<li><strong>Extensible</strong>: if we don't support a DeFi integration out of the box, you can write one yourself in a matter of hours!</li>
</ul>
<blockquote>
<p>üëâ <strong>Example Use-case</strong>:</p>
<p>A DAO wants to bridge tokens to another chain and then deposit the tokens into a vault. After a certain date, it wants to allow a governance proposal to trigger unwinding of the position. While the position is active, It may also want to delegate the right to change vault parameters to a specific committee as long as the parameters are within a certain range.</p>
<p>Without Valence Programs, the DAO would have two choices:<br />
<strong>Choice 1:</strong> Give the tokens to a <strong>multisig</strong> to execute actions on the DAO's behalf<br />
<strong>Choice 2:</strong> Write <strong>custom smart contracts</strong>, and deployed them across multiple chains, to handle the cross-chain token operations.</p>
<p><strong>Valence programs</strong> offer a third choice: the DAO does not need to trust a multisig, nor does it need to spend resources writing complex cross-chain logic.</p>
<p><strong>Leveraging the Valence Protocol allows the DAO to rapidly configure and deploy a solution that meets its needs.</strong></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="high-level-overview"><a class="header" href="#high-level-overview">High-level overview</a></h1>
<p>This section provides a high-level breakdown of the components that compose a Valence cross-chain program.</p>
<ul>
<li><a href="components/./domains.html">Domains</a></li>
<li><a href="components/./accounts.html">Accounts</a></li>
<li><a href="components/./libraries_and_functions.html">Libraries and Functions</a></li>
<li><a href="components/./programs_and_authorizations.html">Programs and Authorizations</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="domains"><a class="header" href="#domains">Domains</a></h1>
<p>A <strong>Valence Program</strong> is an instance of the <strong>Valence Protocol</strong>. A Valence program's execution can typically <em>span multiple Blockchains</em>. In the Valence Protocol, we refer to the various Blockchains that are supported as <strong>domains</strong>.</p>
<p>A <strong>Domain</strong> is an environment in which the components that form a program (more on these later) can be instantiated (deployed).</p>
<p><strong>Domains</strong> are defined by <strong>three properties</strong>:</p>
<ol>
<li>The <strong>Chain</strong>: the Blockchain's name <em>e.g. Neutron, Osmosis, Ethereum mainnet</em>.</li>
<li>The <strong>Execution environment</strong>: the environment under which programs (typically smart contracts) can be executed on that particular chain <em>e.g. CosmWasm, EVM, SVM</em>.</li>
<li>The type of <strong>Bridge</strong> used from the <strong>Main Domain</strong> to other domains <em>e.g. Polytone over IBC, Hyperlane</em>.</li>
</ol>
<p>Within a particular ecosystem of Blockchains (e.g. Cosmos), the Valence Protocol usually defines one specific domain as the <strong>Main Domain</strong>, on which some supporting infrastructure components are deployed. Think of it as the <em>home base</em> supporting the execution and operations of a Valence programs. This will be further clarified in the <a href="components/./authorizations_processors/_overview.html">Authorizations &amp; Processors</a> section.</p>
<p>Below is a simplified representation of a <em>program transferring tokens</em> from a given <strong>input account</strong> on the <strong>Neutron domain</strong>, a CosmWasm-enabled smart contract platform secured by the Cosmos Hub, to a specified <strong>output account</strong> on the <strong>Osmosis domain</strong>, a well-known DeFi platform in the Cosmos ecosystem.</p>
<pre class="mermaid">---
title: Valence cross-domain program
---
graph LR
  IA((Input
      Account))
  OA((Output
		  Account))
  subgraph Neutron
  IA
  end
  subgraph Osmosis
  IA -- 4/Transfer tokens --&gt; OA
  end
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="accounts"><a class="header" href="#accounts">Accounts</a></h1>
<p><strong>Valence Programs</strong> usually perform operations on tokens, accross multiple domains, and to ensure that the funds remain safe throughout a program's execution, they rely on a primitive called <strong>Valence Accounts</strong>.</p>
<p>A <strong>Valence Account</strong> is an escrow contract that can hold balances for various supported token-types (e.g., in Cosmos <code>ics-20</code> or <code>cw-20</code>) and ensures that only a restricted set of operations can be performed on the held tokens.
A <strong>Valence Account</strong> is created (instantiated) on a specific <strong>domain</strong>, and bound to a specific <strong>Valence Program</strong>. <strong>Valence Programs</strong> will typically use multiple accounts, during the program's lifecycle, for different purposes. <strong>Valence Accounts</strong> are generic in nature; how they are used to form a program is entirely up to the program's creator.</p>
<p>Using a simple <em>token swap program</em> as an example: the program receives an amount of <strong>Token A</strong> in an <strong>input account</strong>, and will <strong>swap</strong> these <strong>Token A</strong> for <strong>Token B</strong> using a <strong>DEX</strong> on the <strong>same domain</strong> (e.g. Neutron). After the swap operation, the received amount of <strong>Token B</strong> will be temporarily held in a <strong>transfer account</strong>, before being transfered to a final <strong>output account</strong> on another domain (e.g. Osmosis).</p>
<p>For this, the program will create the following accounts:</p>
<ul>
<li>A <strong>Valence Account</strong> is created on the <strong>Neutron domain</strong> to act as the <strong>Input account</strong>.</li>
<li>A <strong>Valence Account</strong> is created on the <strong>Neutron domain</strong> to act as the <strong>Transfer account</strong>.</li>
<li>A <strong>Valence Account</strong> is created on the <strong>Osmosis domain</strong> to act as the <strong>Output account</strong>.</li>
</ul>
<pre class="mermaid">---
title: Valence token swap program
---
graph LR
  IA((Input
    Account))
  TA((Transfer
    Account))
  OA((Output
	Account))
  DEX
  subgraph Neutron
  IA -- Swap Token A --&gt; DEX
  DEX -- Token B --&gt; TA
  end
  subgraph Osmosis
  TA -- 4/Transfer token B --&gt; OA
  end
</pre>
<p>Note: this is a simplified representation.</p>
<p><strong>Valence Accounts</strong> do not perform any operation by themselves on the held funds, the operations are performed by <strong><a href="components/./libraries_and_functions.html">Valence Libraries</a></strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libraries-and-functions"><a class="header" href="#libraries-and-functions">Libraries and Functions</a></h1>
<p><strong>Valence Libraries</strong> contain the business logic that can be applied to the funds held by <strong>Valence accounts</strong>. Most often, this logic is about <em>performing operations on tokens</em>, such as splitting, routing, or providing liquidity on a DEX. A <strong>Valence account</strong> has to first approve (authorize) a <strong>Valence library</strong> for it to perform operations on that account's balances. <strong>Valence Libraries</strong> expose <strong>Functions</strong> that it supports. <strong>Valence Programs</strong> can be composed of a more or less complex graph of <strong>Valence Accounts</strong> and <strong>Valence Libraries</strong> to form a more or less sophisticated cross-chain workflow. During the course of a <strong>Valence program</strong>'s execution, <strong>Functions</strong> are called by external parties, and trigger the library's operations on the linked accounts.</p>
<p>A typical pattern for a <strong>Valence Library</strong> is to have one (or more) <strong>input account(s)</strong> and one (or more) <strong>output account(s)</strong>. While many libraries implement this pattern, it is by no means a requirement.</p>
<p><strong>Valence Libraries</strong> play a critical role in integrating <strong>Valence Programs</strong> with existing decentralized apps and services that can be found in many Blockchain ecosystems e.g. DEXes, liquid staking, etc</p>
<p>Now that we know accounts cannot perform any operations by themselves, we need to revisit the <em>token swap program</em> example (mentioned on the <a href="components/./accounts.html">Accounts</a> page) and bring <strong>Valence Libraries</strong> into the picture: the program receives an amount of <strong>Token A</strong> in an <strong>input account</strong>, and a <strong>Token Swap</strong> library exposes a <strong>swap</strong> function that, when called, will perform a swap operation of <strong>Token A</strong> held by the <strong>input account</strong> for <strong>Token B</strong> using a <strong>DEX</strong> on the <strong>same domain</strong> (e.g. Neutron), and transfer them to the <strong>transfer account</strong>. A <strong>Token Transfer</strong> library, that exposes a <strong>transfer</strong> function, will transfer the <strong>Token B</strong> amount (when the function is called) to a final <strong>output account</strong> on another domain (e.g. Osmosis). In this scenario, the <strong>DEX</strong> is an existing service found on the hosting domain (e.g. <strong>Astroport</strong> on <strong>Neutron</strong>), so it is not part of the <strong>Valence Protocol</strong>.</p>
<p>The program is then composed of the following accounts &amp; libraries:</p>
<ul>
<li>A <strong>Valence Account</strong> is created on the <strong>Neutron domain</strong> to act as the <strong>Input account</strong>.</li>
<li>A <strong>Valence Account</strong> is created on the <strong>Neutron domain</strong> to act as the <strong>Transfer account</strong>.</li>
<li>A <strong>Token swap Valence Library</strong> is created on the <strong>Neutron domain</strong>, <em>authorized</em> by the <strong>Input Account</strong> (to be able to act on the held Token A balance), and <em>configured</em> with the <strong>Input account</strong> and <strong>Transfer account</strong> as the respective input and output for the swap operation.</li>
<li>A <strong>Token Transfer Valence Library</strong> is created on the <strong>Neutron domain</strong>, <em>authorized</em> by the <strong>Transfer Account</strong> (to be able to act on the held Token B balance), and <em>configured</em> with the <strong>Transfer account</strong> and <strong>Output account</strong> as the respective input and output for the swap operation.</li>
<li>A <strong>Valence Account</strong> is created on the <strong>Osmosis domain</strong> to act as the <strong>Output account</strong>.</li>
</ul>
<pre class="mermaid">---
title: Valence token swap program
---
graph LR
  FC[[Function call]]
  IA((Input
	Account))
  TA((Transfer
	Account))
  OA((Output
	Account))
  TS((Token
  	Swap Library))
  TT((Token
  	Transfer Library))
  DEX
  subgraph Neutron
  FC -- 1/Swap --&gt; TS
  TS -- Swap Token A --&gt; IA
  IA -- Token A --&gt; DEX
  DEX -- Token B --&gt; TA
  FC -- 2/Transfer --&gt; TT
  TT -- Transfer Token B --&gt; TA
  end
  subgraph Osmosis
  TA -- Token B --&gt; OA
  end
</pre>
<p>This example highlights the crucial role that <strong>Valence Libraries</strong> play for integrating <strong>Valence Programs</strong> with pre-existing decentralized apps and services.</p>
<p>One thing remains unclear in this example, though: how are <strong>Functions</strong> called? This is where <a href="components/./authorizations_and_execution.html">Authorizations and Execution</a> come into the picture.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="programs-and-authorizations"><a class="header" href="#programs-and-authorizations">Programs and Authorizations</a></h1>
<p>A <strong>Valence Program</strong> is an instance of the <strong>Valence Protocol</strong>. It is a particular arrangement and configuration of <a href="components/./accounts.html">accounts</a> and <a href="components/./libraries_and_functions.html">libraries</a> across multiple <a href="components/./domains.html">domains</a> e.g. a POL (protocol-owned liquidity) lending relationship between two parties. Similarly to how a <em>library</em> exposes executable <em>functions</em>, programs are associated with a set of executable <strong>Subroutines</strong>.</p>
<p>A <strong>Subroutine</strong> is a vector of <strong>Functions</strong>. A <strong>Subroutine</strong> can call out to one or more <strong>function(s)</strong> from a single library, or from different ones. A <strong>Subroutine</strong> is limited to <strong>one execution domain</strong> (i.e. it cannot use functions from libraries instantiated on multiple domains).</p>
<p>A <strong>Subroutine</strong> can be:</p>
<ul>
<li><strong>Non Atomic</strong>, i.e., execute function one, if it succeeds execute function two, and if that succeeds do function three, and so on.</li>
<li>or <strong>Atomic</strong>, i.e., execution function one, function two, and function three, and if any of them fail then revert all steps.</li>
</ul>
<p><strong>Valence programs</strong> are typically used to implement complex, cross-chain workflows performing financial operations, in a trust-minimized way, on funds provided by various third-parties. Therefore, it goes without saying that a program's subroutines should not (all and/or always) be allowed to be executed by just about anyone.</p>
<p>To specify fine-grained controls over who can initiate the execution of a <strong>Subroutine</strong>, program creators use the <strong>Authorizations</strong> module.</p>
<p>The <strong>Authorizations</strong> module is a powerful and flexible system that supports simple to advanced access control configuration schemes, such as:</p>
<ul>
<li><strong>Anyone</strong> can initiate execution of a <strong>Subroutine</strong></li>
<li>Only <strong>permissioned actors</strong> can initiate execution of a <strong>Subroutine</strong></li>
<li>Execution can only be initiated <strong>after a starting timestamp/block height</strong></li>
<li>Execution can only be initiated <strong>up to a certain timestamp/block height</strong></li>
<li>Authorizations are <strong>tokenized</strong>, which means they can be transferred by the holder or used in more sophisticated DeFi scenarios</li>
<li>Authorizations can <strong>expire</strong></li>
<li>Authorizations can be <strong>enabled/disabled</strong></li>
<li>Authorizations can tightly <strong>constrain parameters</strong>. For example, an authorization to execute a token transfer message can limit the execution to only supply the amount argument, and not the denom or receiver in the transfer message</li>
</ul>
<p>To support the on-chain execution of <strong>Valence Programs</strong>, the <strong>Valence Protocol</strong> provides two important contracts: the <strong>Authorizations contract</strong> and the <strong>Processor contract</strong>.</p>
<p>The <strong>Authorizations contract</strong> is the entry point for users. The user sends a set of messages to the Authorizations contract and the label (id) of the authorization they want to execute. The Authorizations contract then verifies that the sender is authorized, that the messages are valid, constructs a <em>MessageBatch</em> based on the subroutine and passes this batch to the <strong>Processor contract</strong> for execution. The authority to execute any <em>Subroutine</em> is tokenized so that these tokens can be transferred on-chain.</p>
<p>The <strong>Processor contract</strong> receives a <em>MessageBatch</em> and executes the contained <em>Messages</em> in sequence. It does this by maintaining execution queues, where the queue items are <em>Subroutines.</em> The processor exposes a <code>Tick</code> message that allows anyone to trigger the processor, whereby the first batch of the queue is executed or moved to the back of the queue if it's not executable yet (e.g. retry period has not passed).</p>
<pre class="mermaid">graph LR;
	User --&gt; |Subroutine| Auth(Authorizations)
	Auth --&gt; |Message Batch| P(Processor)
	P --&gt; |Function 1| S1[Library 1]
	P --&gt; |Function 2| S2[Library 2]
	P --&gt; |Function N| S3[Library N]
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="authorizations--processors"><a class="header" href="#authorizations--processors">Authorizations &amp; Processors</a></h1>
<p>The <strong>Authorizations</strong> and <strong>Processor</strong> contracts are foundational pieces of the <strong>Valence Protocol</strong>, as they enable on-chain (and cross-chain) execution of <strong>Valence Programs</strong>, and enforce access control to the programs's <strong>subroutines</strong> via <strong>authorizations</strong>.</p>
<p>This section goes into more details in explaining the rationale for these contracts, and shares insights about their technical implementation as well as how end-users can interact with <strong>Valence programs</strong> via authorizations.</p>
<h2 id="rationale"><a class="header" href="#rationale">Rationale</a></h2>
<ul>
<li>To have a general purpose set of smart contracts that will provide the users (anyone if the authorization is permissionless or authorization token owners if it‚Äôs permissioned) with a single point of entry to interact with the Valence program, which can have libraries and accounts deployed on multiple chains.</li>
<li>To have all the user authorizations for multiple domains in a single place, making it very easy to control the application.</li>
<li>To have a single address (<code>Processor</code>) that will execute the messages for all the contracts in a domain using execution queues.</li>
<li>To only tick a single contract (<code>Processor</code>) which will go through the queues to route and execute the messages.</li>
<li>To be able to create, edit or remove different application permissions with ease.</li>
</ul>
<h2 id="technical-deep-dive"><a class="header" href="#technical-deep-dive">Technical deep-dive:</a></h2>
<ul>
<li><a href="authorizations_processors/./assumptions.html">Assumptions</a></li>
<li><a href="authorizations_processors/./processor.html">Processor Contract</a></li>
<li><a href="authorizations_processors/./authorization.html">Authorization Contract</a>
<ul>
<li><a href="authorizations_processors/./authorization_instantiation.html">Instantiation</a></li>
<li><a href="authorizations_processors/./authorization_owner_actions.html">Owner Actions</a></li>
<li><a href="authorizations_processors/./authorization_user_actions.html">User Actions</a></li>
</ul>
</li>
<li><a href="authorizations_processors/./callbacks.html">Callbacks</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assumptions"><a class="header" href="#assumptions">Assumptions</a></h1>
<ul>
<li>
<p><strong>Funds</strong>: You cannot send funds with the messages.</p>
</li>
<li>
<p><strong>Bridging</strong>: We are assuming that messages can be sent and confirmed bidirectionally between domains. From the authorization contract on the main domain to the processor in a different domain in one direction and the callback confirming the correct or failed execution in the other direction.</p>
</li>
<li>
<p><strong>Instantiation</strong>: All these contracts can be instantiated beforehand and off-chain having predictable addresses. Here is an example instantiation flow using Polytone:</p>
<ul>
<li>Predict <code>authorization</code> contract address</li>
<li>Instantiate polytone contracts &amp; set up relayers.</li>
<li>Predict <code>proxy</code> contract address for the <code>authorization</code> contract on each external domain.</li>
<li>Predict <code>proxy</code> contract address on the main domain for each processor on external domains.</li>
<li>Instantiate all <code>processors</code>. The sender on external domains will be the predicted <code>proxy</code> and on the main domain it will be the authorization contract iself.</li>
<li>Instantiate authorization contract with all the processors and their predicted proxies for external domains and the processor on the main domain.</li>
</ul>
</li>
<li>
<p><strong>Relaying</strong>: relayers will be running once everything is instantiated.</p>
</li>
<li>
<p><strong>Tokenfactory</strong>: the main domain has the token factory module with no token creation fee so that we can create and mint these non fungible tokens with no additional cost.</p>
</li>
<li>
<p><strong>Domains</strong>: in the current version, actions in each authorization will be limited to a single domain.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="processor"><a class="header" href="#processor">Processor</a></h1>
<p>The <code>Processor</code> will be a contract on each domain of our workflow. It handles the execution queues which contain <code>Message Batches</code>. The <code>Processor</code> can be <code>ticked</code> permissionlessly, which will execute the next <code>Message Batch</code> in the queue if this one is executable or rotate it to the back of the queue if it isn't executable yet. The processor will also handle the <code>Retry</code> logic for each batch (if the batch is atomic) or function (if the batch is non atomic). After a <code>Message Batch</code> has been executed successfully or it reached the maximum amount of retries, it will be removed from the execution queue and the <code>Processor</code> will send a callback with the execution information to the <code>Authorization</code> contract.</p>
<p>The processors will be instantiated in advance with the correct address that can send messages to them, according to the <em>InstantiationFlow</em> described in the <a href="authorizations_processors/assumptions.html">Assumptions</a> section.</p>
<p>The <code>Authorization</code> contract will be the only address allowed to add list of functions to the execution queues. It will also be allowed to Pause/Resume the <code>Processor</code> or to arbitrarily remove functions from the queues or add certain messages at a specific position.</p>
<p>There will be two execution queues: one <code>High</code> and one <code>Med</code>. This will allow giving different priorities to <code>Message</code>.</p>
<h3 id="execution"><a class="header" href="#execution">Execution</a></h3>
<p>When a processor is <code>Ticked</code> we will take the first <code>MessageBatch</code> from the queue (<code>High</code> if there are batches there or <code>Med</code> if there aren‚Äôt).
After taking them, we will execute them in different ways depending if the batch is <code>Atomic</code> or <code>NonAtomic</code>.</p>
<ul>
<li>For <code>Atomic</code> batches, the <code>Processor</code> will execute them by sending them to itself and trying to execute them in a <code>Fire and Forget</code> manner. If this execution fails, we will check the <code>RetryLogic</code> of the batch to decide if they are to be re-queued or not (if not, we will send a callback with <code>Rejected</code> status to the authorization contract).
If they succeeded we will send a callback with <code>Executed</code> status to the Authorization contract.</li>
<li>For <code>NonAtomic</code> batches, we will execute the functions one by one and applying the RetryLogic individually to each function if they fail. <code>NonAtomic</code> functions might also be confirmed via <code>CallbackConfirmations</code> in which case we will keep them in a separate Map until we receive that specific callback.
Each time a function is confirmed, we will re-queue the batch and keep track of what function we have to execute next.
If at some point a function uses up all its retries, we will send a callback to the Authorization contract with a <code>PartiallyExecuted(num_of_functions_executed)</code> status. If all of them succeed it will be <code>Executed</code> and if none of them were it will be <code>Rejected</code>.
For <code>NonAtomic</code> batches, we need to tick the processor each time the batch is at the top of the queue to continue, so we will need at least as many ticks as number of functions we have in the batch, and each function has to wait for its turn.</li>
</ul>
<h3 id="storage"><a class="header" href="#storage">Storage</a></h3>
<p>The <code>Processor</code> will receive batches of messages from the authorization contract and will enqueue them in a custom storage structure we designed for this purpose, called a <code>QueueMap</code>. This structure is a FIFO queue with owner privileges (allows the owner to insert or remove from any position in the queue).
Each ‚Äúitem‚Äù stored in the queue is an object <code>MessageBatch</code> that looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MessageBatch {
    pub id: u64,
    pub msgs: Vec&lt;ProcessorMessage&gt;,
    pub subroutine: Subroutine,
    pub priority: Priority,
    pub retry: Option&lt;CurrentRetry&gt;,
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>id: represents the global id of the batch. The <code>Authorization</code> contract, to understand the callbacks that it will receive from each processor, identifies each batch with an id. This id is unique for the entire application.</li>
<li>msgs: the messages the processor needs to execute for this batch (e.g. a CosmWasm ExecuteMsg or MigrateMsg).</li>
<li>subroutine: This is the config that the authorization table defines for the execution of these functions. With this field we can know if the functions need to be executed atomically or not atomically, for example, and the retry logic for each batch/function depending on the config type.</li>
<li>priority (for internal use): batches will be queued in different priority queues when they are received from the authorization contract. We also keep this priority here because they might need to be re-queued after a failed execution and we need to know where to re-queue them.</li>
<li>retry (for internal use): we are keeping the current retry we are at (if the execution previously failed) to know when to abort if we exceed the max retry amounts.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="authorization"><a class="header" href="#authorization">Authorization</a></h1>
<p>The authorization contract will be a single contract deployed on the main domain and that will define the authorizations of the top-level application, which can include libraries in different domains (chains). For each domain, there will be one Processor (with its corresponding execution queues). The <code>Authorization</code> contract will connect to all of the <code>Processors</code> using a connector (e.g. Polytone, Hyperlane‚Ä¶) and will route the <code>Message Batches</code> to be executed to the right domain. At the same time, for each external domain, we will have a proxy contract in the main domain which will receive the callbacks sent from the processor on the external domain with the <code>ExecutionResult</code> of the <code>Message Batch</code>.</p>
<p>The contract will be instantiated once at the very beginning and will be used during the entire top-level application lifetime. Users will never interact with the individual Smart Contracts of each workflow, but with the Authorization contract directly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="instantiation"><a class="header" href="#instantiation">Instantiation</a></h1>
<p>When the contract is instantiated, it will be provided the following information:</p>
<ul>
<li>
<p>Processor contract on main domain.</p>
</li>
<li>
<p>[(Domain, Connector(Polytone_note_contract), Processor_contract_on_domain, callback_proxy, IBC_Timeout_settings)]: If it's a cross domain application, an array will be passed with each external domain label and its corresponding connector contracts and proxies that will be instantiated before hand. For each connector, there will be also a proxy corresponding to that external domain because it‚Äôs a two-way communication flow and we need to receive callbacks. Additionally, we need a set of <code>Timeout</code> settings for the bridge, to know for how long the messages sent through the connector are going to be valid.</p>
</li>
<li>
<p>Admin of the contract (if different to sender).</p>
</li>
</ul>
<p>The instantiation will set up all the processors on each domain so that we can start instantiating the services afterwards and providing the correct <code>Processor</code> addresses to each of them depending on which domain they are in.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="owner-functions"><a class="header" href="#owner-functions">Owner Functions</a></h1>
<ul>
<li>
<p><code>create_authorizations(vec[Authorization])</code>: provides an authorization list which is the core information of the authorization contract, it will include all the possible set of functions that can be executed. It will contain the following information:</p>
<ul>
<li>
<p>Label: unique name of the authorization. This label will be used to identify the authorization and will be used as subdenom of the tokenfactory token in case it is permissioned. Due to tokenfactory module restrictions, the max length of this field is 44 characters.
Example: If the label is <code>withdraw</code> and only address <code>neutron123</code> is allowed to execute this authorization, we will create the token <code>factory/&lt;contract_addr&gt;/withdraw</code> and mint one to that address. If <code>withdraw</code> was permissionless, there is no need for any token, so it's not created.</p>
</li>
<li>
<p>Mode: can either be <code>Permissioned</code> or <code>Permissionless</code>. If <code>Permissionless</code> is chosen, any address can execute this function list. In case of <code>Permissioned</code>, we will also say what type of permissioned type we want (with <code>CallLimit</code> or without), a list of addresses will be provided for both cases. In case there is a <code>CallLimit</code> we will mint a certain amount of tokens for each address that is passed, in case there isn‚Äôt we will only mint one token and that token will be used all the time.</p>
</li>
<li>
<p>NotBefore: from what time the authorization can be executed. We can specify a block height or a timestamp.</p>
</li>
<li>
<p>Expiration: until when (what block or timestamp) this authorization is valid.</p>
</li>
<li>
<p>MaxConcurrentExecutions (default 1): to avoid DDoS attacks and to clog the execution queues, we will allow certain authorizations subroutines to be present a maximum amount of times (default 1 unless overwritten) in the execution queue.</p>
</li>
<li>
<p>Subroutine: set of functions in a specific order to be executed. Subroutines can be of two types: <code>Atomic</code> or <code>NonAtomic</code>. For the <code>Atomic</code> subroutines, we will provide an array of <code>Atomic</code> functions and an optional <code>RetryLogic</code> for the entire subroutine. For the <code>NonAtomic</code> subroutines we will just provide an array of <code>NonAtomic</code> functions.</p>
<ul>
<li>
<p><code>AtomicFunction</code>: each Atomic function has the following parameters:</p>
<ul>
<li>
<p>Domain of execution (must be the same for all functions in v1).</p>
</li>
<li>
<p>MessageDetails: type (e.g. CosmWasmExecuteMsg) and message (name of the message in the ExecuteMsg json that can be executed with, if applied, three list of parameters: one for <code>MustBeIncluded</code>, one for <code>CannotBeIncluded</code> and one for <code>MustBeValue</code>. (This gives more control over the authorizations. Example: we want one authorization to provide the message with parameters (admin function for that service) but another authorization for the message without any Parameters (user function for that service).</p>
</li>
<li>
<p>Contract address that will execute it.</p>
</li>
</ul>
</li>
<li>
<p><code>NonAtomicFunction</code>: each NonAtomic function has the following parameters:</p>
<ul>
<li>
<p>Domain of execution</p>
</li>
<li>
<p>MessageDetails (like above).</p>
</li>
<li>
<p>Contract address that will execute it.</p>
</li>
<li>
<p>RetryLogic (optional, self-explanatory).</p>
</li>
<li>
<p>CallbackConfirmation (optional): This defines if a <code>NonAtomicFunction</code> is completed after receiving a callback (Binary) from a specific address instead of after a correct execution. This is used in case of the correct message execution not being enough to consider the message completed, so it will define what callback we should receive from a specific address to flag that message as completed. For this, the processor will append an <code>execution_id</code> to the message which will be also passed in the callback by the service to identify what function this callback is for.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Priority (default Med): priority of a set of functions can be set to High. If this is the case, they will go into a preferential execution queue. Messages in the <code>High</code> priority queue will be taken over messages in the <code>Med</code> priority queue.
All authorizations will have an initial state of <code>Enabled</code> .</p>
</li>
</ul>
<p>Here is an example of an Authorization table after its creation:</p>
<p><img src="authorizations_processors/../img/authorization_table.png" alt="Authorization Table" /></p>
</li>
<li>
<p><code>add_external_domains([external_domains])</code>: if we want to add external domains after instantiation.</p>
</li>
<li>
<p><code>modify_authorization(label, updated_values)</code>: can modify certain updatable fields of the authorization: start_time, expiration, max_concurrent_executions and priority.</p>
</li>
<li>
<p><code>disable_authorization(label)</code>: puts an Authorization to state <code>Disabled</code>. These authorizations can not be run anymore.</p>
</li>
<li>
<p><code>enable_authorization(label)</code>: puts an Authorization to state <code>Enabled</code> so that they can be run again.</p>
</li>
<li>
<p><code>mint_authorization(label, vec[(addresses, Optional: amounts)])</code>: if the authorization is <code>Permissioned</code> with <code>CallLimit: true</code>, this function will mint the corresponding token amounts of that authorization to the addresses provided. If <code>CallLimit: false</code> it will mint 1 token to the new addresses provided.</p>
</li>
<li>
<p><code>pause_processor(domain)</code>: pause the processor of the domain.</p>
</li>
<li>
<p><code>resume_processor(domain)</code>: resume the processor of the domain.</p>
</li>
<li>
<p><code>insert_messages(label, queue_position, queue_type, vec[ProcessorMessage])</code>: adds these set of messages to the queue at a specific position in the queue.</p>
</li>
<li>
<p><code>evict_messages(label, queue_position, queue_type)</code>: remove the set of messages from the specific position in a queue.</p>
</li>
<li>
<p><code>add_sub_owners(vec[addresses])</code>: add the current addresses as 2nd tier owners. These sub_owners can do everything except adding/removing admins.</p>
</li>
<li>
<p><code>remove_sub_owners(vec[addresses])</code>: remove these addresses from the sub_owner list.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="user-actions"><a class="header" href="#user-actions">User Actions</a></h1>
<ul>
<li>
<p><code>send_msgs(label, vec[ProcessorMessage])</code>: users can run an authorization with a specific label. If the authorization is <code>Permissioned</code>, the authorization contract will check if they are allowed to execute it by checking that the user has the token in its wallet if it's <code>Permissioned (without limit)</code> or that the user sent the token along with the messages if it's <code>Permissioned (with limit)</code>. Along with the authorization label, the user will provide an array of encoded messages, together with the message type (e.g. <code>CosmwasmExecuteMsg</code>) and any other parameters for that specific ProcessorMessage (e.g. for a <code>CosmwasmMigrateMsg</code> we need to also pass a code_id). The contract will then check that the messages match the ones defined in the authorization (and in the correct order) and that all Parameters restrictions, if applied, are correct.</p>
<p>If all checks are correct, the contract will route the messages to the correct <code>Processor</code> with an <code>execution_id</code> for the processor to callback with. This <code>execution_id</code> is unique for the entire application.
If the execution of all the actions are confirmed via a callback, we will burn the token and if they fail, we will send the token back.
Here is an example flowchart of how a user interacts with the authorization contract to execute messages in a service sitting on a domain:</p>
</li>
</ul>
<p><img src="authorizations_processors/../img/user_flowchart.png" alt="User flowchart" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="callbacks"><a class="header" href="#callbacks">Callbacks</a></h1>
<p>There are different types of callbacks in our application. Each of them have a specific function and are used in different parts of the application.</p>
<h2 id="function-callbacks"><a class="header" href="#function-callbacks">Function Callbacks</a></h2>
<p>For the execution of <code>NonAtomic</code> batches, each function in the batch can optionally be confirmed with a callback from a specific address. When the processor reaches a function that requires a callback, it will inject the execution_id of the batch into the message that is going to be executed on the library, which means that the library needs to be ready to receive that execution_id and know what the expected callback is and from where it has to come from to confirm that function, otherwise that function will stay unconfirmed and the batch will not move to the next function. The callback will be sent to the processor with the execution_id so that the processor can know what function is being confirmed. The processor will then validate that the correct callback was received from the correct address.</p>
<p>If the processor receives the expected callback from the correct address, the batch will move to the next function. If it receives a different callback than expected from that address, the execution of that function will be considered failed and it will be retried (if applicable). In any case, a callback must be received to determine if the function was successful or not.</p>
<h2 id="processor-callbacks"><a class="header" href="#processor-callbacks">Processor Callbacks</a></h2>
<p>Once a Processor batch is executed or it fails and there are no more retries available, the Processor will send a callback to the Authorizations contract with the execution_id of the batch and the result of the execution. All this information will be stored in the <code>Authorization</code> contract state so the history of all executions can be queried from it. This is how a <code>ProcessorCallback</code> looks like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ProcessorCallbackInfo {
    // Execution ID that the callback was for
    pub execution_id: u64,
    // Who started this operation, used for tokenfactory actions
    pub initiator: OperationInitiator,
    // Address that can send a bridge timeout or success for the message (if applied)
    pub bridge_callback_address: Option&lt;Addr&gt;,
    // Address that will send the callback for the processor
    pub processor_callback_address: Addr,
    // Domain that the callback came from
    pub domain: Domain,
    // Label of the authorization
    pub label: String,
    // Messages that were sent to the processor
    pub messages: Vec&lt;ProcessorMessage&gt;,
    // Optional ttl for re-sending in case of bridged timeouts
    pub ttl: Option&lt;Expiration&gt;,
    // Result of the execution
    pub execution_result: ExecutionResult,
}

pub enum ExecutionResult {
    InProcess,
    // Everthing executed successfully
    Success,
    // Execution was rejected, and the reason
    Rejected(String),
    // Partially executed, for non-atomic function batches
    // Indicates how many functions were executed and the reason the next function was not executed
    PartiallyExecuted(usize, String),
    // Removed by Owner - happens when, from the authorization contract, a remove item from queue is sent
    RemovedByOwner,
    // Timeout - happens when the bridged message times out
    // We'll use a flag to indicate if the timeout is retriable or not
    // true - retriable
    // false - not retriable
    Timeout(bool),
    // Unexpected error that should never happen but we'll store it here if it ever does
    UnexpectedError(String),
}
<span class="boring">}</span></code></pre></pre>
<p>The key information from here is the <code>label</code>, to identify the authorization that was executed; the <code>messages</code>, to identify what the user sent; and the <code>execution_result</code>, to know if the execution was successful, partially successful or rejected.</p>
<h2 id="bridge-callbacks"><a class="header" href="#bridge-callbacks">Bridge Callbacks</a></h2>
<p>When messages need to be sent through bridges because we are executing batches on external domains, we need to know if, for example, a timeout happened and keep track of it. For this reason we have callbacks per bridge that we support and specific logic that will be executed if they are received. For <code>Polytone</code> timeouts, we will check if the <code>ttl</code> field has not expired and allow permissionless retries if it's still valid. In case the <code>ttl</code> has expired, we will set the ExecutionResult to timeout and not retriable, then send the authorization token back to the user if the user sent it to execute the authorization.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libraries"><a class="header" href="#libraries">Libraries</a></h1>
<p>This section contains a detailed description of the various libraries that can be used to rapidly build Valence cross-chain programs.</p>
<p><strong>Valence Protocol libraries</strong>:</p>
<ul>
<li><a href="libraries/./astroport-lper.html">Astroport LPer</a></li>
<li><a href="libraries/./astroport-withdrawer.html">Astroport Withdrawer</a></li>
<li><a href="libraries/./forwarder.html">Forwarder</a></li>
<li><a href="libraries/./generic-ibc-transfer.html">Generic IBC Transfer</a></li>
<li><a href="libraries/./neutron-ibc-transfer.html">Neutron IBC Transfer</a></li>
<li><a href="libraries/./osmosis-cl-lper.html">Osmosis CL LPer</a></li>
<li><a href="libraries/./osmosis-cl-withdrawer.html">Osmosis CL Withdrawer</a></li>
<li><a href="libraries/./osmosis-gamm-lper.html">Osmosis GAMM LPer</a></li>
<li><a href="libraries/./osmosis-gamm-withdrawer.html">Osmosis GAMM Withdrawer</a></li>
<li><a href="libraries/./reverse-splitter.html">Reverse Splitter</a></li>
<li><a href="libraries/./splitter.html">Splitter</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="astroport-lper-library"><a class="header" href="#astroport-lper-library">Astroport LPer library</a></h1>
<p>The <strong>Valence Astroport LPer library</strong> library allows to <strong>provide liquidity</strong> into an <strong>Astroport Liquidity Pool</strong> from an <strong>input account</strong> and deposit the <strong>LP tokens</strong> into an <strong>output account</strong>.</p>
<h2 id="high-level-flow"><a class="header" href="#high-level-flow">High-level flow</a></h2>
<pre class="mermaid">---
title: Astroport Liquidity Provider
---
graph LR
  IA((Input
      Account))
  OA((Output
		  Account))
  P[Processor]
  S[Astroport
      Liquidity
      Provider]
  AP[Astroport
     Pool]
  P -- 1/Provide Liquidity --&gt; S
  S -- 2/Query balances --&gt; IA
  S -- 3/Compute amounts --&gt; S
  S -- 4/Do Provide Liquidity --&gt; IA
  IA -- 5/Provide Liquidity
				  [Tokens] --&gt; AP
  AP -- 5'/Transfer LP Tokens --&gt; OA

</pre>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>ProvideDoubleSidedLiquidity</strong></td><td><code>expected_pool_ratio_range: Option&lt;DecimalRange&gt;</code></td><td>Provide double-sided liquidity to the pre-configured <strong>Astroport Pool</strong> from the <strong>input account</strong>, and deposit the <strong>LP tokens</strong> into the <strong>output account</strong>. Abort it the pool ratio is not within the <code>expected_pool_ratio</code> range (if specified).</td></tr>
<tr><td><strong>ProvideSingleSidedLiquidity</strong></td><td><code>asset: String</code><br><code>limit: Option&lt;Uint128&gt;</code><br><code>expected_pool_ratio_range: Option&lt;DecimalRange&gt;</code></td><td>Provide single-sided liquidity for the specified <code>asset</code> to the pre-configured <strong>Astroport Pool</strong> from the <strong>input account</strong>, and deposit the <strong>LP tokens</strong> into the <strong>output account</strong>. Abort it the pool ratio is not within the <code>expected_pool_ratio</code> range (if specified).</td></tr>
</tbody></table>
</div>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>The library is configured on instantiation via the <code>LibraryConfig</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LibraryConfig {
    // Account from which the funds are LPed
    pub input_addr: LibraryAccountType,
    // Account to which the LP tokens are forwarded
    pub output_addr: LibraryAccountType,
    // Pool address
    pub pool_addr: String,
    // LP configuration
    pub lp_config: LiquidityProviderConfig,
}

pub struct LiquidityProviderConfig {
    // Pool type, old Astroport pools use Cw20 lp tokens and new pools use native tokens, so we specify here what kind of token we are going to get.
    // We also provide the PairType structure of the right Astroport version that we are going to use for each scenario
    pub pool_type: PoolType,
    // Denoms of both native assets we are going to provide liquidity for
    pub asset_data: AssetData,
    // Slippage tolerance
    pub slippage_tolerance: Option&lt;Decimal&gt;,
}

#[cw_serde]
pub enum PoolType {
    NativeLpToken(valence_astroport_utils::astroport_native_lp_token::PairType),
    Cw20LpToken(valence_astroport_utils::astroport_cw20_lp_token::PairType),
}


pub struct AssetData {
    pub asset1: String,
    pub asset2: String,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="astroport-withdrawer-library"><a class="header" href="#astroport-withdrawer-library">Astroport Withdrawer library</a></h1>
<p>The <strong>Valence Astroport Withdrawer library</strong> library allows to <strong>withdraw liquidity</strong> from an Astroport Liquidity Pool from an <strong>input account</strong> an deposit the withdrawed tokens into an <strong>output account</strong>.</p>
<h2 id="high-level-flow-1"><a class="header" href="#high-level-flow-1">High-level flow</a></h2>
<pre class="mermaid">---
title: Astroport Liquidity Withdrawal
---
graph LR
  IA((Input
      Account))
  OA((Output
		  Account))
  P[Processor]
  S[Astroport
      Liquidity
      Withdrawal]
  AP[Astroport
     Pool]
  P -- 1/Withdraw Liquidity --&gt; S
  S -- 2/Query balances --&gt; IA
  S -- 3/Compute amounts --&gt; S
  S -- 4/Do Withdraw Liquidity --&gt; IA
  IA -- 5/Withdraw Liquidity
				  [LP Tokens] --&gt; AP
  AP -- 5'/Transfer assets --&gt; OA
</pre>
<h2 id="functions-1"><a class="header" href="#functions-1">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>WithdrawLiquidity</strong></td><td>-</td><td>Withdraw liquidity from the configured <strong>Astroport Pool</strong> from the <strong>input account</strong> and deposit the withdrawed tokens into the configured <strong>output account</strong></td></tr>
</tbody></table>
</div>
<h2 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h2>
<p>The library is configured on instantiation via the <code>LibraryConfig</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LibraryConfig {
    // Account holding the LP position
    pub input_addr: LibraryAccountType,
    // Account to which the withdrawn assets are forwarded
    pub output_addr: LibraryAccountType,
    // Pool address
    pub pool_addr: String,
    // Liquidity withdrawer configuration
    pub withdrawer_config: LiquidityWithdrawerConfig,
}

pub struct LiquidityWithdrawerConfig {
    // Pool type, old Astroport pools use Cw20 lp tokens and new pools use native tokens, so we specify here what kind of token we are will use.
    // We also provide the PairType structure of the right Astroport version that we are going to use for each scenario
    pub pool_type: PoolType,
}

pub enum PoolType {
    NativeLpToken,
    Cw20LpToken,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="valence-forwarder-library"><a class="header" href="#valence-forwarder-library">Valence Forwarder library</a></h1>
<p>The <strong>Valence Forwarder</strong> library allows to <strong>continuously forward funds</strong> from an <strong>input account</strong> to an <strong>output account</strong>, following some time <strong>constraints</strong>. It is typically used as part of a <strong>Valence Program</strong>. In that context, a <strong>Processor</strong> contract will be the main contract interacting with the Forwarder library.</p>
<h2 id="high-level-flow-2"><a class="header" href="#high-level-flow-2">High-level flow</a></h2>
<pre class="mermaid">---
title: Forwarder Library
---
graph LR
  IA((Input
      Account))
  OA((Output
		  Account))
  P[Processor]
  S[Forwarder
    Library]
  P -- 1/Forward --&gt; S
  S -- 2/Query balances --&gt; IA
  S -- 3/Do Send funds --&gt; IA
  IA -- 4/Send funds --&gt; OA
</pre>
<h2 id="functions-2"><a class="header" href="#functions-2">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>Forward</strong></td><td>-</td><td>Forward funds from the configured <strong>input account</strong> to the <strong>output account</strong>, according to the <strong>forwarding configs</strong> &amp; <strong>constraints</strong>.</td></tr>
</tbody></table>
</div>
<h2 id="configuration-2"><a class="header" href="#configuration-2">Configuration</a></h2>
<p>The library is configured on instantiation via the <code>LibraryConfig</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LibraryConfig {
    // Account from which the funds are pulled
    pub input_addr: LibraryAccountType,
    // Account to which the funds are sent
    pub output_addr: LibraryAccountType,
    // Forwarding configuration per denom
    pub forwarding_configs: Vec&lt;UncheckedForwardingConfig&gt;,
    // Constraints on forwarding operations
    pub forwarding_constraints: ForwardingConstraints,
}

pub struct UncheckedForwardingConfig {
    // Denom to be forwarded (either native or CW20)
    pub denom: UncheckedDenom,
    // Max amount of tokens to be transferred per Forward operation
    pub max_amount: Uint128,
}

// Time constraints on forwarding operations
pub struct ForwardingConstraints {
    // Minimum interval between 2 successive forward operations,
    // specified either as a number of blocks, or as a time delta.
    min_interval: Option&lt;Duration&gt;,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="valence-generic-ibc-transfer-library"><a class="header" href="#valence-generic-ibc-transfer-library">Valence Generic IBC Transfer library</a></h1>
<p>The <strong>Valence Generic IBC Transfer</strong> library allows to transfer funds over IBC from an <strong>input account</strong> on a source chain to an <strong>output account</strong> on a destination chain. It is typically used as part of a <strong>Valence Program</strong>. In that context, a <strong>Processor</strong> contract will be the main contract interacting with the Forwarder library.</p>
<p><strong>Note</strong>: this library should not be used on <strong>Neutron</strong>, which requires some fees to be paid to relayers for IBC transfers. For Neutron, prefer using the dedicated (and optimized) <strong><a href="libraries/./neutron-ibc-transfer.html">Neutron IBC Transfer library</a></strong> instead.</p>
<h2 id="high-level-flow-3"><a class="header" href="#high-level-flow-3">High-level flow</a></h2>
<pre class="mermaid">---
title: Generic IBC Transfer Library
---
graph LR
  IA((Input
      Account))
  OA((Output
		  Account))
  P[Processor]
  S[Gen IBC Transfer
    Library]
  subgraph Chain 1
  P -- 1/IbcTransfer --&gt; S
  S -- 2/Query balances --&gt; IA
  S -- 3/Do Send funds --&gt; IA
  end
  subgraph Chain 2
  IA -- 4/IBC Transfer --&gt; OA
  end
</pre>
<h2 id="functions-3"><a class="header" href="#functions-3">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>IbcTransfer</strong></td><td>-</td><td>Transfer funds over IBC from an <strong>input account</strong> on a source chain to an <strong>output account</strong> on a destination chain.</td></tr>
</tbody></table>
</div>
<h2 id="configuration-3"><a class="header" href="#configuration-3">Configuration</a></h2>
<p>The library is configured on instantiation via the <code>LibraryConfig</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct LibraryConfig {
  // Account from which the funds are pulled (on the source chain)
  input_addr: LibraryAccountType,
  // Account to which the funds are sent (on the destination chain)
  output_addr: String,
  // Denom of the token to transfer
  denom: UncheckedDenom,
  // Amount to be transferred, either a fixed amount or the whole available balance.
  amount: IbcTransferAmount,
  // Memo to be passed in the IBC transfer message.
  memo: String,
  // Information about the destination chain.
  remote_chain_info: RemoteChainInfo,
  // Denom map for the Packet-Forwarding Middleware, to perform a multi-hop transfer.
  denom_to_pfm_map: BTreeMap&lt;String, PacketForwardMiddlewareConfig&gt;,
}

// Defines the amount to be transferred, either a fixed amount or the whole available balance.
enum IbcTransferAmount {
  // Transfer the full available balance of the input account.
  FullAmount,
  // Transfer the specified amount of tokens.
  FixedAmount(Uint128),
}

pub struct RemoteChainInfo {
  // Channel of the IBC connection to be used.
  channel_id: String,
  // Port of  the IBC connection to be used.
  port_id: Option&lt;String&gt;,
  // Timeout for the IBC transfer.
  ibc_transfer_timeout: Option&lt;Uint64&gt;,
}

// Configuration for a multi-hop transfer using the Packet Forwarding Middleware
struct PacketForwardMiddlewareConfig {
  // Channel ID from the source chain to the intermediate chain
  local_to_hop_chain_channel_id: String,
  // Channel ID from the intermediate to the destination chain
  hop_to_destination_chain_channel_id: String,
  // Temporary receiver address on the intermediate chain
  hop_chain_receiver_address: String,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="valence-neutron-ibc-transfer-library"><a class="header" href="#valence-neutron-ibc-transfer-library">Valence Neutron IBC Transfer library</a></h1>
<p>The <strong>Valence Neutron IBC Transfer</strong> library allows to transfer funds over IBC from an <strong>input account</strong> on <strong>Neutron</strong> to an <strong>output account</strong> on a destination chain. It is typically used as part of a <strong>Valence Program</strong>. In that context, a <strong>Processor</strong> contract will be the main contract interacting with the Forwarder library.</p>
<p>Note: this library should not be used on another CosmWasm chain than <strong>Neutron</strong>, which requires some fees to be paid to relayers for IBC transfers. For other CosmWasm chains, prefer using the <strong><a href="libraries/./generic-ibc-transfer.html">Generic IBC Transfer library</a></strong> instead.</p>
<h2 id="high-level-flow-4"><a class="header" href="#high-level-flow-4">High-level flow</a></h2>
<pre class="mermaid">---
title: Neutron IBC Transfer Library
---
graph LR
  IA((Input
      Account))
  OA((Output
		  Account))
  P[Processor]
  S[Neutron IBC Transfer
    Library]
  subgraph Neutron
  P -- 1/IbcTransfer --&gt; S
  S -- 2/Query balances --&gt; IA
  S -- 3/Do Send funds --&gt; IA
  end
  subgraph Chain 2
  IA -- 4/IBC Transfer --&gt; OA
  end
</pre>
<h2 id="functions-4"><a class="header" href="#functions-4">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>IbcTransfer</strong></td><td>-</td><td>Transfer funds over IBC from an <strong>input account</strong> on <strong>Neutron</strong> to an <strong>output account</strong> on a destination chain.</td></tr>
</tbody></table>
</div>
<h2 id="configuration-4"><a class="header" href="#configuration-4">Configuration</a></h2>
<p>The library is configured on instantiation via the <code>LibraryConfig</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct LibraryConfig {
  // Account from which the funds are pulled (on the source chain)
  input_addr: LibraryAccountType,
  // Account to which the funds are sent (on the destination chain)
  output_addr: String,
  // Denom of the token to transfer
  denom: UncheckedDenom,
  // Amount to be transferred, either a fixed amount or the whole available balance.
  amount: IbcTransferAmount,
  // Memo to be passed in the IBC transfer message.
  memo: String,
  // Information about the destination chain.
  remote_chain_info: RemoteChainInfo,
  // Denom map for the Packet-Forwarding Middleware, to perform a multi-hop transfer.
  denom_to_pfm_map: BTreeMap&lt;String, PacketForwardMiddlewareConfig&gt;,
}

// Defines the amount to be transferred, either a fixed amount or the whole available balance.
enum IbcTransferAmount {
  // Transfer the full available balance of the input account.
  FullAmount,
  // Transfer the specified amount of tokens.
  FixedAmount(Uint128),
}

pub struct RemoteChainInfo {
  // Channel of the IBC connection to be used.
  channel_id: String,
  // Port of  the IBC connection to be used.
  port_id: Option&lt;String&gt;,
  // Timeout for the IBC transfer.
  ibc_transfer_timeout: Option&lt;Uint64&gt;,
}

// Configuration for a multi-hop transfer using the Packet Forwarding Middleware
struct PacketForwardMiddlewareConfig {
  // Channel ID from the source chain to the intermediate chain
  local_to_hop_chain_channel_id: String,
  // Channel ID from the intermediate to the destination chain
  hop_to_destination_chain_channel_id: String,
  // Temporary receiver address on the intermediate chain
  hop_chain_receiver_address: String,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="osmosis-cl-lper-library"><a class="header" href="#osmosis-cl-lper-library">Osmosis CL LPer library</a></h1>
<p>The <strong>Valence Osmosis CL LPer library</strong> library allows to <strong>create concentrated liquidity
positions</strong> on <strong>Osmosis</strong> from an <strong>input account</strong>, and deposit the <strong>LP tokens</strong> into an <strong>output account</strong>.</p>
<h2 id="high-level-flow-5"><a class="header" href="#high-level-flow-5">High-level flow</a></h2>
<pre class="mermaid">---
title: Osmosis CL Liquidity Provider
---
graph LR
  IA((Input
      Account))
  OA((Output
		  Account))
  P[Processor]
  S[Osmosis CL
      Liquidity
      Provider]
  AP[Osmosis CL
     Pool]
  P -- 1/Provide Liquidity --&gt; S
  S -- 2/Query balances --&gt; IA
  S -- 3/Configure target
    range --&gt; S
  S -- 4/Do Provide Liquidity --&gt; IA
  IA -- 5/Provide Liquidity
				  [Tokens] --&gt; AP
  AP -- 5'/Transfer LP Tokens --&gt; OA

</pre>
<h2 id="concentrated-liquidity-position-creation"><a class="header" href="#concentrated-liquidity-position-creation">Concentrated Liquidity Position creation</a></h2>
<p>Because of the way CL positions are created, there are two ways to achieve it:</p>
<h3 id="default"><a class="header" href="#default">Default</a></h3>
<p>Default position creation centers around the idea of creating a position
with respect to the currently active tick of the pool.</p>
<p>This method expects a single parameter, <code>bucket_amount</code>, which describes
how many <em>buckets</em> of the pool should be taken into account to both sides
of the price curve.</p>
<p>Consider a situation where the current tick is 125, and the configured
tick spacing is 10.</p>
<p>If this method is called with <code>bucket_amount</code> set to 5, the following logic
will be performed:</p>
<ul>
<li>find the current bucket range, which is 120 to 130</li>
<li>extend the current bucket ranges by 5 buckets to both sides, meaning
that the range "to the left" will be extended by 5 * 10 = 50, and the
range "to the right" will be extended by 5 * 10 = 50, resulting in the covered
range from 120 - 50 = 70 to 130 + 50 = 180, giving the position tick range of (70, 180).</li>
</ul>
<h3 id="custom"><a class="header" href="#custom">Custom</a></h3>
<p>Custom position creation allows for more fine-grained control over the
way the position is created.</p>
<p>This approach expects users to specify the following parameters:</p>
<ul>
<li><code>tick_range</code>, which describes the price range to be covered</li>
<li><code>token_min_amount_0</code> and <code>token_min_amount_1</code> which are optional
parameters that describe the minimum amount of tokens that should be
provided to the pool.</li>
</ul>
<p>With this flexibility a wide variety of positions can be created, such as
those that are entirely single-sided.</p>
<h2 id="functions-5"><a class="header" href="#functions-5">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>ProvideLiquidityDefault</strong></td><td><code>bucket_amount: Uint64</code></td><td>Create a position on the pre-configured <strong>Osmosis Pool</strong> from the <strong>input account</strong>, following the <a href="libraries/osmosis-cl-lper.html#default">Default approach</a> described above, and deposit the <strong>LP tokens</strong> into the <strong>output account</strong>.</td></tr>
<tr><td><strong>ProvideLiquidityCustom</strong></td><td><code>tick_range: TickRange</code><br><code>token_min_amount_0: Option&lt;Uint128&gt;</code><br><code>token_min_amount_1: Option&lt;Uint128&gt;</code></td><td>Create a position on the pre-configured <strong>Osmosis Pool</strong> from the <strong>input account</strong>, following the <a href="libraries/osmosis-cl-lper.html#custom">Custom approach</a> described above, and deposit the <strong>LP tokens</strong> into the <strong>output account</strong>.</td></tr>
</tbody></table>
</div>
<h2 id="configuration-5"><a class="header" href="#configuration-5">Configuration</a></h2>
<p>The library is configured on instantiation via the <code>LibraryConfig</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LibraryConfig {
    // Account from which the funds are LPed
    pub input_addr: LibraryAccountType,
    // Account to which the LP position is forwarded
    pub output_addr: LibraryAccountType,
    // LP configuration
    pub lp_config: LiquidityProviderConfig,
}

pub struct LiquidityProviderConfig {
    // ID of the Osmosis CL pool
    pub pool_id: Uint64,
    // Pool asset 1 
    pub pool_asset_1: String,
    // Pool asset 2
    pub pool_asset_2: String,
    // Pool global price range
    pub global_tick_range: TickRange,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="osmosis-cl-liquidity-withdrawer-library"><a class="header" href="#osmosis-cl-liquidity-withdrawer-library">Osmosis CL liquidity withdrawer library</a></h1>
<p>The <strong>Valence Osmosis CL Withdrawer library</strong> library allows to <strong>withdraw a concentrated liquidity
position</strong> off an <strong>Osmosis</strong> pool from an <strong>input account</strong>, and transfer the resulting tokens to an <strong>output account</strong>.</p>
<h2 id="high-level-flow-6"><a class="header" href="#high-level-flow-6">High-level flow</a></h2>
<pre class="mermaid">---
title: Osmosis CL Liquidity Withdrawal
---
graph LR
  IA((Input
      Account))
  OA((Output
		  Account))
  P[Processor]
  S[Osmosis CL
      Liquidity
      Withdrawal]
  AP[Osmosis CL
     Pool]
  P -- 1/Withdraw Liquidity --&gt; S
  S -- 2/Query balances --&gt; IA
  S -- 3/Compute amounts --&gt; S
  S -- 4/Do Withdraw Liquidity --&gt; IA
  IA -- 5/Withdraw Liquidity
				  [LP Position] --&gt; AP
  AP -- 5'/Transfer assets --&gt; OA
</pre>
<h2 id="functions-6"><a class="header" href="#functions-6">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>WithdrawLiquidity</strong></td><td><code>position_id: Uint64</code><br><code>liquidity_amount: String</code></td><td>Withdraw liquidity from the configured <strong>Osmosis Pool</strong> from the <strong>input account</strong>, according to the given parameters, and transfer the withdrawned tokens to the configured <strong>output account</strong></td></tr>
</tbody></table>
</div>
<h2 id="configuration-6"><a class="header" href="#configuration-6">Configuration</a></h2>
<p>The library is configured on instantiation via the <code>LibraryConfig</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LibraryConfig {
    // Account holding the LP position
    pub input_addr: LibraryAccountType,
    // Account to which the withdrawn assets are forwarded
    pub output_addr: LibraryAccountType,
    // ID of the pool
    pub pool_id: Uint64,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="osmosis-gamm-lper-library"><a class="header" href="#osmosis-gamm-lper-library">Osmosis GAMM LPer library</a></h1>
<p>The <strong>Valence Osmosis GAMM LPer library</strong> library allows to <strong>join a pool</strong> on <strong>Osmosis</strong>, using the <strong>GAMM module</strong> (Generalized Automated Market Maker), from an <strong>input account</strong>, and deposit the <strong>LP tokens</strong> into an <strong>output account</strong>.</p>
<h2 id="high-level-flow-7"><a class="header" href="#high-level-flow-7">High-level flow</a></h2>
<pre class="mermaid">---
title: Osmosis GAMM Liquidity Provider
---
graph LR
  IA((Input
      Account))
  OA((Output
          Account))
  P[Processor]
  S[Osmosis GAMM
      Liquidity
      Provider]
  AP[Osmosis
     Pool]
  P -- 1/Join Pool --&gt; S
  S -- 2/Query balances --&gt; IA
  S -- 3/Compute amounts --&gt; S
  S -- 4/Do Join Pool --&gt; IA
  IA -- 5/Join Pool
                  [Tokens] --&gt; AP
  AP -- 5'/Transfer LP tokens --&gt; OA

</pre>
<h2 id="functions-7"><a class="header" href="#functions-7">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>ProvideDoubleSidedLiquidity</strong></td><td><code>expected_spot_price: Option&lt;DecimalRange&gt;</code></td><td>Provide double-sided liquidity to the pre-configured <strong>Osmosis Pool</strong> from the <strong>input account</strong>, and deposit the <strong>LP tokens</strong> into the <strong>output account</strong>. Abort it the spot price is not within the <code>expected_spot_price</code> range (if specified).</td></tr>
<tr><td><strong>ProvideSingleSidedLiquidity</strong></td><td><code>asset: String</code><br><code>limit: Option&lt;Uint128&gt;</code><br><code>expected_spot_price: Option&lt;DecimalRange&gt;</code></td><td>Provide single-sided liquidity for the specified <code>asset</code> to the pre-configured <strong>Osmosis Pool</strong> from the <strong>input account</strong>, and deposit the <strong>LP tokens</strong> into the <strong>output account</strong>. Abort it the spot price is not within the <code>expected_spot_price</code> range (if specified).</td></tr>
</tbody></table>
</div>
<h2 id="configuration-7"><a class="header" href="#configuration-7">Configuration</a></h2>
<p>The library is configured on instantiation via the <code>LibraryConfig</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LibraryConfig {
    // Account from which the funds are LPed
    pub input_addr: LibraryAccountType,
    // Account to which the LP position is forwarded
    pub output_addr: LibraryAccountType,
    // LP configuration
    pub lp_config: LiquidityProviderConfig,
}

pub struct LiquidityProviderConfig {
    // ID of the Osmosis pool
    pub pool_id: Uint64,
    // Pool asset 1 
    pub pool_asset_1: String,
    // Pool asset 2
    pub pool_asset_2: String,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="osmosis-gamm-liquidity-withdrawer-library"><a class="header" href="#osmosis-gamm-liquidity-withdrawer-library">Osmosis GAMM liquidity withdrawer library</a></h1>
<p>The <strong>Valence Osmosis GAMM Withdrawer library</strong> library allows to <strong>exit a pool</strong> on <strong>Osmosis</strong>, using the <strong>GAMM module</strong> (Generalized Automated Market Maker), from an <strong>input account</strong>, an deposit the withdrawed tokens into an <strong>output account</strong>.</p>
<h2 id="high-level-flow-8"><a class="header" href="#high-level-flow-8">High-level flow</a></h2>
<pre class="mermaid">---
title: Osmosis GAMM Liquidity Withdrawal
---
graph LR
  IA((Input
      Account))
  OA((Output
		  Account))
  P[Processor]
  S[Osmosis GAMM
      Liquidity
      Withdrawal]
  AP[Osmosis
     Pool]
  P -- 1/Withdraw Liquidity --&gt; S
  S -- 2/Query balances --&gt; IA
  S -- 3/Compute amounts --&gt; S
  S -- 4/Do Withdraw Liquidity --&gt; IA
  IA -- 5/Withdraw Liquidity
				  [LP Tokens] --&gt; AP
  AP -- 5'/Transfer assets --&gt; OA
</pre>
<h2 id="functions-8"><a class="header" href="#functions-8">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>WithdrawLiquidity</strong></td><td>-</td><td>Withdraw liquidity from the configured <strong>Osmosis Pool</strong> from the <strong>input account</strong> and deposit the withdrawed tokens into the configured <strong>output account</strong></td></tr>
</tbody></table>
</div>
<h2 id="configuration-8"><a class="header" href="#configuration-8">Configuration</a></h2>
<p>The library is configured on instantiation via the <code>LibraryConfig</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LibraryConfig {
    // Account from which the funds are LPed
    pub input_addr: LibraryAccountType,
    // Account to which the LP tokens are forwarded
    pub output_addr: LibraryAccountType,
    // Liquidity withdrawer configuration
    pub withdrawer_config: LiquidityWithdrawerConfig,
}

pub struct LiquidityWithdrawerConfig {
    // ID of the pool
    pub pool_id: Uint64,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="valence-reverse-splitter-library"><a class="header" href="#valence-reverse-splitter-library">Valence Reverse Splitter library</a></h1>
<p>The <strong>Reverse Splitter</strong> library allows to <strong>route funds</strong> from <strong>one or more input account(s)</strong> to a <strong>single output account</strong>, for <strong>one or more token denom(s)</strong> according to the configured <strong>ratio(s)</strong>. It is typically used as part of a <strong>Valence Program</strong>. In that context, a <strong>Processor</strong> contract will be the main contract interacting with the Forwarder library.</p>
<h2 id="high-level-flow-9"><a class="header" href="#high-level-flow-9">High-level flow</a></h2>
<pre class="mermaid">---
title: Reverse Splitter Library
---
graph LR
  IA1((Input
      Account1))
  IA2((Input
       Account2))
  OA((Output
		  Account))
  P[Processor]
  S[Reverse Splitter
    Library]
  C[Contract]
  P -- 1/Split --&gt; S
  S -- 2/Query balances --&gt; IA1
  S -- 2'/Query balances --&gt; IA2
  S -. 3/Query split ratio .-&gt; C
  S -- 4/Do Send funds --&gt; IA1
  S -- 4'/Do Send funds --&gt; IA2
  IA1 -- 5/Send funds --&gt; OA
  IA2 -- 5'/Send funds --&gt; OA
</pre>
<h2 id="functions-9"><a class="header" href="#functions-9">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>Split</strong></td><td>-</td><td>Split and route funds from the configured <strong>input account(s)</strong> to the <strong>output account</strong>, according to the configured <strong>token denom(s)</strong> and <strong>ratio(s)</strong>.</td></tr>
</tbody></table>
</div>
<h2 id="configuration-9"><a class="header" href="#configuration-9">Configuration</a></h2>
<p>The library is configured on instantiation via the <code>LibraryConfig</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct LibraryConfig {
    output_addr: LibraryAccountType,   // Account to which the funds are sent.
    splits: Vec&lt;UncheckedSplitConfig&gt;, // Split configuration per denom.
    base_denom: UncheckedDenom         // Base denom, used with ratios.
}

// Split config for specified account
struct UncheckedSplitConfig {
  denom: UncheckedDenom,                // Denom for this split configuration (either native or CW20).
  account: LibraryAccountType,          // Address of the input account for this split config.
  amount: UncheckedSplitAmount,         // Fixed amount of tokens or an amount defined based on a ratio.
  factor: Option&lt;u64&gt;                   // Multiplier relative to other denoms (only used if a ratio is specified).
}

// Ratio configuration, either fixed &amp; dynamically calculated
enum UncheckedRatioConfig {
  FixedAmount(Uint128), // Fixed amount of tokens
  FixedRatio(Decimal),  // Fixed ratio e.g. 0.0262 for NTRN/STARS (or could be another arbitrary ratio)
  DynamicRatio {        // Dynamic ratio calculation (delegated to external contract)
	contract_addr: "&lt;TWAP Oracle wrapper contract address&gt;",
    params: "base64-encoded arbitrary payload to send in addition to the denoms"
  }
}

// Standard query &amp; response for contract computing a dynamic ratio
// for the Splitter &amp; Reverse Splitter libraries.
#[cw_serde]
#[derive(QueryResponses)]
pub enum DynamicRatioQueryMsg {
    #[returns(DynamicRatioResponse)]
    DynamicRatio {
        denoms: Vec&lt;String&gt;,
        params: String,
    }
}

#[cw_serde]
// Response returned by the external contract for a dynamic ratio
struct DynamicRatioResponse {
    pub denom_ratios: HashMap&lt;String, Decimal&gt;,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="valence-splitter-library"><a class="header" href="#valence-splitter-library">Valence Splitter library</a></h1>
<p>The <strong>Valence Splitter</strong> library allows to <strong>split funds</strong> from <strong>one input account</strong> to <strong>one or more output account(s)</strong>, for <strong>one or more token denom(s)</strong> according to the configured <strong>ratio(s)</strong>. It is typically used as part of a <strong>Valence Program</strong>. In that context, a <strong>Processor</strong> contract will be the main contract interacting with the Forwarder library.</p>
<h2 id="high-level-flow-10"><a class="header" href="#high-level-flow-10">High-level flow</a></h2>
<pre class="mermaid">---
title: Splitter Library
---
graph LR
  IA((Input
      Account))
  OA1((Output
		  Account 1))
	OA2((Output
		  Account 2))
  P[Processor]
  S[Splitter
    Library]
  C[Contract]
  P -- 1/Split --&gt; S
  S -- 2/Query balances --&gt; IA
  S -. 3/Query split ratio .-&gt; C
  S -- 4/Do Send funds --&gt; IA
  IA -- 5/Send funds --&gt; OA1
  IA -- 5'/Send funds --&gt; OA2
</pre>
<h2 id="functions-10"><a class="header" href="#functions-10">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>Split</strong></td><td>-</td><td>Split funds from the configured <strong>input account</strong> to the <strong>output account(s)</strong>, according to the configured <strong>token denom(s)</strong> and <strong>ratio(s)</strong>.</td></tr>
</tbody></table>
</div>
<h2 id="configuration-10"><a class="header" href="#configuration-10">Configuration</a></h2>
<p>The library is configured on instantiation via the <code>LibraryConfig</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct LibraryConfig {
    input_addr: LibraryAccountType,    // Address of the input account
    splits: Vec&lt;UncheckedSplitConfig&gt;, // Split configuration per denom
}

// Split config for specified account
struct UncheckedSplitConfig {
  denom: UncheckedDenom,          // Denom for this split configuration (either native or CW20)
  account: LibraryAccountType,    // Address of the output account for this split config
  amount: UncheckedSplitAmount,   // Fixed amount of tokens or an amount defined based on a ratio
}

// Split amount configuration, either a fixed amount of tokens or an amount defined based on a ratio
enum UncheckedSplitAmount {
  FixedAmount(Uint128),       // Fixed amount of tokens
  FixedRatio(Decimal),        // Fixed ratio e.g. 0.0262 for NTRN/STARS (or could be another arbitrary ratio)
  DynamicRatio {              // Dynamic ratio calculation (delegated to external contract)
    contract_addr: "&lt;TWAP Oracle wrapper contract address&gt;",
    params: "base64-encoded arbitrary payload to send in addition to the denoms"
  }
}

// Standard query &amp; response for contract computing a dynamic ratio
// for the Splitter &amp; Reverse Splitter libraries.
#[cw_serde]
#[derive(QueryResponses)]
pub enum DynamicRatioQueryMsg {
    #[returns(DynamicRatioResponse)]
    DynamicRatio {
        denoms: Vec&lt;String&gt;,
        params: String,
    }
}

#[cw_serde]
// Response returned by the external contract for a dynamic ratio
struct DynamicRatioResponse {
    pub denom_ratios: HashMap&lt;String, Decimal&gt;,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<p>Here are some examples of Valence Programs that you can use to get started.</p>
<ul>
<li><a href="examples/./token_swap.html">Token Swap</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="token-swap-program"><a class="header" href="#token-swap-program">Token Swap Program</a></h1>
<p>This example demonstrates a simple <em>token swap</em> program whereby two parties wish to exchange specific amounts of (different) tokens they each hold, at a rate they have previously agreed on. The program ensures the swap happens atomically, so neither party can withdraw without completing the trade.</p>
<pre class="mermaid">---
title: Valence token swap program
---
graph LR
	InA((Party A Deposit))
	InB((Party B Deposit))
	OutA((Party A Withdraw))
	OutB((Party B Withdraw))
	SSA[Splitter A]
	SSB[Splitter B]
	subgraph Neutron
	InA --&gt; SSA --&gt; OutB
	InB --&gt; SSB --&gt; OutA
	end
</pre>
<p>The program is composed of the following components:</p>
<ul>
<li><strong>Party A Deposit account</strong>: a <a href="examples/../components/accounts.html">Valence account</a> which Party A will deposit their tokens into, to be exchanged with Party B's tokens.</li>
<li><strong>Splitter A</strong>: an instance of the <a href="examples/../libraries/splitter.html">Splitter library</a> that will transfer Party A's tokens from its input account (i.e. the <strong>Party A Deposit account</strong>) to its output account (i.e. the <strong>Party B Withdraw account</strong>) upon execution of its <code>split</code> function.</li>
<li><strong>Party B Withdraw account</strong>: the account from which Party B can withdraw Party A's tokens after the swap has successfully completed. Note: this can be a <a href="examples/../components/accounts.html">Valence account</a>, but it could also be a regular chain account, or a smart contract.</li>
<li><strong>Party B Deposit account</strong>:  a <a href="examples/../components/accounts.html">Valence account</a> which Party B will deposit their funds into, to be exchanged with Party A's funds.</li>
<li><strong>Splitter B</strong>: an instance of the <a href="examples/../libraries/splitter.html">Splitter library</a> that will transfer Party B's tokens from its input account (i.e. the <strong>Party B Deposit account</strong>) to its output account (i.e. the <strong>Party A Withdraw account</strong>) upon execution of its <code>split</code> function.</li>
<li><strong>Party A Withdraw account</strong>: the account from which Party A can withdraw Party B's tokens after the swap has successfully completed. Note: this can be a <a href="examples/../components/accounts.html">Valence account</a>, but it could also be a regular chain account, or a smart contract.</li>
</ul>
<p>The way the program is able to fulfil the requirement for an <em>atomic exchange of tokens</em> between the two parties is done by implementing an <strong>atomic subroutine</strong> composed of two function calls:</p>
<ol>
<li><strong>Splitter A</strong>'s <code>split</code> function</li>
<li><strong>Splitter B</strong>'s <code>split</code> function</li>
</ol>
<p>The Authorizations component will ensure that either both succeed, or none is executed, thereby ensuring that <strong>funds remain safe at all time</strong> (either remaining in the respective deposit accounts, or transferred to the respective withdraw accounts).</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
