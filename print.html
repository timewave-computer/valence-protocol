<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Valence Protocol Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Valence Protocol Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/timewave-computer/valence-protocol" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<blockquote>
<p>🚧 Valence Protocol architecture and developer documentation is still evolving rapidly. Portions of the toolchain have stabilized to build cross-chain vaults, and extending vaults with multi-party agreements. Send us a message on <a href="https://x.com/valencezone">X</a> if you'd like to get started!</p>
</blockquote>
<p><strong>Valence</strong> is a unified development environment that enables building <em>trust-minimized cross-chain DeFi applications</em>, called <strong>Valence Programs</strong>.</p>
<p>Valence Programs are:</p>
<ul>
<li><strong>Easy to understand</strong> and <strong>quick to deploy</strong>: a program can be set up with a configuration file and no code.</li>
<li><strong>Extensible</strong>: if we don't yet support a DeFi integration out of the box, new integrations can be written in a matter of hours!</li>
</ul>
<blockquote>
<p><strong>Example Use Case</strong>:</p>
<p>A DeFi protocol wants to bridge tokens to another chain and deposit them into a vault. After a certain date, it wants to unwind the position. While the position is active, it may also want to delegate the right to change vault parameters to a designated committee so long as the parameters are within a certain range.
Without Valence Programs, the protocol would have two choices:</p>
<ol>
<li>Give the tokens to a <strong>multisig</strong> to execute actions on the protocol's behalf</li>
<li>Write <strong>custom smart contracts</strong> and deploy them across multiple chains to handle the cross-chain token operations.</li>
</ol>
<p><strong>Valence Programs</strong> offer the DeFi protocol a third choice: rapidly configure and deploy a secure solution that meets its needs without trusting a multisig or writing complex smart contracts.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="valence-programs"><a class="header" href="#valence-programs">Valence Programs</a></h1>
<p>There are two ways to execute Valence Programs.</p>
<ol>
<li>
<p><strong>On-chain Execution</strong>:
Valence currently supports CosmWasm and EVM. SVM support coming soon. The rest of this section provides a high-level breakdown of the components that comprise a Valence Program using on-chain coprocessors.</p>
<ul>
<li><a href="components/./domains.html">Domains</a></li>
<li><a href="components/./accounts.html">Accounts</a></li>
<li><a href="components/./libraries_and_functions.html">Libraries and Functions</a></li>
<li><a href="components/./programs_and_authorizations.html">Programs and Authorizations</a></li>
<li><a href="components/./middleware.html">Middleware</a></li>
</ul>
</li>
<li>
<p><strong>Off-chain Execution via ZK Coprocessor</strong>:
Early specifications exist for the [Valence ZK coprocessor] (/zk-coprocessor/_overview.md). We aim to move as much computation off-chain as possible since off-chain computation is a more scalable approach to building a cross-chain execution environment.</p>
</li>
</ol>
<p>Unless explicitly mentioned, you may assume that documentation and examples in the remaining sections are written with on-chain execution in mind.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="domains"><a class="header" href="#domains">Domains</a></h1>
<p>A <strong>domain</strong> is an environment in which the components that form a program (more on these later) can be instantiated (deployed).</p>
<p><strong>Domains</strong> are defined by <strong>three properties</strong>:</p>
<ol>
<li>The <strong>chain</strong>: the blockchain's name <em>e.g. Neutron, Osmosis, Ethereum mainnet</em>.</li>
<li>The <strong>execution environment</strong>: the environment under which programs (typically smart contracts) can be executed on that particular chain <em>e.g. CosmWasm, EVM, SVM</em>.</li>
<li>The type of <strong>bridge</strong> used from the <strong>main domain</strong> to other domains <em>e.g. Polytone over IBC, Hyperlane</em>.</li>
</ol>
<p>Within a particular ecosystem of blockchains (e.g. Cosmos), the Valence Protocol usually defines one specific domain as the <strong>main domain</strong>, on which some supporting infrastructure components are deployed. Think of it as the <em>home base</em> supporting the execution and operations of Valence Programs. This will be further clarified in the <a href="components/./authorizations_processors/_overview.html">Authorizations &amp; Processors</a> section.</p>
<p>Below is a simplified representation of a <em>program transferring tokens</em> from a given <strong>input account</strong> on the <strong>Neutron domain</strong>, a CosmWasm-enabled smart contract platform secured by the Cosmos Hub, to a specified <strong>output account</strong> on the <strong>Osmosis domain</strong>, a well-known DeFi platform in the Cosmos ecosystem.</p>
<pre class="mermaid">---
title: Valence Cross-Domain Program
---
graph LR
  IA((Input
      Account))
  OA((Output
		  Account))
  subgraph Neutron
  IA
  end
  subgraph Osmosis
  IA -- Transfer tokens --&gt; OA
  end
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="accounts"><a class="header" href="#accounts">Accounts</a></h1>
<p><strong>Valence Programs</strong> usually perform operations on tokens accross multiple domains. To ensure that the funds remain safe throughout a program's execution, Valence Programs rely on a primitive called <strong>Valence Accounts</strong>.</p>
<p>A <strong>Valence Account</strong> is an escrow contract that can hold balances for various supported token types (e.g., in Cosmos <code>ics-20</code> or <code>cw-20</code>) and ensure that only a restricted set of operations can be performed on the held tokens.
<strong>Valence Accounts</strong> are created (i.e., instantiated) on a specific <strong>domain</strong> and bound to a specific <strong>Valence Program</strong>. <strong>Valence Programs</strong> will typically use multiple accounts during the program's lifecycle for different purposes. <strong>Valence Accounts</strong> are generic by nature; their use in forming a program is entirely up to the program's creator.</p>
<p>Using a simple <em>token swap program</em> as an example: the program receives an amount of <strong>Token A</strong> in an <strong>input account</strong> and will <strong>swap</strong> these <strong>Token A</strong> for <strong>Token B</strong> using a <strong>DEX</strong> on the <strong>same domain</strong> (e.g., Neutron). After the swap operation, the received amount of <strong>Token B</strong> will be temporarily held in a <strong>transfer account</strong> before being transfered to a final <strong>output account</strong> on another domain (e.g., Osmosis).</p>
<p>For this, the program will create the following accounts:</p>
<ul>
<li>A <strong>Valence Account</strong> is created on the <strong>Neutron domain</strong> to act as the <strong>Input account</strong>.</li>
<li>A <strong>Valence Account</strong> is created on the <strong>Neutron domain</strong> to act as the <strong>Transfer account</strong>.</li>
<li>A <strong>Valence Account</strong> is created on the <strong>Osmosis domain</strong> to act as the <strong>Output account</strong>.</li>
</ul>
<pre class="mermaid">---
title: Valence Token Swap Program
---
graph LR
  IA((Input
    Account))
  TA((Transfer
    Account))
  OA((Output
	Account))
  DEX
  subgraph Neutron
  IA -- Swap Token A --&gt; DEX
  DEX -- Token B --&gt; TA
  end
  subgraph Osmosis
  TA -- Transfer token B --&gt; OA
  end
</pre>
<p>Note: this is a simplified representation.</p>
<p><strong>Valence Accounts</strong> do not perform any operation by themselves on the held funds. The operations are performed by <strong><a href="components/./libraries_and_functions.html">Valence Libraries</a></strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libraries-and-functions"><a class="header" href="#libraries-and-functions">Libraries and Functions</a></h1>
<p><strong>Valence Libraries</strong> contain the business logic that can be applied to the funds held by <strong>Valence Accounts</strong>. Most often, this logic is about <em>performing operations on tokens</em>, such as splitting, routing, or providing liquidity on a DEX. A <strong>Valence Account</strong> has to first approve (authorize) a <strong>Valence Library</strong> for it to perform operations on that account's balances. <strong>Valence Libraries</strong> expose <strong>Functions</strong> that it supports. <strong>Valence Programs</strong> can be composed of a more or less complex graph of <strong>Valence Accounts</strong> and <strong>Valence Libraries</strong> to form a more or less sophisticated cross-chain workflow. During the course of a <strong>Valence Program</strong>'s execution, <strong>Functions</strong> are called by external parties that trigger the library's operations on the linked accounts.</p>
<p>A typical pattern for a <strong>Valence Library</strong> is to have one (or more) <strong>input account(s)</strong> and one (or more) <strong>output account(s)</strong>. While many libraries implement this pattern, it is by no means a requirement.</p>
<p><strong>Valence Libraries</strong> play a critical role in integrating <strong>Valence Programs</strong> with existing decentralized apps and services that can be found in many blockchain ecosystems (e.g., DEXes, liquid staking, etc.).</p>
<p>Now that we know accounts cannot perform any operations by themselves, we need to revisit the <em>token swap program</em> example (mentioned on the <a href="components/./accounts.html">Accounts</a> page) and bring <strong>Valence Libraries</strong> into the picture: the program receives an amount of <strong>Token A</strong> in an <strong>input account</strong>, and a <strong>Token Swap</strong> library exposes a <strong>swap</strong> function that, when called, will perform a swap operation of <strong>Token A</strong> held by the <strong>input account</strong> for <strong>Token B</strong> using a <strong>DEX</strong> on the <strong>same domain</strong> (e.g., Neutron), and transfer them to the <strong>transfer account</strong>. A <strong>Token Transfer</strong> library that exposes a <strong>transfer</strong> function will transfer the <strong>Token B</strong> amount (when the function is called) to a final <strong>output account</strong> on another domain (e.g. Osmosis). In this scenario, the <strong>DEX</strong> is an existing service found on the host domain (e.g. <strong>Astroport</strong> on <strong>Neutron</strong>), so it is not part of the <strong>Valence Protocol</strong>.</p>
<p>The program is then composed of the following accounts &amp; libraries:</p>
<ul>
<li>A <strong>Valence Account</strong> is created on the <strong>Neutron domain</strong> to act as the <strong>input account</strong>.</li>
<li>A <strong>Valence Account</strong> is created on the <strong>Neutron domain</strong> to act as the <strong>transfer account</strong>.</li>
<li>A <strong>Token Swap Valence Library</strong> is created on the <strong>Neutron domain</strong>, <em>authorized</em> by the <strong>input account</strong> (to be able to act on the held Token A balance), and <em>configured</em> with the <strong>input account</strong> and <strong>transfer account</strong> as the respective input and output for the swap operation.</li>
<li>A <strong>Token Transfer Valence Library</strong> is created on the <strong>Neutron domain</strong>, <em>authorized</em> by the <strong>transfer account</strong> (to be able to act on the held Token B balance), and <em>configured</em> with the <strong>transfer account</strong> and <strong>output account</strong> as the respective input and output for the swap operation.</li>
<li>A <strong>Valence Account</strong> is created on the <strong>Osmosis domain</strong> to act as the <strong>output account</strong>.</li>
</ul>
<pre class="mermaid">---
title: Valence Token Swap Program
---
graph LR
  FC[[Function call]]
  IA((Input
	Account))
  TA((Transfer
	Account))
  OA((Output
	Account))
  TS((Token
  	Swap Library))
  TT((Token
  	Transfer Library))
  DEX
  subgraph Neutron
  FC -- 1/Swap --&gt; TS
  TS -- Swap Token A --&gt; IA
  IA -- Token A --&gt; DEX
  DEX -- Token B --&gt; TA
  FC -- 2/Transfer --&gt; TT
  TT -- Transfer Token B --&gt; TA
  end
  subgraph Osmosis
  TA -- Token B --&gt; OA
  end
</pre>
<p>This example highlights the crucial role that <strong>Valence Libraries</strong> play for integrating <strong>Valence Programs</strong> with pre-existing decentralized apps and services.</p>
<p>However, one thing remains unclear in this example: how are <strong>Functions</strong> called? This is where <a href="components/./programs_and_authorizations.html">Programs and Authorizations</a> come into the picture.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="programs-and-authorizations"><a class="header" href="#programs-and-authorizations">Programs and Authorizations</a></h1>
<p>A <strong>Valence Program</strong> is an instance of the <strong>Valence Protocol</strong>. It is a particular arrangement and configuration of <a href="components/./accounts.html">accounts</a> and <a href="components/./libraries_and_functions.html">libraries</a> across multiple <a href="components/./domains.html">domains</a> (e.g., a POL (protocol-owned liquidity) lending relationship between two parties). Similarly to how a <em>library</em> exposes executable <em>functions</em>, programs are associated with a set of executable <strong>Subroutines</strong>.</p>
<p>A <strong>Subroutine</strong> is a vector of <strong>Functions</strong>. A <strong>Subroutine</strong> can call out to one or more <strong>Function(s)</strong> from a single library, or from different libraries. A <strong>Subroutine</strong> is limited to <strong>one execution domain</strong> (i.e., <strong>Subroutines</strong> cannot use functions from libraries instantiated on multiple domains).</p>
<p>A <strong>Subroutine</strong> can be:</p>
<ul>
<li><strong>Non Atomic</strong> (e.g., Execute function one. If that succeeds, execute function two. If that succeeds, execute function three. And so on.)</li>
<li>or <strong>Atomic</strong> (e.g., execute function one, function two, and function three. If any of them fail, then revert all steps.)</li>
</ul>
<p><strong>Valence Programs</strong> are typically used to implement complex cross-chain workflows that perform financial operations in a trust-minimized way. Because multiple parties may be involved in a <strong>Valence Program</strong>, the parties to a <strong>Valence Program</strong> may wish for limitations on what various parties are authorized to do.</p>
<p>To specify fine-grained controls over who can initiate the execution of a <strong>Subroutine</strong>, program creators use the <strong>Authorizations</strong> module.</p>
<p>The <strong>Authorizations</strong> module is a powerful and flexible system that supports access control configuration schemes, such as:</p>
<ul>
<li><strong>Anyone</strong> can initiate execution of a <strong>Subroutine</strong></li>
<li>Only <strong>permissioned actors</strong> can initiate execution of a <strong>Subroutine</strong></li>
<li>Execution can only be initiated <strong>after a starting timestamp/block height</strong></li>
<li>Execution can only be initiated <strong>up to a certain timestamp/block height</strong></li>
<li>Authorizations are <strong>tokenized</strong>, which means they can be transferred by the holder or used in more sophisticated DeFi scenarios</li>
<li>Authorizations can <strong>expire</strong></li>
<li>Authorizations can be <strong>enabled/disabled</strong></li>
<li>Authorizations can tightly <strong>constrain parameters</strong> (e.g., an authorization to execute a token transfer message can limit the execution to only supply the amount argument, not the denom or receiver in the transfer message)</li>
</ul>
<p>To support the on-chain execution of <strong>Valence Programs</strong>, the <strong>Valence Protocol</strong> provides two important contracts: the <strong>Authorizations Contract</strong> and the <strong>Processor Contract</strong>.</p>
<p>The <strong>Authorizations Contract</strong> is the entry point for users. The user sends a set of messages to the Authorizations Contract and the label (id) of the authorization they want to execute. The Authorizations Contract then verifies that the sender is authorized and that the messages are valid, constructs a <em>MessageBatch</em> based on the subroutine, and passes this batch to the <strong>Processor Contract</strong> for execution. The authority to execute any <strong>Subroutine</strong> is tokenized so that these tokens can be transferred on-chain.</p>
<p>The <strong>Processor Contract</strong> receives a <em>MessageBatch</em> and executes the contained <em>Messages</em> in sequence. It does this by maintaining execution queues where the queue items are <strong>Subroutines.</strong> The processor exposes a <code>Tick</code> message that allows anyone to trigger the processor, whereby the first batch of the queue is executed or moved to the back of the queue if it's not executable yet (e.g., retry period has not passed).</p>
<pre class="mermaid">graph LR;
	User --&gt; |Subroutine| Auth(Authorizations)
	Auth --&gt; |Message Batch| P(Processor)
	P --&gt; |Function 1| S1[Library 1]
	P --&gt; |Function 2| S2[Library 2]
	P --&gt; |Function N| S3[Library N]
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wip-middleware"><a class="header" href="#wip-middleware">WIP: Middleware</a></h1>
<p>The Valence Middleware is a set of components that provide a unified interface for the Valence Type system.</p>
<p>At its core, middleware is made up from the following components.</p>
<h2 id="design-goals"><a class="header" href="#design-goals">Design goals</a></h2>
<p>TODO: describe modifiable middleware, design goals and philosophy behind it</p>
<p>These means are achieved with three key components:</p>
<ul>
<li>brokers</li>
<li>type registries</li>
<li>Valence types</li>
</ul>
<h2 id="middleware-brokers"><a class="header" href="#middleware-brokers">Middleware Brokers</a></h2>
<p>Middleware brokers are responsible for managing the lifecycle of middleware instances and their associated types.</p>
<h2 id="middleware-type-registries"><a class="header" href="#middleware-type-registries">Middleware Type Registries</a></h2>
<p>Middleware Type Registries are responsible for unifying a set of foreign types to be used in Valence Programs.</p>
<h2 id="valence-types"><a class="header" href="#valence-types">Valence Types</a></h2>
<p>Valence Types are the canonical representations of various external domain implementations of some types.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="valence-zk-coprocessor"><a class="header" href="#valence-zk-coprocessor">Valence ZK coprocessor</a></h1>
<blockquote>
<p>⚠️ <strong>Note:</strong> Valence's ZK coprocessor is currently in specification stage and evolving rapidly. This document is shared to give partners a preview of our roadmap in the spirit of building in public.</p>
</blockquote>
<p>The Valence ZK coprocessor is a universal DeFi execution engine. It allows developers to compose programs once and deploy them across multiple blockchains. Additionally, the coprocessor facilitates execution of arbitrary cross-chain messages with a focus on synchronizing state between domains. Using Valence, developers can:</p>
<ol>
<li>Build once, deploy everywhere. Write programs in Rust and settle on one or more EVM, Wasm, Move, or SVM chains.</li>
<li>Avoid introducing additional trust assumptions. Only trust the consensus of the underlying chains you are building on.</li>
</ol>
<p>While the actual execution is straightforward, <em>the challenge lies in encoding state</em>. The ZK program, as a pure function, must be able to to utilize existing state as arguments to produce an evaluated output state.</p>
<p>Initially, we can develop an efficient version of this coprocessor approximately at par with creating the state encoder. However, it is crucial to note that each chain will necessitate a separate encoder implementation. The initial version will necessitate users to deploy their custom verification keys along with the state mutation function within the target blockchain. Although the code required for this purpose will be minimal, users will still need to implement their own verification keys and state mutation functions.</p>
<p>Longer term, we plan to develop a decoder that will automate the state mutation process based on the output of the ZK commitment. For this initial version, users will be able to perform raw mutations directly, as the correctness of ZK proofs will ensure the validity of messages according to the implemented ZK circuit.</p>
<pre class="mermaid">---
title: ZK coprocessor overview
---
graph TB;
    %% Programs
    subgraph ZK coprocessor
        P1[zk program 1]
        P2[zk program 2]
        P3[zk program 3]
    end

    %% Chains
    C1[chain 1]
    C2[chain 2]
    C3[chain 3]

    P1 &lt;--&gt; C1
    P2 &lt;--&gt; C2
    P3 &lt;--&gt; C3
</pre>
<h2 id="zkvm-primer"><a class="header" href="#zkvm-primer">zkVM Primer</a></h2>
<p>A zero-knowledge virtual machine (zkVM) is a zero-knowledge proof system that allows developers to prove the execution of arbitrary programs. In our case these programs are written in Rust. Given a Rust program that can be described as a pure function<code>f(x) = y</code>, one can prove the evaluation in the following way:</p>
<ol>
<li>Define <code>f</code> using normal Rust code and compile the function as an executable binary</li>
<li>With this executable binary, set up a proving key <code>pk</code> and verifying key <code>vk</code></li>
<li>Generate a proof <code>p</code> that <code>f</code> was evaluated correctly given input <code>x</code> using the zkVM, by calling <code>prove(pk, x)</code></li>
<li>Now you can verify this proof <code>p</code> by calling <code>verify(vk, x, y, p)</code></li>
</ol>
<h2 id="building-the-valence-zk-coprocessor"><a class="header" href="#building-the-valence-zk-coprocessor">Building the Valence ZK coprocessor</a></h2>
<p>Let's assume that we have Valence Accounts in each domain. These accounts implement a kv store.</p>
<p>Every ZK computation will follow the format of a pure state transition function; specifically, we input a state <code>A</code>, apply the function <code>f</code> to it, and produce the resulting state <code>B</code> : <code>f(A) = B</code> .
For the function <code>f</code>, the chosen zkVM will generate a verifying key <code>K</code>, which remains consistent across all state transition functions.</p>
<h3 id="encoding-the-account-state-unary-encoder"><a class="header" href="#encoding-the-account-state-unary-encoder">Encoding the account state: Unary Encoder</a></h3>
<p>To ensure every state transition computed as a ZK proof by the coprocessor is a pure state transition function, we require a method to encode the entire account's state into initial and mutated forms, <code>A</code> and <code>B</code>, respectively, for use in providing the applicable state modifications for the target chain.</p>
<p>In essence, let's consider an account with its state containing a map that assigns a balance (u64 value) to each key. A contract execution transferring 100 tokens from key <code>m</code> to <code>n</code> can be achieved by invoking <code>state.transfer(signature, m, n, 100)</code>. This on-chain transfer function may look something like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn transfer(&amp;mut self, signature: Signature, from: Address, to: Address, value: u64) {
    assert!(signature.verify(&amp;from));
    assert!(value &gt; 0);

    let balance_from = self.get(&amp;from).unwrap();
    let balance_to = self.get(&amp;from).unwrap_or(0);

    let balance_from = balance_from.checked_sub(value).unwrap();
    let balance_to = balance_to.checked_add(value).unwrap();

    self.insert(from, balance_from);
    self.insert(to, balance_to);
}
<span class="boring">}</span></code></pre></pre>
<p>Here, the pre-transfer state is <code>A</code> and after the transfer, the state is <code>B</code>.</p>
<p>Let's write a new function called <code>transfer_trusted</code> that leaves signature verification to the ZK coprocessor.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn transfer_trusted(&amp;mut self, from: Address, to: Address, value: u64) {
    let balance_from = self.get(&amp;from).unwrap();
    let balance_to = self.get(&amp;to).unwrap_or(0);

    self.insert(from, balance_from - value);
    self.insert(to, balance_to + value);
}
<span class="boring">}</span></code></pre></pre>
<p>In the ZK setting, we execute the <code>transfer</code> function within the zkVM. We must input the encoded state the account and receive as output the encoded state of the mutated account.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn program(mut state: State, encoder: Encoder, arguments: Arguments) -&gt; Commitment {
    let (signature, from, to, value) = arguments;
    let initial = encoder.commitment(state);

    state.transfer(signature, from, to, value);

	let arguments = encoder.commitment(arugment)
    let finalized = encoder.commitment(state)
    let output = encoder.commitment(initial, arguments, finalized) 

    encoder.commitment(initial, arguments, output)
}
<span class="boring">}</span></code></pre></pre>
<p>Running this program within the zkVM, also allows us to generate a <code>Proof</code>.</p>
<p>Upon receiving the <code>(Proof, Commitment, Arguments)</code> data on the target chain, it can validate the execution correctness by verifying the proof and commitments, leveraging the ZK property that the proof will be valid if, and only if, the contract's execution was accurate for the given inputs, and the supplied commitments are those generated specifically for this proof.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn verify(&amp;self, proof: Proof, arguments: Arguments) {
    let current = self.state.commitment();
    let args = arguments.commitment();
    let (from, to, value) = arguments;

    self.transfer_trusted(from, to, value);

    let mutated = self.state.commitment();
    let commitment = (current, args, mutated).commitment();

    proof.verify(&amp;self.vk, commitment);
}
<span class="boring">}</span></code></pre></pre>
<p>By doing so, we switch from on-chain signature verification to computation over committed arguments, followed by ZK proof verification. Although we've presented a simplified example, the same verification process can accommodate any computation supported by a zkVM, enabling us to process multiple transfers in batches, perform intricate computation, and succinctly verify execution correctness. We refer to this pattern as a <strong>"Unary Encoder"</strong> because we compress the two states of the account, 'current' and 'mutated', into a single zero-knowledge proof.</p>
<p>The Unary Encoder will be the responsible for compressing any chain account state into a compatible commitment for the chosen zkVM (in our case a RISC-V zkVM). The encoding is a one-way function that allows anyone in possession of the pre-image, i.e. inputs to the encoding function, to reconstruct the commitment. This commitment will be transparent to the target chain, enabling use in construction of the block header for verification purposes.</p>
<h3 id="handling-state-transition-dependencies-across-domains-merkelized-encoder"><a class="header" href="#handling-state-transition-dependencies-across-domains-merkelized-encoder">Handling state transition dependencies across domains: Merkelized Encoder</a></h3>
<p>Lets assume a hypothetical situation where we aim to achieve decoupled state updates across three distinct chains: <code>chain 1</code>, <code>chain 2</code>, and <code>chain 3</code>. The objective is to generate a unified ZK proof that verifies the correctness of the state transitions on all chains.</p>
<p>Specifically, <code>chain 3</code> will depend on a mutation from <code>chain 1</code>, while <code>chain 2</code> operates independently of the mutations on both <code>chain 1</code> and <code>chain 3</code>.</p>
<pre class="mermaid">graph TB
    %% Root node
    r[R]
    
    %% Level 1
    m1[M1] --&gt; r
    m2[M2] --&gt; r
    
    %% Level 2
    c1[C1] --&gt; m1
    c2[C2] --&gt; m1
    c3[C3] --&gt; m2
    zero((0)) --&gt; m2
    
    %% Level 3
    chain1[&quot;(S1 --&gt; T1), K1&quot;] -- chain 1 transition encoding --&gt; c1
    chain2[&quot;(S2 --&gt; T2), K2&quot;] -- chain 2 transition encoding --&gt; c2
    chain3[&quot;(S3 --&gt; T3), K3&quot;] -- chain 3 transition encoding --&gt; c3
</pre>
<p>The Merkle Graph above depicts the state transition that can be compressed into a single commitment via Merkelization. Given an encoder with a specialized argument—a Sparse Merkle tree containing encoded state transition values indexed by the program's view key on the target blockchain—we obtain a Merkle Root denoted as <code>R</code>.</p>
<p>The ZK coprocessor can execute proof computations either sequentially or in parallel. The parallel computation associated with <code>C2</code> operates independently and generates a unary proof of <code>S2 -&gt; T2</code>. Conversely, the proof for <code>C3</code> requires querying <code>T1</code>.</p>
<p>Since <code>chain 3</code> has a sequential execution, the coprocessor will first process <code>C1</code>, then relay the pre-image of <code>T1</code> to the coprocessor responsible for computing <code>C3</code>. Due to the deterministic nature of unary encoding, the <code>chain 3</code> coprocessor can easily derive <code>T1</code> and validate its foreign state while concurrently processing <code>C3</code>.</p>
<p>At this point, there is no justification given for Merkelizing the produced proofs, hashing the entire set of Merkle arguments would work as well. However, it's worth noting that <code>chain 2</code> does not require knowledge of the data <code>(S1, T1, K1, S3, T3, K3)</code>. Including such information in the verification arguments of <code>chain 3</code> would unnecessarily burden its proving process. A Merkle tree is employed here for its logarithmic verification property: the condensed proof generated for <code>chain 2</code> will only require a Merkle opening to <code>R</code>, without requiring excess state data from other chains. Essentially, when generating the Merkelized proof, the <code>chain 2</code> coprocessor, after computing <code>C2</code>, will need only <code>C1</code> and <code>M2</code>, rather than all Merkle arguments.</p>
<p>Finally, each chain will receive <code>R</code>, accompanied by its individual state transition arguments, and the Merkle path leading to <code>R</code> will be proven inside of the circuit.</p>
<pre class="mermaid">---
title: On-chain Proof Verification
---
graph TD;
	coprocessor --(R1, T1)--&gt; chain1
	coprocessor --(R2, T2)--&gt; chain2
	coprocessor --(R3, T3, R1, T1, C2)--&gt; chain3
</pre>
<p>In this diagram we see <code>chain 3</code> will first <code>verify(R3, T3)</code>, then <code>verify(R1, T1)</code>, then it will <code>query(T1)</code>, then compute <code>C1 := encoding(S1, T1)</code>, then compute  <code>C3 := encoding(S3, T3)</code>, and finally will assert <code>R == H(H(C1, C2), H(C3, 0))</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sparse-merkle-tree"><a class="header" href="#sparse-merkle-tree">Sparse Merkle tree</a></h1>
<p>A sparse Merkle tree (SMT) is a specialized version of a Merkle tree, characterized by a leaf index defined by an injective function derived from a predefined argument at the design level. The verification key of a ZK circuit is another constant, also injective to the circuit's definition, and can serve as an index for the available programs.</p>
<p>In the context of a ZK proof being a product of its verification key (alongside other attributes), it allows us to index a proof from a collection of proofs for distinct programs.</p>
<p>Assuming that we don't reuse the same proof for different purposes during a state transition, as the program will either be raw or recursed, the verifying key is an unique index in such collection.</p>
<p>This document describes a sparse Merkle tree design that employs indexing proofs based on the hash of the verification key.</p>
<h2 id="merkle-tree"><a class="header" href="#merkle-tree">Merkle tree</a></h2>
<p>A Merkle tree is typically a (binary) tree structure consisting of leaves and nodes. Each node in this tree represents the cryptographic hash of its children, while the leaves hold an arbitrary piece of data—usually the hash value of some variable input.</p>
<p>For a hash function <code>H</code>, if we insert the data items A, B, C into a Merkle tree, the resulting structure would look like:</p>
<pre class="mermaid">graph TB
    %% Root node
    r[&quot;R := H(t10, t11)&quot;]
    
    %% Level 1
    m1[&quot;t10 := H(t00, t01)&quot;] --&gt; r
    m2[&quot;t11 := H(t02, t03)&quot;] --&gt; r
    
    %% Level 2
    c1[&quot;t00 := H(A)&quot;] --&gt; m1
    c2[&quot;t01 := H(B)&quot;] --&gt; m1
    c3[&quot;t02 := H(C)&quot;] --&gt; m2
    c4[&quot;t03 := 0&quot;] --&gt; m2
</pre>
<h3 id="membership-proof"><a class="header" href="#membership-proof">Membership proof</a></h3>
<p>A Merkle tree serves as an efficient data structure for validating the membership of a leaf node within a set in logarithmic time, making it especially useful for handling large sets. A Merkle opening (or Merkle proof) represents an array of sibling nodes that outline a Merkle Path leading to a commitment Root. If the verifier possesses the root and employs a cryptographic hash function, the pre-image of the hash is non-malleable; in a cryptographic hash, it's unfeasible to discover a set of siblings resulting in the root, except for the valid inputs. Given that the leaf node is known to the verifier, a Merkle Proof will consist of a sequence of hashes leading up to the root. This allows the verifier to compute the root value and compare it with the known Merkle root, thereby confirming the membership of any provided alleged member without relying on the trustworthiness of the source. Consequently, a single hash commitment ensures that any verifier can securely validate the membership of any proposed member supplied by an untrusted party.</p>
<p>On the example above, the Merkle opening for <code>C</code> is the siblings of the path until the root, that is: <code>[t03, t10]</code> . The verifier, that knows <code>R</code> beforehand, will compute:</p>
<ol>
<li><code>t02 := H(C)</code></li>
<li><code>t11 := H(t02, t03)</code></li>
<li><code>R' := H(t10, t11)</code></li>
</ol>
<p>If <code>R == R'</code>, then <code>C</code> is a member of the set.</p>
<p>Note that the depth of the tree is the length of its Merkle opening, that is: we open up to a node with depth equal to the length of the proof.</p>
<h2 id="sparse-data"><a class="header" href="#sparse-data">Sparse Data</a></h2>
<p>Let's consider a public function <code>f</code> that accepts a member and returns a tuple. This tuple consists of the index within the tree as a <code>u64</code> value, and the hash of the leaf: <code>(i, h) = f(X)</code>.</p>
<p>For the example above, let’s assume two members:</p>
<ul>
<li><code>(3, a) := f(A)</code></li>
<li><code>(1, b) := f(B)</code></li>
</ul>
<pre class="mermaid">graph TB
    %% Root node
    r[&quot;R := H(t10, t11)&quot;]
    
    %% Level 1
    m1[&quot;t10 := H(t00, t01)&quot;] --&gt; r
    m2[&quot;t11 := H(t02, t03)&quot;] --&gt; r
    
    %% Level 2
    c1[&quot;t00 := 0&quot;] --&gt; m1
    c2[&quot;t01 := b&quot;] --&gt; m1
    c3[&quot;t02 := 0&quot;] --&gt; m2
    c4[&quot;t03 := a&quot;] --&gt; m2
</pre>
<p>The primary distinction of a sparse Merkle tree lies in the deterministic leaf index, making it agnostic to input order. In essence, this structure forms an unordered set whose equivalence remains consistent irrespective of the sequence in which items are appended.</p>
<p>The behavior of the membership proof in this context mirrors that in a traditional Merkle tree, except that a sparse Merkle tree enables the generation of a non-membership proof. To achieve this, we carry out a Merkle opening at the specified target index, and expect it to be <code>0</code>.</p>
<p>Let’s assume a non-member <code>X</code> to be <code>(0, x) := f(X)</code> . To prove non-membership, we broadcast <code>[b, t11]</code> . To verify the non-membership of <code>X</code>, knowing <code>R</code> and the non-membership proof, we:</p>
<ol>
<li><code>(0, x) := f(X)</code></li>
<li><code>t10 := H(0, b)</code> ; here we open to <code>0</code></li>
<li><code>R’ := H(t10, t11)</code></li>
</ol>
<p>If <code>R == R'</code> , then <code>0</code> is at the slot of <code>X</code> . Since we know <code>X</code> to not be the pre-image of <code>0</code> in <code>H</code>, then <code>X</code> is not a member of the tree.</p>
<h2 id="valence-smt"><a class="header" href="#valence-smt">Valence SMT</a></h2>
<p>Within the scope of Valence, the sparse Merkle tree is designed to utilize the hash of the verifying key generated by the ZK circuit as its index. The tree's leaf data will encompass the proof and input arguments for the ZK program. In this particular implementation, we can consider the input arguments as a generic type, which will be specifically defined during development. These input arguments will constitute the key-value pairs that define a subset of the contract state essential for state transition. The proof will be a vector of bytes.</p>
<p>The tree depth will be adaptive, representing the smallest feasible value required to traverse from the leaf nodes up to the root, given the number of elements involved. This approach ensures we avoid unnecessary utilization of nodes containing unused entries.</p>
<p>For instance, if the tree contains two adjacent nodes indexed at <code>[(0,0), (0,1)]</code>, the Merkle opening proof will have a single element—specifically the sibling leaf of the validated node.</p>
<p>In case the tree comprises two nodes with indices <code>[(0,0), (0,2)]</code>, the Merkle opening will require two elements, allowing for a complete traversal from the leaves to the root.</p>
<h3 id="precomputed-empty-subtrees"><a class="header" href="#precomputed-empty-subtrees">Precomputed empty subtrees</a></h3>
<p>Every Merkle tree implementation should include a pre-computed set of empty subtrees, based on the selected hash primitive. To avoid unnecessary computational expenditure, it is more efficient to pre-compute the roots of subtrees consisting solely of zeroed leaves. For instance, all the nodes of the following Merkle tree are constant values for <code>H</code> :</p>
<pre class="mermaid">graph TB
    %% Root node
    r[&quot;R := H(t10, t11)&quot;]
    
    %% Level 1
    m1[&quot;t10 := H(t00, t01)&quot;] --&gt; r
    m2[&quot;t11 := H(t02, t03)&quot;] --&gt; r
    
    %% Level 2
    c1[&quot;t00 := 0&quot;] --&gt; m1
    c2[&quot;t01 := 0&quot;] --&gt; m1
    c3[&quot;t02 := 0&quot;] --&gt; m2
    c4[&quot;t03 := 0&quot;] --&gt; m2
</pre>
<p>Let’s assume we have a long path on a sparse Merkle tree with a single leaf <code>X</code> with index 2:</p>
<pre class="mermaid">graph TB
    %% Root
    r[&quot;R := H(t20, K2)&quot;]
    
    %% Level 1
    t20[&quot;t20 := H(K1, t11)&quot;] --&gt; r
    t21[&quot;K2&quot;] --&gt; r
    
    %% Level 2
    m1[&quot;K1&quot;] --&gt; t20
    m2[&quot;t11 := H(X, K0)&quot;] --&gt; t20
    
    %% Level 3
    c3[&quot;X&quot;] --&gt; m2
    c4[&quot;K0&quot;] --&gt; m2
</pre>
<p>It would be a waste to compute <code>(K0, K1, K2)</code> here as they are, respectively, <code>K0 := H(0)</code>, <code>K1 := H(K0, K0)</code>, <code>K2 := (K1, K1)</code>. In other words, they are constant values that should be available and should never have to hit the database backend in order to have their values fetched, nor should they exist as a data node. Whenever the tree queries for a node that doesn't exist on the data backend, it should return the constant precomputed empty subtree for that depth.</p>
<p>Normally, the trees will support precomputed values up to a certain depth. If we adopt a 16 bits output hash function, we should have 16 precomputed empty subtrees.</p>
<h3 id="future-upgrades"><a class="header" href="#future-upgrades">Future upgrades</a></h3>
<p>We don't expect the MVP to be optimized. That is, we should have a working implementation, but not yet optimized to specific use-case.</p>
<ul>
<li><strong>Hash</strong>: In the context of sparse Merkle trees, the MVP could employ a widely-accepted cryptographic hash function as its fundamental building block. For example, the Keccak256, which is native to EVM, could be used due to its broad availability. However, utilizing this hash function may lead to an extensive gap between nodes, potentially resulting in a tree structure with only 2 leaves yet a significant depth, as the hashes of the two verifying keys might be exceptionally far apart. A future improvement would be to choose of a cryptographic hash that keeps the leaf nodes close. One cheap method to achieve this is by taking the initial <code>n</code> bits (e.g., 16) of the hash output and using it as an index, given that any secure cryptographic hash maintains its collision resistance and avalanche effect characteristics across the target security level with the selected number of sampled bits. While we anticipate not dealing with a large number of program, (i.e. a 256-bit number, 16 bits should be more than sufficient for this purpose.</li>
<li><strong>Data backend</strong>: In typical scenarios, the number of nodes in a proof batch shouldn't be large: 8 bits should suffice to represent the number of programs; for very complex and large batches, 16 bits should suffice. Choosing a database backend for a Merkle tree can be challenging because it involves deciding on storage methodologies and optimizing database seek operations to retrieve nodes from the same path on a single page when possible. However, with a limited number of nodes, a streamlined database backend could suffice, delivering requested nodes without regard for the total page count. Given this performance constraint, we should prioritize compatibility over optimization: the ability to use the same backend across multiple blockchain clients and execution environments is more crucial than fine-tuning something that functions well only under specific conditions.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="authorizations--processors"><a class="header" href="#authorizations--processors">Authorizations &amp; Processors</a></h1>
<p>The <strong>Authorizations</strong> and <strong>Processor</strong> contracts are foundational pieces of the <strong>Valence Protocol</strong>, as they enable on-chain (and cross-chain) execution of <strong>Valence Programs</strong> and enforce access control to the program's <strong>Subroutines</strong> via <strong>Authorizations</strong>.</p>
<p>This section explains the rationale for these contracts and shares insights into their technical implementation, as well as how end-users can interact with <strong>Valence Programs</strong> via <strong>Authorizations</strong>.</p>
<h2 id="rationale"><a class="header" href="#rationale">Rationale</a></h2>
<ul>
<li>To have a general purpose set of smart contracts that provide users with a single point of entry to interact with the Valence Program, which can have libraries and accounts deployed on multiple chains.</li>
<li>To have all the user authorizations for multiple domains in a single place, making it very easy to control the application.</li>
<li>To have a single address (<code>Processor</code>) that will execute the messages for all the contracts in a domain using execution queues.</li>
<li>To only tick a single contract (<code>Processor</code>) that will go through the queues to route and execute the messages.</li>
<li>To create, edit, or remove different application permissions with ease.</li>
</ul>
<h2 id="technical-deep-dive"><a class="header" href="#technical-deep-dive">Technical deep-dive:</a></h2>
<ul>
<li><a href="authorizations_processors/./assumptions.html">Assumptions</a></li>
<li><a href="authorizations_processors/./processor.html">Processor Contract</a></li>
<li><a href="authorizations_processors/./authorization.html">Authorization Contract</a>
<ul>
<li><a href="authorizations_processors/./authorization_instantiation.html">Instantiation</a></li>
<li><a href="authorizations_processors/./authorization_owner_actions.html">Owner Actions</a></li>
<li><a href="authorizations_processors/./authorization_user_actions.html">User Actions</a></li>
</ul>
</li>
<li><a href="authorizations_processors/./callbacks.html">Callbacks</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assumptions"><a class="header" href="#assumptions">Assumptions</a></h1>
<ul>
<li>
<p><strong>Funds</strong>: You cannot send funds with the messages.</p>
</li>
<li>
<p><strong>Bridging</strong>: We are assuming that messages can be sent and confirmed bidirectionally between domains. The authorization contract on the main domain communicates with the processor in a different domain in one direction and the callback confirming the correct or failed execution in the other direction.</p>
</li>
<li>
<p><strong>Instantiation</strong>: All these contracts can be instantiated beforehand and off-chain having predictable addresses. Here is an example instantiation flow using Polytone:</p>
<ul>
<li>Predict <code>authorization</code> contract address.</li>
<li>Instantiate polytone contracts &amp; set up relayers.</li>
<li>Predict <code>proxy</code> contract address for the <code>authorization</code> contract on each external domain.</li>
<li>Predict <code>proxy</code> contract address on the main domain for each processor on external domains.</li>
<li>Instantiate all <code>processors</code>. The sender on external domains will be the predicted <code>proxy</code> and on the main domain it will be the authorization contract iself.</li>
<li>Instantiate authorization contract with all the processors and their predicted proxies for external domains and the processor on the main domain.</li>
</ul>
</li>
<li>
<p><strong>Relaying</strong>: Relayers will be running once everything is instantiated.</p>
</li>
<li>
<p><strong>Tokenfactory</strong>: The main domain has the token factory module with no token creation fee so that we can create and mint these nonfungible tokens with no additional cost.</p>
</li>
<li>
<p><strong>Domains</strong>: In the current version, actions in each authorization will be limited to a single domain.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="processor"><a class="header" href="#processor">Processor</a></h1>
<p>The <code>Processor</code> will be a contract on each domain of our workflow. It handles the execution queues which contain <code>Message Batches</code>. The <code>Processor</code> can be <code>ticked</code> permissionlessly, which will execute the next <code>Message Batch</code> in the queue if this one is executable or rotate it to the back of the queue if it isn't executable yet. The processor will also handle the <code>Retry</code> logic for each batch (if the batch is atomic) or function (if the batch is non atomic). After a <code>Message Batch</code> has been executed successfully or it reached the maximum amount of retries, it will be removed from the execution queue and the <code>Processor</code> will send a callback with the execution information to the <code>Authorization</code> contract.</p>
<p>The processors will be instantiated in advance with the correct address that can send messages to them, according to the <em>InstantiationFlow</em> described in the <a href="authorizations_processors/assumptions.html">Assumptions</a> section.</p>
<p>The <code>Authorization</code> contract will be the only address allowed to add list of functions to the execution queues. It will also be allowed to Pause/Resume the <code>Processor</code> or to arbitrarily remove functions from the queues or add certain messages at a specific position.</p>
<p>There will be two execution queues: one <code>High</code> and one <code>Med</code>. This will allow giving different priorities to <code>Message</code>.</p>
<h3 id="execution"><a class="header" href="#execution">Execution</a></h3>
<p>When a processor is <code>Ticked</code> we will take the first <code>MessageBatch</code> from the queue (<code>High</code> if there are batches there or <code>Med</code> if there aren’t).
After taking them, we will execute them in different ways depending if the batch is <code>Atomic</code> or <code>NonAtomic</code>.</p>
<ul>
<li>For <code>Atomic</code> batches, the <code>Processor</code> will execute them by sending them to itself and trying to execute them in a <code>Fire and Forget</code> manner. If this execution fails, we will check the <code>RetryLogic</code> of the batch to decide if they are to be re-queued or not (if not, we will send a callback with <code>Rejected</code> status to the authorization contract).
If they succeeded we will send a callback with <code>Executed</code> status to the Authorization contract.</li>
<li>For <code>NonAtomic</code> batches, we will execute the functions one by one and applying the RetryLogic individually to each function if they fail. <code>NonAtomic</code> functions might also be confirmed via <code>CallbackConfirmations</code> in which case we will keep them in a separate Map until we receive that specific callback.
Each time a function is confirmed, we will re-queue the batch and keep track of what function we have to execute next.
If at some point a function uses up all its retries, we will send a callback to the Authorization contract with a <code>PartiallyExecuted(num_of_functions_executed)</code> status. If all of them succeed it will be <code>Executed</code> and if none of them were it will be <code>Rejected</code>.
For <code>NonAtomic</code> batches, we need to tick the processor each time the batch is at the top of the queue to continue, so we will need at least as many ticks as number of functions we have in the batch, and each function has to wait for its turn.</li>
</ul>
<h3 id="storage"><a class="header" href="#storage">Storage</a></h3>
<p>The <code>Processor</code> will receive batches of messages from the authorization contract and will enqueue them in a custom storage structure we designed for this purpose, called a <code>QueueMap</code>. This structure is a FIFO queue with owner privileges (allows the owner to insert or remove from any position in the queue).
Each “item” stored in the queue is an object <code>MessageBatch</code> that looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MessageBatch {
    pub id: u64,
    pub msgs: Vec&lt;ProcessorMessage&gt;,
    pub subroutine: Subroutine,
    pub priority: Priority,
    pub retry: Option&lt;CurrentRetry&gt;,
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>id: represents the global id of the batch. The <code>Authorization</code> contract, to understand the callbacks that it will receive from each processor, identifies each batch with an id. This id is unique for the entire application.</li>
<li>msgs: the messages the processor needs to execute for this batch (e.g. a CosmWasm ExecuteMsg or MigrateMsg).</li>
<li>subroutine: This is the config that the authorization table defines for the execution of these functions. With this field we can know if the functions need to be executed atomically or not atomically, for example, and the retry logic for each batch/function depending on the config type.</li>
<li>priority (for internal use): batches will be queued in different priority queues when they are received from the authorization contract. We also keep this priority here because they might need to be re-queued after a failed execution and we need to know where to re-queue them.</li>
<li>retry (for internal use): we are keeping the current retry we are at (if the execution previously failed) to know when to abort if we exceed the max retry amounts.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="authorization"><a class="header" href="#authorization">Authorization</a></h1>
<p>The authorization contract will be a single contract deployed on the main domain and that will define the authorizations of the top-level application, which can include libraries in different domains (chains). For each domain, there will be one Processor (with its corresponding execution queues). The <code>Authorization</code> contract will connect to all of the <code>Processors</code> using a connector (e.g. Polytone, Hyperlane…) and will route the <code>Message Batches</code> to be executed to the right domain. At the same time, for each external domain, we will have a proxy contract in the main domain which will receive the callbacks sent from the processor on the external domain with the <code>ExecutionResult</code> of the <code>Message Batch</code>.</p>
<p>The contract will be instantiated once at the very beginning and will be used during the entire top-level application lifetime. Users will never interact with the individual Smart Contracts of each workflow, but with the Authorization contract directly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="instantiation"><a class="header" href="#instantiation">Instantiation</a></h1>
<p>When the contract is instantiated, it will be provided the following information:</p>
<ul>
<li>
<p>Processor contract on main domain.</p>
</li>
<li>
<p><code>[(Domain, Connector(Polytone_note_contract), Processor_contract_on_domain, callback_proxy, IBC_Timeout_settings)]</code>: If it's a cross domain application, an array will be passed with each external domain label and its corresponding connector contracts and proxies that will be instantiated before hand. For each connector, there will be also a proxy corresponding to that external domain because it’s a two-way communication flow and we need to receive callbacks. Additionally, we need a set of <code>Timeout</code> settings for the bridge, to know for how long the messages sent through the connector are going to be valid.</p>
</li>
<li>
<p>Admin of the contract (if different to sender).</p>
</li>
</ul>
<p>The instantiation will set up all the processors on each domain so that we can start instantiating the libraries afterwards and providing the correct <code>Processor</code> addresses to each of them depending on which domain they are in.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="owner-functions"><a class="header" href="#owner-functions">Owner Functions</a></h1>
<ul>
<li>
<p><code>create_authorizations(vec[Authorization])</code>: provides an authorization list which is the core information of the authorization contract, it will include all the possible set of functions that can be executed. It will contain the following information:</p>
<ul>
<li>
<p>Label: unique name of the authorization. This label will be used to identify the authorization and will be used as subdenom of the tokenfactory token in case it is permissioned. Due to tokenfactory module restrictions, the max length of this field is 44 characters.
Example: If the label is <code>withdraw</code> and only address <code>neutron123</code> is allowed to execute this authorization, we will create the token <code>factory/&lt;contract_addr&gt;/withdraw</code> and mint one to that address. If <code>withdraw</code> was permissionless, there is no need for any token, so it's not created.</p>
</li>
<li>
<p>Mode: can either be <code>Permissioned</code> or <code>Permissionless</code>. If <code>Permissionless</code> is chosen, any address can execute this function list. In case of <code>Permissioned</code>, we will also say what type of permissioned type we want (with <code>CallLimit</code> or without), a list of addresses will be provided for both cases. In case there is a <code>CallLimit</code> we will mint a certain amount of tokens for each address that is passed, in case there isn’t we will only mint one token and that token will be used all the time.</p>
</li>
<li>
<p>NotBefore: from what time the authorization can be executed. We can specify a block height or a timestamp.</p>
</li>
<li>
<p>Expiration: until when (what block or timestamp) this authorization is valid.</p>
</li>
<li>
<p>MaxConcurrentExecutions (default 1): to avoid DDoS attacks and to clog the execution queues, we will allow certain authorizations subroutines to be present a maximum amount of times (default 1 unless overwritten) in the execution queue.</p>
</li>
<li>
<p>Subroutine: set of functions in a specific order to be executed. Subroutines can be of two types: <code>Atomic</code> or <code>NonAtomic</code>. For the <code>Atomic</code> subroutines, we will provide an array of <code>Atomic</code> functions and an optional <code>RetryLogic</code> for the entire subroutine. For the <code>NonAtomic</code> subroutines we will just provide an array of <code>NonAtomic</code> functions.</p>
<ul>
<li>
<p><code>AtomicFunction</code>: each Atomic function has the following parameters:</p>
<ul>
<li>
<p>Domain of execution (must be the same for all functions in v1).</p>
</li>
<li>
<p>MessageDetails: type (e.g. CosmWasmExecuteMsg) and message (name of the message in the ExecuteMsg json that can be executed with, if applied, three list of parameters: one for <code>MustBeIncluded</code>, one for <code>CannotBeIncluded</code> and one for <code>MustBeValue</code>. (This gives more control over the authorizations. Example: we want one authorization to provide the message with parameters (admin function for that service) but another authorization for the message without any Parameters (user function for that service).</p>
</li>
<li>
<p>Contract address that will execute it.</p>
</li>
</ul>
</li>
<li>
<p><code>NonAtomicFunction</code>: each NonAtomic function has the following parameters:</p>
<ul>
<li>
<p>Domain of execution</p>
</li>
<li>
<p>MessageDetails (like above).</p>
</li>
<li>
<p>Contract address that will execute it.</p>
</li>
<li>
<p>RetryLogic (optional, self-explanatory).</p>
</li>
<li>
<p>CallbackConfirmation (optional): This defines if a <code>NonAtomicFunction</code> is completed after receiving a callback (Binary) from a specific address instead of after a correct execution. This is used in case of the correct message execution not being enough to consider the message completed, so it will define what callback we should receive from a specific address to flag that message as completed. For this, the processor will append an <code>execution_id</code> to the message which will be also passed in the callback by the service to identify what function this callback is for.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Priority (default Med): priority of a set of functions can be set to High. If this is the case, they will go into a preferential execution queue. Messages in the <code>High</code> priority queue will be taken over messages in the <code>Med</code> priority queue.
All authorizations will have an initial state of <code>Enabled</code> .</p>
</li>
</ul>
<p>Here is an example of an Authorization table after its creation:</p>
<p><img src="authorizations_processors/../img/authorization_table.png" alt="Authorization Table" /></p>
</li>
<li>
<p><code>add_external_domains([external_domains])</code>: if we want to add external domains after instantiation.</p>
</li>
<li>
<p><code>modify_authorization(label, updated_values)</code>: can modify certain updatable fields of the authorization: start_time, expiration, max_concurrent_executions and priority.</p>
</li>
<li>
<p><code>disable_authorization(label)</code>: puts an Authorization to state <code>Disabled</code>. These authorizations can not be run anymore.</p>
</li>
<li>
<p><code>enable_authorization(label)</code>: puts an Authorization to state <code>Enabled</code> so that they can be run again.</p>
</li>
<li>
<p><code>mint_authorization(label, vec[(addresses, Optional: amounts)])</code>: if the authorization is <code>Permissioned</code> with <code>CallLimit: true</code>, this function will mint the corresponding token amounts of that authorization to the addresses provided. If <code>CallLimit: false</code> it will mint 1 token to the new addresses provided.</p>
</li>
<li>
<p><code>pause_processor(domain)</code>: pause the processor of the domain.</p>
</li>
<li>
<p><code>resume_processor(domain)</code>: resume the processor of the domain.</p>
</li>
<li>
<p><code>insert_messages(label, queue_position, queue_type, vec[ProcessorMessage])</code>: adds these set of messages to the queue at a specific position in the queue.</p>
</li>
<li>
<p><code>evict_messages(label, queue_position, queue_type)</code>: remove the set of messages from the specific position in a queue.</p>
</li>
<li>
<p><code>add_sub_owners(vec[addresses])</code>: add the current addresses as 2nd tier owners. These sub_owners can do everything except adding/removing admins.</p>
</li>
<li>
<p><code>remove_sub_owners(vec[addresses])</code>: remove these addresses from the sub_owner list.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="user-actions"><a class="header" href="#user-actions">User Actions</a></h1>
<ul>
<li>
<p><code>send_msgs(label, vec[ProcessorMessage])</code>: users can run an authorization with a specific label. If the authorization is <code>Permissioned</code>, the authorization contract will check if they are allowed to execute it by checking that the user has the token in its wallet if it's <code>Permissioned (without limit)</code> or that the user sent the token along with the messages if it's <code>Permissioned (with limit)</code>. Along with the authorization label, the user will provide an array of encoded messages, together with the message type (e.g. <code>CosmwasmExecuteMsg</code>) and any other parameters for that specific ProcessorMessage (e.g. for a <code>CosmwasmMigrateMsg</code> we need to also pass a code_id). The contract will then check that the messages match the ones defined in the authorization (and in the correct order) and that all Parameters restrictions, if applied, are correct.</p>
<p>If all checks are correct, the contract will route the messages to the correct <code>Processor</code> with an <code>execution_id</code> for the processor to callback with. This <code>execution_id</code> is unique for the entire application.
If the execution of all the actions are confirmed via a callback, we will burn the token and if they fail, we will send the token back.
Here is an example flowchart of how a user interacts with the authorization contract to execute messages in a service sitting on a domain:</p>
</li>
</ul>
<p><img src="authorizations_processors/../img/user_flowchart.png" alt="User flowchart" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="callbacks"><a class="header" href="#callbacks">Callbacks</a></h1>
<p>There are different types of callbacks in our application. Each of them have a specific function and are used in different parts of the application.</p>
<h2 id="function-callbacks"><a class="header" href="#function-callbacks">Function Callbacks</a></h2>
<p>For the execution of <code>NonAtomic</code> batches, each function in the batch can optionally be confirmed with a callback from a specific address. When the processor reaches a function that requires a callback, it will inject the execution_id of the batch into the message that is going to be executed on the library, which means that the library needs to be ready to receive that execution_id and know what the expected callback is and from where it has to come from to confirm that function, otherwise that function will stay unconfirmed and the batch will not move to the next function. The callback will be sent to the processor with the execution_id so that the processor can know what function is being confirmed. The processor will then validate that the correct callback was received from the correct address.</p>
<p>If the processor receives the expected callback from the correct address, the batch will move to the next function. If it receives a different callback than expected from that address, the execution of that function will be considered failed and it will be retried (if applicable). In any case, a callback must be received to determine if the function was successful or not.</p>
<h2 id="processor-callbacks"><a class="header" href="#processor-callbacks">Processor Callbacks</a></h2>
<p>Once a Processor batch is executed or it fails and there are no more retries available, the Processor will send a callback to the Authorizations contract with the execution_id of the batch and the result of the execution. All this information will be stored in the <code>Authorization</code> contract state so the history of all executions can be queried from it. This is how a <code>ProcessorCallback</code> looks like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ProcessorCallbackInfo {
    // Execution ID that the callback was for
    pub execution_id: u64,
    // Who started this operation, used for tokenfactory actions
    pub initiator: OperationInitiator,
    // Address that can send a bridge timeout or success for the message (if applied)
    pub bridge_callback_address: Option&lt;Addr&gt;,
    // Address that will send the callback for the processor
    pub processor_callback_address: Addr,
    // Domain that the callback came from
    pub domain: Domain,
    // Label of the authorization
    pub label: String,
    // Messages that were sent to the processor
    pub messages: Vec&lt;ProcessorMessage&gt;,
    // Optional ttl for re-sending in case of bridged timeouts
    pub ttl: Option&lt;Expiration&gt;,
    // Result of the execution
    pub execution_result: ExecutionResult,
}

pub enum ExecutionResult {
    InProcess,
    // Everthing executed successfully
    Success,
    // Execution was rejected, and the reason
    Rejected(String),
    // Partially executed, for non-atomic function batches
    // Indicates how many functions were executed and the reason the next function was not executed
    PartiallyExecuted(usize, String),
    // Removed by Owner - happens when, from the authorization contract, a remove item from queue is sent
    RemovedByOwner,
    // Timeout - happens when the bridged message times out
    // We'll use a flag to indicate if the timeout is retriable or not
    // true - retriable
    // false - not retriable
    Timeout(bool),
    // Unexpected error that should never happen but we'll store it here if it ever does
    UnexpectedError(String),
}
<span class="boring">}</span></code></pre></pre>
<p>The key information from here is the <code>label</code>, to identify the authorization that was executed; the <code>messages</code>, to identify what the user sent; and the <code>execution_result</code>, to know if the execution was successful, partially successful or rejected.</p>
<h2 id="bridge-callbacks"><a class="header" href="#bridge-callbacks">Bridge Callbacks</a></h2>
<p>When messages need to be sent through bridges because we are executing batches on external domains, we need to know if, for example, a timeout happened and keep track of it. For this reason we have callbacks per bridge that we support and specific logic that will be executed if they are received. For <code>Polytone</code> timeouts, we will check if the <code>ttl</code> field has not expired and allow permissionless retries if it's still valid. In case the <code>ttl</code> has expired, we will set the ExecutionResult to timeout and not retriable, then send the authorization token back to the user if the user sent it to execute the authorization.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libraries"><a class="header" href="#libraries">Libraries</a></h1>
<p>This section contains a detailed description of the various libraries that can be used to rapidly build Valence cross-chain programs.</p>
<p><strong>Valence Protocol libraries</strong>:</p>
<ul>
<li><a href="libraries/./astroport_lper.html">Astroport LPer</a></li>
<li><a href="libraries/./astroport_withdrawer.html">Astroport Withdrawer</a></li>
<li><a href="libraries/./forwarder.html">Forwarder</a></li>
<li><a href="libraries/./generic_ibc_transfer.html">Generic IBC Transfer</a></li>
<li><a href="libraries/./neutron_ibc_transfer.html">Neutron IBC Transfer</a></li>
<li><a href="libraries/./osmosis_cl_lper.html">Osmosis CL LPer</a></li>
<li><a href="libraries/./osmosis_cl_withdrawer.html">Osmosis CL Withdrawer</a></li>
<li><a href="libraries/./osmosis_gamm_lper.html">Osmosis GAMM LPer</a></li>
<li><a href="libraries/./osmosis_gamm_withdrawer.html">Osmosis GAMM Withdrawer</a></li>
<li><a href="libraries/./reverse_splitter.html">Reverse Splitter</a></li>
<li><a href="libraries/./splitter.html">Splitter</a></li>
<li><a href="libraries/./neutron_ic_querier.html">Neutron Interchain Querier</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="astroport-lper-library"><a class="header" href="#astroport-lper-library">Astroport LPer library</a></h1>
<p>The <strong>Valence Astroport LPer library</strong> library allows to <strong>provide liquidity</strong> into an <strong>Astroport Liquidity Pool</strong> from an <strong>input account</strong> and deposit the <strong>LP tokens</strong> into an <strong>output account</strong>.</p>
<h2 id="high-level-flow"><a class="header" href="#high-level-flow">High-level flow</a></h2>
<pre class="mermaid">---
title: Astroport Liquidity Provider
---
graph LR
  IA((Input
      Account))
  OA((Output
		  Account))
  P[Processor]
  S[Astroport
      Liquidity
      Provider]
  AP[Astroport
     Pool]
  P -- 1/Provide Liquidity --&gt; S
  S -- 2/Query balances --&gt; IA
  S -- 3/Compute amounts --&gt; S
  S -- 4/Do Provide Liquidity --&gt; IA
  IA -- 5/Provide Liquidity
				  [Tokens] --&gt; AP
  AP -- 5'/Transfer LP Tokens --&gt; OA

</pre>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>ProvideDoubleSidedLiquidity</strong></td><td><code>expected_pool_ratio_range: Option&lt;DecimalRange&gt;</code></td><td>Provide double-sided liquidity to the pre-configured <strong>Astroport Pool</strong> from the <strong>input account</strong>, and deposit the <strong>LP tokens</strong> into the <strong>output account</strong>. Abort it the pool ratio is not within the <code>expected_pool_ratio</code> range (if specified).</td></tr>
<tr><td><strong>ProvideSingleSidedLiquidity</strong></td><td><code>asset: String</code><br><code>limit: Option&lt;Uint128&gt;</code><br><code>expected_pool_ratio_range: Option&lt;DecimalRange&gt;</code></td><td>Provide single-sided liquidity for the specified <code>asset</code> to the pre-configured <strong>Astroport Pool</strong> from the <strong>input account</strong>, and deposit the <strong>LP tokens</strong> into the <strong>output account</strong>. Abort it the pool ratio is not within the <code>expected_pool_ratio</code> range (if specified).</td></tr>
</tbody></table>
</div>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>The library is configured on instantiation via the <code>LibraryConfig</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LibraryConfig {
    // Account from which the funds are LPed
    pub input_addr: LibraryAccountType,
    // Account to which the LP tokens are forwarded
    pub output_addr: LibraryAccountType,
    // Pool address
    pub pool_addr: String,
    // LP configuration
    pub lp_config: LiquidityProviderConfig,
}

pub struct LiquidityProviderConfig {
    // Pool type, old Astroport pools use Cw20 lp tokens and new pools use native tokens, so we specify here what kind of token we are going to get.
    // We also provide the PairType structure of the right Astroport version that we are going to use for each scenario
    pub pool_type: PoolType,
    // Denoms of both native assets we are going to provide liquidity for
    pub asset_data: AssetData,
    // Slippage tolerance
    pub slippage_tolerance: Option&lt;Decimal&gt;,
}

#[cw_serde]
pub enum PoolType {
    NativeLpToken(valence_astroport_utils::astroport_native_lp_token::PairType),
    Cw20LpToken(valence_astroport_utils::astroport_cw20_lp_token::PairType),
}


pub struct AssetData {
    pub asset1: String,
    pub asset2: String,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="astroport-withdrawer-library"><a class="header" href="#astroport-withdrawer-library">Astroport Withdrawer library</a></h1>
<p>The <strong>Valence Astroport Withdrawer library</strong> library allows to <strong>withdraw liquidity</strong> from an Astroport Liquidity Pool from an <strong>input account</strong> an deposit the withdrawed tokens into an <strong>output account</strong>.</p>
<h2 id="high-level-flow-1"><a class="header" href="#high-level-flow-1">High-level flow</a></h2>
<pre class="mermaid">---
title: Astroport Liquidity Withdrawal
---
graph LR
  IA((Input
      Account))
  OA((Output
		  Account))
  P[Processor]
  S[Astroport
      Liquidity
      Withdrawal]
  AP[Astroport
     Pool]
  P -- 1/Withdraw Liquidity --&gt; S
  S -- 2/Query balances --&gt; IA
  S -- 3/Compute amounts --&gt; S
  S -- 4/Do Withdraw Liquidity --&gt; IA
  IA -- 5/Withdraw Liquidity
				  [LP Tokens] --&gt; AP
  AP -- 5'/Transfer assets --&gt; OA
</pre>
<h2 id="functions-1"><a class="header" href="#functions-1">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>WithdrawLiquidity</strong></td><td>-</td><td>Withdraw liquidity from the configured <strong>Astroport Pool</strong> from the <strong>input account</strong> and deposit the withdrawed tokens into the configured <strong>output account</strong></td></tr>
</tbody></table>
</div>
<h2 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h2>
<p>The library is configured on instantiation via the <code>LibraryConfig</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LibraryConfig {
    // Account holding the LP position
    pub input_addr: LibraryAccountType,
    // Account to which the withdrawn assets are forwarded
    pub output_addr: LibraryAccountType,
    // Pool address
    pub pool_addr: String,
    // Liquidity withdrawer configuration
    pub withdrawer_config: LiquidityWithdrawerConfig,
}

pub struct LiquidityWithdrawerConfig {
    // Pool type, old Astroport pools use Cw20 lp tokens and new pools use native tokens, so we specify here what kind of token we are will use.
    // We also provide the PairType structure of the right Astroport version that we are going to use for each scenario
    pub pool_type: PoolType,
}

pub enum PoolType {
    NativeLpToken,
    Cw20LpToken,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="valence-forwarder-library"><a class="header" href="#valence-forwarder-library">Valence Forwarder library</a></h1>
<p>The <strong>Valence Forwarder</strong> library allows to <strong>continuously forward funds</strong> from an <strong>input account</strong> to an <strong>output account</strong>, following some time <strong>constraints</strong>. It is typically used as part of a <strong>Valence Program</strong>. In that context, a <strong>Processor</strong> contract will be the main contract interacting with the Forwarder library.</p>
<h2 id="high-level-flow-2"><a class="header" href="#high-level-flow-2">High-level flow</a></h2>
<pre class="mermaid">---
title: Forwarder Library
---
graph LR
  IA((Input
      Account))
  OA((Output
		  Account))
  P[Processor]
  S[Forwarder
    Library]
  P -- 1/Forward --&gt; S
  S -- 2/Query balances --&gt; IA
  S -- 3/Do Send funds --&gt; IA
  IA -- 4/Send funds --&gt; OA
</pre>
<h2 id="functions-2"><a class="header" href="#functions-2">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>Forward</strong></td><td>-</td><td>Forward funds from the configured <strong>input account</strong> to the <strong>output account</strong>, according to the <strong>forwarding configs</strong> &amp; <strong>constraints</strong>.</td></tr>
</tbody></table>
</div>
<h2 id="configuration-2"><a class="header" href="#configuration-2">Configuration</a></h2>
<p>The library is configured on instantiation via the <code>LibraryConfig</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LibraryConfig {
    // Account from which the funds are pulled
    pub input_addr: LibraryAccountType,
    // Account to which the funds are sent
    pub output_addr: LibraryAccountType,
    // Forwarding configuration per denom
    pub forwarding_configs: Vec&lt;UncheckedForwardingConfig&gt;,
    // Constraints on forwarding operations
    pub forwarding_constraints: ForwardingConstraints,
}

pub struct UncheckedForwardingConfig {
    // Denom to be forwarded (either native or CW20)
    pub denom: UncheckedDenom,
    // Max amount of tokens to be transferred per Forward operation
    pub max_amount: Uint128,
}

// Time constraints on forwarding operations
pub struct ForwardingConstraints {
    // Minimum interval between 2 successive forward operations,
    // specified either as a number of blocks, or as a time delta.
    min_interval: Option&lt;Duration&gt;,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="valence-generic-ibc-transfer-library"><a class="header" href="#valence-generic-ibc-transfer-library">Valence Generic IBC Transfer library</a></h1>
<p>The <strong>Valence Generic IBC Transfer</strong> library allows to transfer funds over IBC from an <strong>input account</strong> on a source chain to an <strong>output account</strong> on a destination chain. It is typically used as part of a <strong>Valence Program</strong>. In that context, a <strong>Processor</strong> contract will be the main contract interacting with the Forwarder library.</p>
<p><strong>Note</strong>: this library should not be used on <strong>Neutron</strong>, which requires some fees to be paid to relayers for IBC transfers. For Neutron, prefer using the dedicated (and optimized) <strong><a href="libraries/./neutron-ibc-transfer.html">Neutron IBC Transfer library</a></strong> instead.</p>
<h2 id="high-level-flow-3"><a class="header" href="#high-level-flow-3">High-level flow</a></h2>
<pre class="mermaid">---
title: Generic IBC Transfer Library
---
graph LR
  IA((Input
      Account))
  OA((Output
		  Account))
  P[Processor]
  S[Gen IBC Transfer
    Library]
  subgraph Chain 1
  P -- 1/IbcTransfer --&gt; S
  S -- 2/Query balances --&gt; IA
  S -- 3/Do Send funds --&gt; IA
  end
  subgraph Chain 2
  IA -- 4/IBC Transfer --&gt; OA
  end
</pre>
<h2 id="functions-3"><a class="header" href="#functions-3">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>IbcTransfer</strong></td><td>-</td><td>Transfer funds over IBC from an <strong>input account</strong> on a source chain to an <strong>output account</strong> on a destination chain.</td></tr>
</tbody></table>
</div>
<h2 id="configuration-3"><a class="header" href="#configuration-3">Configuration</a></h2>
<p>The library is configured on instantiation via the <code>LibraryConfig</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct LibraryConfig {
  // Account from which the funds are pulled (on the source chain)
  input_addr: LibraryAccountType,
  // Account to which the funds are sent (on the destination chain)
  output_addr: String,
  // Denom of the token to transfer
  denom: UncheckedDenom,
  // Amount to be transferred, either a fixed amount or the whole available balance.
  amount: IbcTransferAmount,
  // Memo to be passed in the IBC transfer message.
  memo: String,
  // Information about the destination chain.
  remote_chain_info: RemoteChainInfo,
  // Denom map for the Packet-Forwarding Middleware, to perform a multi-hop transfer.
  denom_to_pfm_map: BTreeMap&lt;String, PacketForwardMiddlewareConfig&gt;,
}

// Defines the amount to be transferred, either a fixed amount or the whole available balance.
enum IbcTransferAmount {
  // Transfer the full available balance of the input account.
  FullAmount,
  // Transfer the specified amount of tokens.
  FixedAmount(Uint128),
}

pub struct RemoteChainInfo {
  // Channel of the IBC connection to be used.
  channel_id: String,
  // Port of  the IBC connection to be used.
  port_id: Option&lt;String&gt;,
  // Timeout for the IBC transfer.
  ibc_transfer_timeout: Option&lt;Uint64&gt;,
}

// Configuration for a multi-hop transfer using the Packet Forwarding Middleware
struct PacketForwardMiddlewareConfig {
  // Channel ID from the source chain to the intermediate chain
  local_to_hop_chain_channel_id: String,
  // Channel ID from the intermediate to the destination chain
  hop_to_destination_chain_channel_id: String,
  // Temporary receiver address on the intermediate chain
  hop_chain_receiver_address: String,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="valence-neutron-ibc-transfer-library"><a class="header" href="#valence-neutron-ibc-transfer-library">Valence Neutron IBC Transfer library</a></h1>
<p>The <strong>Valence Neutron IBC Transfer</strong> library allows to transfer funds over IBC from an <strong>input account</strong> on <strong>Neutron</strong> to an <strong>output account</strong> on a destination chain. It is typically used as part of a <strong>Valence Program</strong>. In that context, a <strong>Processor</strong> contract will be the main contract interacting with the Forwarder library.</p>
<p>Note: this library should not be used on another CosmWasm chain than <strong>Neutron</strong>, which requires some fees to be paid to relayers for IBC transfers. For other CosmWasm chains, prefer using the <strong><a href="libraries/./generic-ibc-transfer.html">Generic IBC Transfer library</a></strong> instead.</p>
<h2 id="high-level-flow-4"><a class="header" href="#high-level-flow-4">High-level flow</a></h2>
<pre class="mermaid">---
title: Neutron IBC Transfer Library
---
graph LR
  IA((Input
      Account))
  OA((Output
		  Account))
  P[Processor]
  S[Neutron IBC Transfer
    Library]
  subgraph Neutron
  P -- 1/IbcTransfer --&gt; S
  S -- 2/Query balances --&gt; IA
  S -- 3/Do Send funds --&gt; IA
  end
  subgraph Chain 2
  IA -- 4/IBC Transfer --&gt; OA
  end
</pre>
<h2 id="functions-4"><a class="header" href="#functions-4">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>IbcTransfer</strong></td><td>-</td><td>Transfer funds over IBC from an <strong>input account</strong> on <strong>Neutron</strong> to an <strong>output account</strong> on a destination chain.</td></tr>
</tbody></table>
</div>
<h2 id="configuration-4"><a class="header" href="#configuration-4">Configuration</a></h2>
<p>The library is configured on instantiation via the <code>LibraryConfig</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct LibraryConfig {
  // Account from which the funds are pulled (on the source chain)
  input_addr: LibraryAccountType,
  // Account to which the funds are sent (on the destination chain)
  output_addr: String,
  // Denom of the token to transfer
  denom: UncheckedDenom,
  // Amount to be transferred, either a fixed amount or the whole available balance.
  amount: IbcTransferAmount,
  // Memo to be passed in the IBC transfer message.
  memo: String,
  // Information about the destination chain.
  remote_chain_info: RemoteChainInfo,
  // Denom map for the Packet-Forwarding Middleware, to perform a multi-hop transfer.
  denom_to_pfm_map: BTreeMap&lt;String, PacketForwardMiddlewareConfig&gt;,
}

// Defines the amount to be transferred, either a fixed amount or the whole available balance.
enum IbcTransferAmount {
  // Transfer the full available balance of the input account.
  FullAmount,
  // Transfer the specified amount of tokens.
  FixedAmount(Uint128),
}

pub struct RemoteChainInfo {
  // Channel of the IBC connection to be used.
  channel_id: String,
  // Port of  the IBC connection to be used.
  port_id: Option&lt;String&gt;,
  // Timeout for the IBC transfer.
  ibc_transfer_timeout: Option&lt;Uint64&gt;,
}

// Configuration for a multi-hop transfer using the Packet Forwarding Middleware
struct PacketForwardMiddlewareConfig {
  // Channel ID from the source chain to the intermediate chain
  local_to_hop_chain_channel_id: String,
  // Channel ID from the intermediate to the destination chain
  hop_to_destination_chain_channel_id: String,
  // Temporary receiver address on the intermediate chain
  hop_chain_receiver_address: String,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="osmosis-cl-lper-library"><a class="header" href="#osmosis-cl-lper-library">Osmosis CL LPer library</a></h1>
<p>The <strong>Valence Osmosis CL LPer library</strong> library allows to <strong>create concentrated liquidity
positions</strong> on <strong>Osmosis</strong> from an <strong>input account</strong>, and deposit the <strong>LP tokens</strong> into an <strong>output account</strong>.</p>
<h2 id="high-level-flow-5"><a class="header" href="#high-level-flow-5">High-level flow</a></h2>
<pre class="mermaid">---
title: Osmosis CL Liquidity Provider
---
graph LR
  IA((Input
      Account))
  OA((Output
		  Account))
  P[Processor]
  S[Osmosis CL
      Liquidity
      Provider]
  AP[Osmosis CL
     Pool]
  P -- 1/Provide Liquidity --&gt; S
  S -- 2/Query balances --&gt; IA
  S -- 3/Configure target
    range --&gt; S
  S -- 4/Do Provide Liquidity --&gt; IA
  IA -- 5/Provide Liquidity
				  [Tokens] --&gt; AP
  AP -- 5'/Transfer LP Tokens --&gt; OA

</pre>
<h2 id="concentrated-liquidity-position-creation"><a class="header" href="#concentrated-liquidity-position-creation">Concentrated Liquidity Position creation</a></h2>
<p>Because of the way CL positions are created, there are two ways to achieve it:</p>
<h3 id="default"><a class="header" href="#default">Default</a></h3>
<p>Default position creation centers around the idea of creating a position
with respect to the currently active tick of the pool.</p>
<p>This method expects a single parameter, <code>bucket_amount</code>, which describes
how many <em>buckets</em> of the pool should be taken into account to both sides
of the price curve.</p>
<p>Consider a situation where the current tick is 125, and the configured
tick spacing is 10.</p>
<p>If this method is called with <code>bucket_amount</code> set to 5, the following logic
will be performed:</p>
<ul>
<li>find the current bucket range, which is 120 to 130</li>
<li>extend the current bucket ranges by 5 buckets to both sides, meaning
that the range "to the left" will be extended by 5 * 10 = 50, and the
range "to the right" will be extended by 5 * 10 = 50, resulting in the covered
range from 120 - 50 = 70 to 130 + 50 = 180, giving the position tick range of (70, 180).</li>
</ul>
<h3 id="custom"><a class="header" href="#custom">Custom</a></h3>
<p>Custom position creation allows for more fine-grained control over the
way the position is created.</p>
<p>This approach expects users to specify the following parameters:</p>
<ul>
<li><code>tick_range</code>, which describes the price range to be covered</li>
<li><code>token_min_amount_0</code> and <code>token_min_amount_1</code> which are optional
parameters that describe the minimum amount of tokens that should be
provided to the pool.</li>
</ul>
<p>With this flexibility a wide variety of positions can be created, such as
those that are entirely single-sided.</p>
<h2 id="functions-5"><a class="header" href="#functions-5">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>ProvideLiquidityDefault</strong></td><td><code>bucket_amount: Uint64</code></td><td>Create a position on the pre-configured <strong>Osmosis Pool</strong> from the <strong>input account</strong>, following the <a href="libraries/osmosis_cl_lper.html#default">Default approach</a> described above, and deposit the <strong>LP tokens</strong> into the <strong>output account</strong>.</td></tr>
<tr><td><strong>ProvideLiquidityCustom</strong></td><td><code>tick_range: TickRange</code><br><code>token_min_amount_0: Option&lt;Uint128&gt;</code><br><code>token_min_amount_1: Option&lt;Uint128&gt;</code></td><td>Create a position on the pre-configured <strong>Osmosis Pool</strong> from the <strong>input account</strong>, following the <a href="libraries/osmosis_cl_lper.html#custom">Custom approach</a> described above, and deposit the <strong>LP tokens</strong> into the <strong>output account</strong>.</td></tr>
</tbody></table>
</div>
<h2 id="configuration-5"><a class="header" href="#configuration-5">Configuration</a></h2>
<p>The library is configured on instantiation via the <code>LibraryConfig</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LibraryConfig {
    // Account from which the funds are LPed
    pub input_addr: LibraryAccountType,
    // Account to which the LP position is forwarded
    pub output_addr: LibraryAccountType,
    // LP configuration
    pub lp_config: LiquidityProviderConfig,
}

pub struct LiquidityProviderConfig {
    // ID of the Osmosis CL pool
    pub pool_id: Uint64,
    // Pool asset 1 
    pub pool_asset_1: String,
    // Pool asset 2
    pub pool_asset_2: String,
    // Pool global price range
    pub global_tick_range: TickRange,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="osmosis-cl-liquidity-withdrawer-library"><a class="header" href="#osmosis-cl-liquidity-withdrawer-library">Osmosis CL liquidity withdrawer library</a></h1>
<p>The <strong>Valence Osmosis CL Withdrawer library</strong> library allows to <strong>withdraw a concentrated liquidity
position</strong> off an <strong>Osmosis</strong> pool from an <strong>input account</strong>, and transfer the resulting tokens to an <strong>output account</strong>.</p>
<h2 id="high-level-flow-6"><a class="header" href="#high-level-flow-6">High-level flow</a></h2>
<pre class="mermaid">---
title: Osmosis CL Liquidity Withdrawal
---
graph LR
  IA((Input
      Account))
  OA((Output
		  Account))
  P[Processor]
  S[Osmosis CL
      Liquidity
      Withdrawal]
  AP[Osmosis CL
     Pool]
  P -- 1/Withdraw Liquidity --&gt; S
  S -- 2/Query balances --&gt; IA
  S -- 3/Compute amounts --&gt; S
  S -- 4/Do Withdraw Liquidity --&gt; IA
  IA -- 5/Withdraw Liquidity
				  [LP Position] --&gt; AP
  AP -- 5'/Transfer assets --&gt; OA
</pre>
<h2 id="functions-6"><a class="header" href="#functions-6">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>WithdrawLiquidity</strong></td><td><code>position_id: Uint64</code><br><code>liquidity_amount: String</code></td><td>Withdraw liquidity from the configured <strong>Osmosis Pool</strong> from the <strong>input account</strong>, according to the given parameters, and transfer the withdrawned tokens to the configured <strong>output account</strong></td></tr>
</tbody></table>
</div>
<h2 id="configuration-6"><a class="header" href="#configuration-6">Configuration</a></h2>
<p>The library is configured on instantiation via the <code>LibraryConfig</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LibraryConfig {
    // Account holding the LP position
    pub input_addr: LibraryAccountType,
    // Account to which the withdrawn assets are forwarded
    pub output_addr: LibraryAccountType,
    // ID of the pool
    pub pool_id: Uint64,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="osmosis-gamm-lper-library"><a class="header" href="#osmosis-gamm-lper-library">Osmosis GAMM LPer library</a></h1>
<p>The <strong>Valence Osmosis GAMM LPer library</strong> library allows to <strong>join a pool</strong> on <strong>Osmosis</strong>, using the <strong>GAMM module</strong> (Generalized Automated Market Maker), from an <strong>input account</strong>, and deposit the <strong>LP tokens</strong> into an <strong>output account</strong>.</p>
<h2 id="high-level-flow-7"><a class="header" href="#high-level-flow-7">High-level flow</a></h2>
<pre class="mermaid">---
title: Osmosis GAMM Liquidity Provider
---
graph LR
  IA((Input
      Account))
  OA((Output
          Account))
  P[Processor]
  S[Osmosis GAMM
      Liquidity
      Provider]
  AP[Osmosis
     Pool]
  P -- 1/Join Pool --&gt; S
  S -- 2/Query balances --&gt; IA
  S -- 3/Compute amounts --&gt; S
  S -- 4/Do Join Pool --&gt; IA
  IA -- 5/Join Pool
                  [Tokens] --&gt; AP
  AP -- 5'/Transfer LP tokens --&gt; OA

</pre>
<h2 id="functions-7"><a class="header" href="#functions-7">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>ProvideDoubleSidedLiquidity</strong></td><td><code>expected_spot_price: Option&lt;DecimalRange&gt;</code></td><td>Provide double-sided liquidity to the pre-configured <strong>Osmosis Pool</strong> from the <strong>input account</strong>, and deposit the <strong>LP tokens</strong> into the <strong>output account</strong>. Abort it the spot price is not within the <code>expected_spot_price</code> range (if specified).</td></tr>
<tr><td><strong>ProvideSingleSidedLiquidity</strong></td><td><code>asset: String</code><br><code>limit: Option&lt;Uint128&gt;</code><br><code>expected_spot_price: Option&lt;DecimalRange&gt;</code></td><td>Provide single-sided liquidity for the specified <code>asset</code> to the pre-configured <strong>Osmosis Pool</strong> from the <strong>input account</strong>, and deposit the <strong>LP tokens</strong> into the <strong>output account</strong>. Abort it the spot price is not within the <code>expected_spot_price</code> range (if specified).</td></tr>
</tbody></table>
</div>
<h2 id="configuration-7"><a class="header" href="#configuration-7">Configuration</a></h2>
<p>The library is configured on instantiation via the <code>LibraryConfig</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LibraryConfig {
    // Account from which the funds are LPed
    pub input_addr: LibraryAccountType,
    // Account to which the LP position is forwarded
    pub output_addr: LibraryAccountType,
    // LP configuration
    pub lp_config: LiquidityProviderConfig,
}

pub struct LiquidityProviderConfig {
    // ID of the Osmosis pool
    pub pool_id: Uint64,
    // Pool asset 1 
    pub pool_asset_1: String,
    // Pool asset 2
    pub pool_asset_2: String,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="osmosis-gamm-liquidity-withdrawer-library"><a class="header" href="#osmosis-gamm-liquidity-withdrawer-library">Osmosis GAMM liquidity withdrawer library</a></h1>
<p>The <strong>Valence Osmosis GAMM Withdrawer library</strong> library allows to <strong>exit a pool</strong> on <strong>Osmosis</strong>, using the <strong>GAMM module</strong> (Generalized Automated Market Maker), from an <strong>input account</strong>, an deposit the withdrawed tokens into an <strong>output account</strong>.</p>
<h2 id="high-level-flow-8"><a class="header" href="#high-level-flow-8">High-level flow</a></h2>
<pre class="mermaid">---
title: Osmosis GAMM Liquidity Withdrawal
---
graph LR
  IA((Input
      Account))
  OA((Output
		  Account))
  P[Processor]
  S[Osmosis GAMM
      Liquidity
      Withdrawal]
  AP[Osmosis
     Pool]
  P -- 1/Withdraw Liquidity --&gt; S
  S -- 2/Query balances --&gt; IA
  S -- 3/Compute amounts --&gt; S
  S -- 4/Do Withdraw Liquidity --&gt; IA
  IA -- 5/Withdraw Liquidity
				  [LP Tokens] --&gt; AP
  AP -- 5'/Transfer assets --&gt; OA
</pre>
<h2 id="functions-8"><a class="header" href="#functions-8">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>WithdrawLiquidity</strong></td><td>-</td><td>Withdraw liquidity from the configured <strong>Osmosis Pool</strong> from the <strong>input account</strong> and deposit the withdrawed tokens into the configured <strong>output account</strong></td></tr>
</tbody></table>
</div>
<h2 id="configuration-8"><a class="header" href="#configuration-8">Configuration</a></h2>
<p>The library is configured on instantiation via the <code>LibraryConfig</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LibraryConfig {
    // Account from which the funds are LPed
    pub input_addr: LibraryAccountType,
    // Account to which the LP tokens are forwarded
    pub output_addr: LibraryAccountType,
    // Liquidity withdrawer configuration
    pub withdrawer_config: LiquidityWithdrawerConfig,
}

pub struct LiquidityWithdrawerConfig {
    // ID of the pool
    pub pool_id: Uint64,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="valence-reverse-splitter-library"><a class="header" href="#valence-reverse-splitter-library">Valence Reverse Splitter library</a></h1>
<p>The <strong>Reverse Splitter</strong> library allows to <strong>route funds</strong> from <strong>one or more input account(s)</strong> to a <strong>single output account</strong>, for <strong>one or more token denom(s)</strong> according to the configured <strong>ratio(s)</strong>. It is typically used as part of a <strong>Valence Program</strong>. In that context, a <strong>Processor</strong> contract will be the main contract interacting with the Forwarder library.</p>
<h2 id="high-level-flow-9"><a class="header" href="#high-level-flow-9">High-level flow</a></h2>
<pre class="mermaid">---
title: Reverse Splitter Library
---
graph LR
  IA1((Input
      Account1))
  IA2((Input
       Account2))
  OA((Output
		  Account))
  P[Processor]
  S[Reverse Splitter
    Library]
  C[Contract]
  P -- 1/Split --&gt; S
  S -- 2/Query balances --&gt; IA1
  S -- 2'/Query balances --&gt; IA2
  S -. 3/Query split ratio .-&gt; C
  S -- 4/Do Send funds --&gt; IA1
  S -- 4'/Do Send funds --&gt; IA2
  IA1 -- 5/Send funds --&gt; OA
  IA2 -- 5'/Send funds --&gt; OA
</pre>
<h2 id="functions-9"><a class="header" href="#functions-9">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>Split</strong></td><td>-</td><td>Split and route funds from the configured <strong>input account(s)</strong> to the <strong>output account</strong>, according to the configured <strong>token denom(s)</strong> and <strong>ratio(s)</strong>.</td></tr>
</tbody></table>
</div>
<h2 id="configuration-9"><a class="header" href="#configuration-9">Configuration</a></h2>
<p>The library is configured on instantiation via the <code>LibraryConfig</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct LibraryConfig {
    output_addr: LibraryAccountType,   // Account to which the funds are sent.
    splits: Vec&lt;UncheckedSplitConfig&gt;, // Split configuration per denom.
    base_denom: UncheckedDenom         // Base denom, used with ratios.
}

// Split config for specified account
struct UncheckedSplitConfig {
  denom: UncheckedDenom,                // Denom for this split configuration (either native or CW20).
  account: LibraryAccountType,          // Address of the input account for this split config.
  amount: UncheckedSplitAmount,         // Fixed amount of tokens or an amount defined based on a ratio.
  factor: Option&lt;u64&gt;                   // Multiplier relative to other denoms (only used if a ratio is specified).
}

// Ratio configuration, either fixed &amp; dynamically calculated
enum UncheckedRatioConfig {
  FixedAmount(Uint128), // Fixed amount of tokens
  FixedRatio(Decimal),  // Fixed ratio e.g. 0.0262 for NTRN/STARS (or could be another arbitrary ratio)
  DynamicRatio {        // Dynamic ratio calculation (delegated to external contract)
	contract_addr: "&lt;TWAP Oracle wrapper contract address&gt;",
    params: "base64-encoded arbitrary payload to send in addition to the denoms"
  }
}

// Standard query &amp; response for contract computing a dynamic ratio
// for the Splitter &amp; Reverse Splitter libraries.
#[cw_serde]
#[derive(QueryResponses)]
pub enum DynamicRatioQueryMsg {
    #[returns(DynamicRatioResponse)]
    DynamicRatio {
        denoms: Vec&lt;String&gt;,
        params: String,
    }
}

#[cw_serde]
// Response returned by the external contract for a dynamic ratio
struct DynamicRatioResponse {
    pub denom_ratios: HashMap&lt;String, Decimal&gt;,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="valence-splitter-library"><a class="header" href="#valence-splitter-library">Valence Splitter library</a></h1>
<p>The <strong>Valence Splitter</strong> library allows to <strong>split funds</strong> from <strong>one input account</strong> to <strong>one or more output account(s)</strong>, for <strong>one or more token denom(s)</strong> according to the configured <strong>ratio(s)</strong>. It is typically used as part of a <strong>Valence Program</strong>. In that context, a <strong>Processor</strong> contract will be the main contract interacting with the Forwarder library.</p>
<h2 id="high-level-flow-10"><a class="header" href="#high-level-flow-10">High-level flow</a></h2>
<pre class="mermaid">---
title: Splitter Library
---
graph LR
  IA((Input
      Account))
  OA1((Output
		  Account 1))
	OA2((Output
		  Account 2))
  P[Processor]
  S[Splitter
    Library]
  C[Contract]
  P -- 1/Split --&gt; S
  S -- 2/Query balances --&gt; IA
  S -. 3/Query split ratio .-&gt; C
  S -- 4/Do Send funds --&gt; IA
  IA -- 5/Send funds --&gt; OA1
  IA -- 5'/Send funds --&gt; OA2
</pre>
<h2 id="functions-10"><a class="header" href="#functions-10">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>Split</strong></td><td>-</td><td>Split funds from the configured <strong>input account</strong> to the <strong>output account(s)</strong>, according to the configured <strong>token denom(s)</strong> and <strong>ratio(s)</strong>.</td></tr>
</tbody></table>
</div>
<h2 id="configuration-10"><a class="header" href="#configuration-10">Configuration</a></h2>
<p>The library is configured on instantiation via the <code>LibraryConfig</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct LibraryConfig {
    input_addr: LibraryAccountType,    // Address of the input account
    splits: Vec&lt;UncheckedSplitConfig&gt;, // Split configuration per denom
}

// Split config for specified account
struct UncheckedSplitConfig {
  denom: UncheckedDenom,          // Denom for this split configuration (either native or CW20)
  account: LibraryAccountType,    // Address of the output account for this split config
  amount: UncheckedSplitAmount,   // Fixed amount of tokens or an amount defined based on a ratio
}

// Split amount configuration, either a fixed amount of tokens or an amount defined based on a ratio
enum UncheckedSplitAmount {
  FixedAmount(Uint128),       // Fixed amount of tokens
  FixedRatio(Decimal),        // Fixed ratio e.g. 0.0262 for NTRN/STARS (or could be another arbitrary ratio)
  DynamicRatio {              // Dynamic ratio calculation (delegated to external contract)
    contract_addr: "&lt;TWAP Oracle wrapper contract address&gt;",
    params: "base64-encoded arbitrary payload to send in addition to the denoms"
  }
}

// Standard query &amp; response for contract computing a dynamic ratio
// for the Splitter &amp; Reverse Splitter libraries.
#[cw_serde]
#[derive(QueryResponses)]
pub enum DynamicRatioQueryMsg {
    #[returns(DynamicRatioResponse)]
    DynamicRatio {
        denoms: Vec&lt;String&gt;,
        params: String,
    }
}

#[cw_serde]
// Response returned by the external contract for a dynamic ratio
struct DynamicRatioResponse {
    pub denom_ratios: HashMap&lt;String, Decimal&gt;,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="neutron-interchain-querier"><a class="header" href="#neutron-interchain-querier">Neutron Interchain Querier</a></h1>
<p><strong>Neutron Interchain Querier library</strong> enables Valence Programs to configure and carry out
KV-based queries enabled by the <code>interchainqueries</code> module on Neutron.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<h3 id="active-neutron-icq-relayer"><a class="header" href="#active-neutron-icq-relayer">Active Neutron ICQ relayer</a></h3>
<p>This library requires active <a href="https://github.com/neutron-org/neutron-query-relayer">Neutron ICQ Relayers</a> operating on the specified target route.</p>
<h3 id="valence-middleware-broker"><a class="header" href="#valence-middleware-broker">Valence Middleware broker</a></h3>
<p>Each KV-based query requires a correctly encoded key in order to be registered.
This library obtains the query keys from <a href="libraries/./../middleware/broker.html">Valence Middleware brokers</a>,
which expose particular type registries.</p>
<p>For a given KV-query to be performed, the underlying type registry must implement <code>IcqIntegration</code> trait
which in turn enables the following functionality:</p>
<ol>
<li><code>get_kv_key</code>, enabling the ability to get the correctly encoded <code>KVKey</code> for query registration</li>
<li><code>decode_and_reconstruct</code>, allowing to reconstruct the interchain query result</li>
</ol>
<p>Read more about the given type ICQ integration in the <a href="libraries/./../middleware/type_registry.html#neutron-interchain-query-integration">type registry documentation page</a>.</p>
<h3 id="valence-storage-account"><a class="header" href="#valence-storage-account">Valence Storage account</a></h3>
<p>Results received and meant for further processing by other libraries will be stored in
<a href="libraries/./../components/storage_account.html">Storage Accounts</a>. Each instance of Neutron
IC querier will be associated with its own storage account.</p>
<h3 id="query-registration-fee"><a class="header" href="#query-registration-fee">Query registration fee</a></h3>
<p>Neutron <code>interchainqueries</code> module is configured to escrow a fee in order to register a query.
The fee parameter is dynamic and can be queried via the <code>interchainqueries</code> module.
Currently the fee is set to <code>100000untrn</code>, but it may change in the future.
Users must ensure that the fee is provided along with the query registration function call.</p>
<h3 id="query-deregistration"><a class="header" href="#query-deregistration">Query deregistration</a></h3>
<p>Interchain Query escrow payments can be reclaimed by submitting the <code>RemoveInterchainQuery</code> message.
Only the query owner (this contract) is able to submit this message.</p>
<p>Interchain Queries should be removed after they are no longer needed, however, that moment may be different for each Valence Program depending on its configuration.</p>
<h3 id="background-on-the-interchainqueries-module"><a class="header" href="#background-on-the-interchainqueries-module">Background on the <code>interchainqueries</code> module</a></h3>
<h4 id="query-registration-message-types"><a class="header" href="#query-registration-message-types">Query Registration Message types</a></h4>
<p>Interchain queries can be registered and unregistered by submitting the following <code>neutron-sdk</code> messages:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum NeutronMsg {
	// other variants
	RegisterInterchainQuery {
		/// **query_type** is a query type identifier ('tx' or 'kv' for now).
		query_type: String,

		/// **keys** is the KV-storage keys for which we want to get values from remote chain.
		keys: Vec&lt;KVKey&gt;,

		/// **transactions_filter** is the filter for transaction search ICQ.
		transactions_filter: String,

		/// **connection_id** is an IBC connection identifier between Neutron and remote chain.
		connection_id: String,

		/// **update_period** is used to say how often the query must be updated.
		update_period: u64,
	},
	RemoveInterchainQuery {
    query_id: u64,
	},
}
<span class="boring">}</span></code></pre></pre>
<p>where the <code>KVKey</code> is defined as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct KVKey {
    /// **path** is a path to the storage (storage prefix) where you want to read value by key (usually name of cosmos-packages module: 'staking', 'bank', etc.)
    pub path: String,

    /// **key** is a key you want to read from the storage
    pub key: Binary,
}
<span class="boring">}</span></code></pre></pre>
<p><code>RegisterInterchainQuery</code> variant can be applied for both <em>TX</em>- and <em>KV</em>-based queries.
Given that this library is meant for dealing with <em>KV</em>-based queries exclusively,
<code>transactions_filter</code> field is irrelevant.</p>
<p>This library constructs the query registration message as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // helper
    let kv_registration_msg = NeutronMsg::register_interchain_query(
        QueryPayload::KV(vec![query_kv_key]),
        "connection-3".to_string(),
        5,
    );
    // which translates to:
    let kv_registration_msg = NeutronMsg::RegisterInterchainQuery {
        query_type: QueryType::KV.into(),
        keys: vec![query_kv_key],
        transactions_filter: String::new(),
        connection_id: "connection-3".to_string(),
        update_period: 5,
    }
<span class="boring">}</span></code></pre></pre>
<p><code>query_kv_key</code> here is obtained by querying the associated Middleware Broker for a given type and query parameters.</p>
<h4 id="query-result-message-types"><a class="header" href="#query-result-message-types">Query Result Message types</a></h4>
<p>After a query is registered and fetched back to Neutron, its results can be queried with the following Neutron query:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum NeutronQuery {
    /// Query a result of registered interchain query on remote chain
    InterchainQueryResult {
        /// **query_id** is an ID registered interchain query
        query_id: u64,
    },
	// other types
}
<span class="boring">}</span></code></pre></pre>
<p>which will return the interchain query result:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct InterchainQueryResult {
    /// **kv_results** is a raw key-value pairs of query result
    pub kv_results: Vec&lt;StorageValue&gt;,

    /// **height** is a height of remote chain
    pub height: u64,

    #[serde(default)]
    /// **revision** is a revision of remote chain
    pub revision: u64,
}
<span class="boring">}</span></code></pre></pre>
<p>where <code>StorageValue</code> is defined as:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Describes value in the Cosmos-SDK KV-storage on remote chain
pub struct StorageValue {
    /// **storage_prefix** is a path to the storage (storage prefix) where you want to read
    /// value by key (usually name of cosmos-packages module: 'staking', 'bank', etc.)
    pub storage_prefix: String,

    /// **key** is a key under which the **value** is stored in the storage on remote chain
    pub key: Binary,

    /// **value** is a value which is stored under the **key** in the storage on remote chain
    pub value: Binary,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="interchain-query-lifecycle"><a class="header" href="#interchain-query-lifecycle">Interchain Query lifecycle</a></h2>
<p>After <code>RegisterInterchainQuery</code> message is submitted, <code>interchainqueries</code> module will deduct
the query registration fee from the caller.</p>
<p>At that point the query is assigned its unique <code>query_id</code> identifier, which is not known in advance.
This identifier is returned to the caller in the reply.</p>
<p>Once the query is registered, the interchain query relayers perform the following steps:</p>
<ol>
<li>fetch the specified value from the target domain</li>
<li>post the query result to <code>interchainqueries</code> module</li>
<li>trigger <code>SudoMsg::KVQueryResult</code> endpoint on the contract that registered the query</li>
</ol>
<p><code>SudoMsg::KVQueryResult</code> does not carry back the actual query result. Instead, it posts back
a <code>query_id</code> of the query which had been performed, announcing that its result is available.</p>
<p>Obtained <code>query_id</code> can then be used to query the <code>interchainqueries</code> module for the <strong>raw</strong>
interchainquery result. One thing to note here is that these raw results are not meant to be
(natively) interpreted by foreign VMs; instead, they will adhere to the encoding schemes of
the origin domain.</p>
<h2 id="library-high-level-flow"><a class="header" href="#library-high-level-flow">Library high-level flow</a></h2>
<p>At its core, this library should enable three key functions:</p>
<ol>
<li>initiating the interchain queries</li>
<li>receiving &amp; postprocessing the query results</li>
<li>reclaiming the escrowed fees by unregistering the queries</li>
</ol>
<p>Considering that Valence Programs operate across different VMs and adhere to their rules,
these functions can be divided into two categories:</p>
<ol>
<li>external operations (Valence &lt;&gt; host VM)</li>
<li>internal operations (Valence &lt;&gt; Valence)</li>
</ol>
<p>From this perspective, query initiation, receival, and termination can be seen as external
operations that adhere to the functionality provided by the <code>interchainqueries</code> module on Neutron.</p>
<p>On the other hand, query result postprocessing involves internal Valence Program operations.
KV-Query query results fetched from remote domains are not readily useful within the Valence
scope because of their encoding formats. Result postprocessing is therefore about adapting
remote domain data types into <a href="libraries/./../middleware/valence_types.html">canonical Valence Protocol data types</a>
that can be reasoned about.</p>
<blockquote>
<p>For most Cosmos SDK based chains, KV-storage values are encoded in protobuf. Interpreting
protobuf from within CosmWasm context is not straightforward and requires explicit conversion
steps. Other domains may store their state in other encoding formats. This library does not
make any assumptions about the different encoding schemes that remote domains may be subject
to - instead, that responsibility is handed over to <a href="libraries/./../middleware/_overview.html">Valence Middleware</a>.</p>
</blockquote>
<p>Final step in result postprocessing is about persisting the canonicalized query results.
Resulting Valence Types are written into a <a href="libraries/./../components/storage_account.html">Storage Account</a>,
making it available for further processing, interpretation, or other types of processing.</p>
<h2 id="library-lifecycle"><a class="header" href="#library-lifecycle">Library Lifecycle</a></h2>
<p>With the baseline functionality in mind, there are a few design decisions
that shape the overall lifecycle of this library.</p>
<h3 id="instantiation-flow"><a class="header" href="#instantiation-flow">Instantiation flow</a></h3>
<p>Neutron Interchain Querier is instantiated with the full configuration needed
to initiate and process the queries that it will be capable of executing.
After instantiation, the library has the full context needed to carry out its
functions.</p>
<p>Library is configured with the following <code>LibraryConfig</code>. Further sections
will focus on each of its fields.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LibraryConfig {
    pub storage_account: LibraryAccountType,
    pub querier_config: QuerierConfig,
    pub query_definitions: BTreeMap&lt;String, QueryDefinition&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h4 id="storage-account-association"><a class="header" href="#storage-account-association">Storage Account association</a></h4>
<p>Like other libraries, Neutron IC querier has a notion of its associated account.</p>
<p>Associated Storage account will authorize libraries like Neutron IC Querier
to persist canonical Valence types under its storage.</p>
<p>Unlike most other libraries, IC querier does not differentiate between input and
output accounts. There is just an account, and it is the only account that this
library will be authorized to post its results into.</p>
<p>Storage account association follows the same logic of approving/revoking
libraries. Its configuration is done via <code>LibraryAccountType</code>, following
the same account pattern as other libraries.</p>
<h4 id="global-configurations-that-apply-to-all-queries"><a class="header" href="#global-configurations-that-apply-to-all-queries">Global configurations that apply to all queries</a></h4>
<p>While this library is capable of carrying out an arbitrary number of distinct
interchain queries, their scope is bound by <code>QuerierConfig</code></p>
<p><code>QuerierConfig</code> describes ICQ parameters that will apply to every query to be
managed by this library. It can be seen as the global configuration parameters,
of which there are two:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct QuerierConfig {
    pub broker_addr: String,
    pub connection_id: String,
}
<span class="boring">}</span></code></pre></pre>
<p><code>connection_id</code> here describes the IBC connection between Neutron and the
target domain. This effectively limits each instance of Neutron IC Querier to
be responsible for querying one particular domain.</p>
<p><code>broker_addr</code> describes the address of the associated middleware broker.
Just as all queries are going to be bound by a particular connection id,
they will also be postprocessed using a single broker instance.</p>
<h4 id="query-configurations"><a class="header" href="#query-configurations">Query configurations</a></h4>
<p>Queries to be carried out by this library are configured with the following
type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct QueryDefinition {
    pub registry_version: Option&lt;String&gt;,
    pub type_url: String,
    pub update_period: Uint64,
    pub params: BTreeMap&lt;String, Binary&gt;,
    pub query_id: Option&lt;u64&gt;,
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>registry_version: Option&lt;String&gt;</code> specifies which version of the type registry
the middleware broker should use. When set to <code>None</code>, the broker uses its latest
available type registry version. Set this field when a specific type registry
version is needed instead of the latest one.</li>
<li><code>type_url: String</code> identifies the query type within the type registry (via broker).
An important thing to note here is that this url may differ from the one used to
identify the target type on its origin domain. This decoupling is done intentionally
in order to allow for flexible type mapping between domains when necessary.</li>
<li><code>update_period: Uint64</code> specifies how often the given query should be performed/updated</li>
<li><code>params: BTreeMap&lt;String, Binary&gt;</code> provides the type registry with the base64
encoded query parameters that are going to be used for <code>KVKey</code> construction</li>
<li><code>query_id: Option&lt;u64&gt;</code> is an internal parameter that gets modified during runtime.
It must be set to <code>None</code> when configuring the library.</li>
</ul>
<p>Every query definition must be associated with a unique string-based identifier (key).
Query definitions are passed to the library config via <code>BTreeMap&lt;String, QueryDefinition&gt;</code>,
which ensures that there is only one <code>QueryDefinition</code> for every key. While these
keys can be anything, they should clearly identify a particular query. Every function
call exposed by this library expects these keys (and only these keys) as their arguments.</p>
<h3 id="execution-flow"><a class="header" href="#execution-flow">Execution flow</a></h3>
<p>With Neutron IC Querier instantiated, the library is ready to start carrying
out the queries.</p>
<h4 id="query-registration"><a class="header" href="#query-registration">Query registration</a></h4>
<p>Configured queries can be registered with the following function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>RegisterKvQuery { target_query: String }
<span class="boring">}</span></code></pre></pre>
<p>Query registration flow consists of the following steps:</p>
<ol>
<li>querying the <code>interchainqueries</code> module for the currently set query
registration fee and asserting that the function caller covered all
expected fees</li>
<li>querying the middleware broker to obtain the <code>KVKey</code> value to be used
in ICQ registration</li>
<li>constructing and firing the ICQ registration message</li>
</ol>
<p>Each configured query can be started with this function call.</p>
<h4 id="query-result-processing"><a class="header" href="#query-result-processing">Query result processing</a></h4>
<p>Interchain Query results are delivered to the <code>interchainqueries</code> module
in an asynchronous manner. To ensure that query results are available to
Valence Programs as fresh as possible, this library leverages <code>sudo</code> callbacks
that are triggered after ICQ relayers post back the results for a query
registered by this library.</p>
<p>This entry point is configured as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn sudo(deps: ExecuteDeps, _env: Env, msg: SudoMsg) -&gt; StdResult&lt;Response&lt;NeutronMsg&gt;&gt; {
    match msg {
        // this is triggered by the ICQ relayer delivering the query result
        SudoMsg::KVQueryResult { query_id } =&gt; handle_sudo_kv_query_result(deps, query_id),
        _ =&gt; Ok(Response::default()),
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This function call triggers a set of actions that will process the raw query
result into a canonical Valence Type before storing it into the associated
Storage account:</p>
<ol>
<li>query the <code>interchainqueries</code> module to obtain the raw query result
associated with the given <code>query_id</code></li>
<li>query the broker to deserialize the proto-encoded result into a Rust type</li>
<li>query the broker to canonicalize the native rust type into <code>ValenceType</code></li>
<li>post the resulting canonical type to the associated storage account</li>
</ol>
<p>After these actions, the associated storage account will hold the adapted query
result in its storage on the same block as the result was brought into Neutron.</p>
<h4 id="query-deregistration-1"><a class="header" href="#query-deregistration-1">Query deregistration</a></h4>
<p>Actively registered queries can be removed from the active query set with the
following function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>DeregisterKvQuery { target_query: String }
<span class="boring">}</span></code></pre></pre>
<p>This function will perform two actions.</p>
<p>First it will query the <code>interchainqueries</code> module on Neutron for the <code>target_query</code>.
This is done in order to find the deposit fee that was escrowed upon query
registration.</p>
<p>Next, the library will submit the query removal request to the <code>interchainqueries</code>
module. If this request is successful, the deposit fee tokens will be transferred
to the sender that initiated this function.</p>
<h2 id="library-in-valence-programs"><a class="header" href="#library-in-valence-programs">Library in Valence Programs</a></h2>
<p>Neutron IC Querier does not behave as a standard library in that it does result in
any fungible outcome. Instead, it produces a data object in the form of Valence Type.</p>
<p>While that result could be posted directly to the state of this library,
instead, it is posted to an associated output account meant for storing data.
Just as some other libraries have a notion of input accounts that grant them
the permission of executing some logic, Neutron IC Querier has a notion of an
associated account which grants the querier a permission to writing some data
into its storage slots.</p>
<p>For example, consider a situation where this library had queried the balance of
some remote account, parsed the response into a Valence Balance type, and wrote
that resulting object into its associated storage account. That same associated
account may be the input account of some other library, which will attempt to
perform its function based on the content written to its input account. This may
involve something along the lines of: <code>if balance &gt; 0, do x; otherwise, do y;</code>.</p>
<p>With that, the IC Querier flow in a Valence Program may look like this:</p>
<pre class="mermaid">---
title: Neutron IC Querier in Valence Programs
---
graph LR
    A[neutron IC querier] --&gt;|post Valence type| B(storage account)
    C[other library] --&gt;|interpret Valence type| B
</pre>
<blockquote>
<p>Valence Middleware is being actively developed. More elaborate examples
of this library will be added here in the future.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="middleware"><a class="header" href="#middleware">Middleware</a></h1>
<p>This section contains a description of the Valence Protocol middleware design.</p>
<p><strong>Valence Protocol Middleware components</strong>:</p>
<ul>
<li><a href="middleware/./broker.html">Middleware Broker</a></li>
<li><a href="middleware/./type_registry.html">Middleware Type Registry</a></li>
<li><a href="middleware/./valence_types.html">Valence Types</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="middleware-broker"><a class="header" href="#middleware-broker">Middleware Broker</a></h1>
<p>Middleware broker acts as an app-level integration gateway in Valence Programs.
<em>Integration</em> here is used rather ambiguously on purpose - brokers should remain
agnostic to the primitives being integrated into Valence Protocol. These primitives
may involve but not be limited to:</p>
<ul>
<li>data types</li>
<li>functions</li>
<li>encoding schemes</li>
<li>any other distributed system building blocks that may be implemented differently</li>
</ul>
<h3 id="problem-statement"><a class="header" href="#problem-statement">Problem statement</a></h3>
<p>Valence Programs can be configured to span over multiple domains and last for an
indefinite duration of time.</p>
<p>Domains integrated into Valence Protocol are sovereign and evolve on their own.</p>
<p>Middleware brokers provide the means to live with these differences by enabling
various primitive conversions to be as seamless as possible. Seamless here primarily
refers to causing <strong>no downtime</strong> to bring a given primitive up-to-date, and
making the process of doing so as <strong>easy as possible</strong> for the developers.</p>
<p>To visualize a rather complex instance of this problem, consider the following
situation. A Valence Program is initialized to continuously query a particular
type from a remote domain, modify some of its values, and send the altered object
back to the remote domain for further actions.
At some point during the runtime, remote domain performs an upgrade which extends
the given type with additional fields. The Valence Program is unaware of this
upgrade and continues with its order of operations. However, the type in question
from the perspective of the Valence Program had drifted and is no longer
representative of its origin domain.</p>
<p>Among other things, Middleware brokers should enable such programs to gracefully
recover into a synchronized state that can continue operating in a correct manner.</p>
<h2 id="broker-lifecycle"><a class="header" href="#broker-lifecycle">Broker Lifecycle</a></h2>
<p>Brokers are singleton components that are instantiated before the program start
time.</p>
<p>Valence Programs refer to their brokers of choice by their respective addresses.</p>
<p>This means that the same broker instance for a particular domain could be used
across many Valence Programs.</p>
<p>Brokers maintain their set of <a href="middleware/./type_registry.html"><em>type registries</em></a> and index
them by <code>semver</code>. New type registries can be added to the broker during runtime.
While programs have the freedom to select a particular version of a type registry
to be used for a given request, by default, the most up to date type registry is used.</p>
<p>Two aforementioned properties reduce the amount of work needed to upkeep the integrations
across active Valence Programs: updating one broker with the latest version of a
given domain will immediately become available for all Valence Programs using it.</p>
<h2 id="api"><a class="header" href="#api">API</a></h2>
<p>Broker interface is agnostic to the type registries it indexes. A single query is
exposed:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct QueryMsg {
    pub registry_version: Option&lt;String&gt;,
    pub query: RegistryQueryMsg,
}
<span class="boring">}</span></code></pre></pre>
<p>This query message should only change in situations where it may become limiting.</p>
<p>After receiving the query request, broker will relay the contained <code>RegistryQueryMsg</code>
to the correct type registry, and return the result to the caller.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="middleware-type-registry"><a class="header" href="#middleware-type-registry">Middleware Type Registry</a></h1>
<p>Middleware type registries are static components that define how primitives
external to the Valence Protocol are adapted to be used within Valence programs.</p>
<p>While type registries can be used independently, they are typically meant to be
registered into and used via <a href="middleware/./broker.html"><em>brokers</em></a> to ensure versioning is
kept up to date.</p>
<h2 id="type-registry-lifecycle"><a class="header" href="#type-registry-lifecycle">Type Registry lifecycle</a></h2>
<p>Type Registries are static contracts that define their primitives during compile time.</p>
<p>Once a registry is deployed, it is expected to remain unchanged.
If a type change is needed, a new registry should be compiled, deployed,
and registered into the broker to offer the missing or updated functionality.</p>
<h2 id="api-1"><a class="header" href="#api-1">API</a></h2>
<p>All type registry instances must implement the same interface defined in middleware-utils.</p>
<p>Type registries function in a read-only manner - all of their functionality is exposed
with the <code>RegistryQueryMsg</code>. Currently, the following primitive conversions are enabled:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum RegistryQueryMsg {
    /// serialize a message to binary
    #[returns(NativeTypeWrapper)]
    FromCanonical { obj: ValenceType },
    /// deserialize a message from binary/bytes
    #[returns(Binary)]
    ToCanonical { type_url: String, binary: Binary },

    /// get the kvkey used for registering an interchain query
    #[returns(KVKey)]
    KVKey {
        type_id: String,
        params: BTreeMap&lt;String, Binary&gt;,
    },

    #[returns(NativeTypeWrapper)]
    ReconstructProto {
        type_id: String,
        icq_result: InterchainQueryResult,
    },
}
<span class="boring">}</span></code></pre></pre>
<p><code>RegistryQueryMsg</code> can be seen as the <em>superset</em> of all primitives that Valence Programs
can expect. No particular type being integrated into the system is required to implement
all available functionality, although that is possible.</p>
<p>To maintain a unified interface across all type registries, they have to adhere to the same
API as all other type registries. This means that if a particular type is enabled in a type
registry and only provides the means to perform native &lt;-&gt; canonical conversion, attempting
to call <code>ReconstructProto</code> on that type will return an error stating that reconstructing
protobuf for this type is not enabled.</p>
<h2 id="module-organization"><a class="header" href="#module-organization">Module organization</a></h2>
<p>Primitives defined in type registries should be outlined in a domain-driven manner.
Types, encodings, and any other functionality should be grouped by their domain and
are expected to be self-contained, not leaking into other primitives.</p>
<p>For instance, an osmosis type registry is expected to contain all registry instances related to
the Osmosis domain. Different registry instances should be versioned by <code>semver</code>, following that
of the external domain of which the primitives are being integrated.</p>
<h2 id="enabled-primitives"><a class="header" href="#enabled-primitives">Enabled primitives</a></h2>
<p>Currently, the following type registry primitives are enabled:</p>
<ul>
<li>Neutron Interchain Query types:
<ul>
<li>reconstructing native types from protobuf</li>
<li>obtaining the <code>KVKey</code> used to initiate the query for a given type</li>
</ul>
</li>
<li>Valence Canonical Types:
<ul>
<li>reconstructing native types from Valence Types</li>
<li>mapping native types into Valence Types</li>
</ul>
</li>
</ul>
<h2 id="example-integration"><a class="header" href="#example-integration">Example integration</a></h2>
<p>For an example, consider the integration of the osmosis gamm pool.</p>
<h3 id="neutron-interchain-query-integration"><a class="header" href="#neutron-interchain-query-integration">Neutron Interchain Query integration</a></h3>
<p>Neutron Interchain Query integration for a given type is achieved by implementing
the <code>IcqIntegration</code> trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait IcqIntegration {
    fn get_kv_key(params: BTreeMap&lt;String, Binary&gt;) -&gt; Result&lt;KVKey, MiddlewareError&gt;;
    fn decode_and_reconstruct(
        query_id: String,
        icq_result: InterchainQueryResult,
    ) -&gt; Result&lt;Binary, MiddlewareError&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h4 id="get_kv_key"><a class="header" href="#get_kv_key"><code>get_kv_key</code></a></h4>
<p>Implementing the <code>get_kv_key</code> will provide the means to obtain the <code>KVKey</code> needed
to register the interchain query. For osmosis gamm pool, the implementation may look
like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>impl IcqIntegration for OsmosisXykPool {
    fn get_kv_key(params: BTreeMap&lt;String, Binary&gt;) -&gt; Result&lt;KVKey, MiddlewareError&gt; {
        let pool_prefix_key: u8 = 0x02;

        let id: u64 = try_unpack_domain_specific_value("pool_id", &amp;params)?;

        let mut pool_access_key = vec![pool_prefix_key];
        pool_access_key.extend_from_slice(&amp;id.to_be_bytes());

        Ok(KVKey {
            path: STORAGE_PREFIX.to_string(),
            key: Binary::new(pool_access_key),
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="decode_and_reconstruct"><a class="header" href="#decode_and_reconstruct"><code>decode_and_reconstruct</code></a></h4>
<p>Other part of enabling interchain queries is the implementation of <code>decode_and_reconstruct</code>.
This method will be called upon ICQ relayer posting the query result back to the <code>interchainqueries</code>
module on Neutron. For osmosis gamm pool, the implementation may look
like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl IcqIntegration for OsmosisXykPool {
    fn decode_and_reconstruct(
        _query_id: String,
        icq_result: InterchainQueryResult,
    ) -&gt; Result&lt;Binary, MiddlewareError&gt; {
        let any_msg: Any = Any::decode(icq_result.kv_results[0].value.as_slice())
            .map_err(|e| MiddlewareError::DecodeError(e.to_string()))?;

        let osmo_pool: Pool = any_msg
            .try_into()
            .map_err(|_| StdError::generic_err("failed to parse into pool"))?;

        to_json_binary(&amp;osmo_pool)
            .map_err(StdError::from)
            .map_err(MiddlewareError::Std)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="valence-type-integration"><a class="header" href="#valence-type-integration">Valence Type integration</a></h3>
<p>Valence Type integration for a given type is achieved by implementing
the <code>ValenceTypeAdapter</code> trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait ValenceTypeAdapter {
    type External;

    fn try_to_canonical(&amp;self) -&gt; Result&lt;ValenceType, MiddlewareError&gt;;
    fn try_from_canonical(canonical: ValenceType) -&gt; Result&lt;Self::External, MiddlewareError&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>Ideally, Valence Types should represent the minimal amount of information needed and
avoid any domain-specific logic or identifiers. In practice, this is a hard problem:
native types that are mapped into Valence types may need to be sent back to the remote
domains. For that reason, we cannot afford leaking any domain-specific fields and instead
store them in the Valence Type itself for later reconstruction.</p>
<p>In case of <code>ValenceXykPool</code>, this storage is kept in its <code>domain_specific_fields</code> field.
Any fields that are logically common across all possible integrations into this type
should be kept in their dedicated fields. In the case of constant product pools, such
fields are the assets in the pool, and the shares issued that represent those assets:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cw_serde]
pub struct ValenceXykPool {
    /// assets in the pool
    pub assets: Vec&lt;Coin&gt;,

    /// total amount of shares issued
    pub total_shares: String,

    /// any other fields that are unique to the external pool type
    /// being represented by this struct
    pub domain_specific_fields: BTreeMap&lt;String, Binary&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h4 id="try_to_canonical"><a class="header" href="#try_to_canonical"><code>try_to_canonical</code></a></h4>
<p>Implementing the <code>try_from_canonical</code> will provide the means of mapping a native remote type
into the canonical Valence Type to be used in Valence Protocol.
For osmosis gamm pool, the implementation may look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ValenceTypeAdapter for OsmosisXykPool {
    type External = Pool;

    fn try_to_canonical(&amp;self) -&gt; Result&lt;ValenceType, MiddlewareError&gt; {
        // pack all the domain-specific fields
        let mut domain_specific_fields = BTreeMap::from([
            (ADDRESS_KEY.to_string(), to_json_binary(&amp;self.0.address)?),
            (ID_KEY.to_string(), to_json_binary(&amp;self.0.id)?),
            (
                FUTURE_POOL_GOVERNOR_KEY.to_string(),
                to_json_binary(&amp;self.0.future_pool_governor)?,
            ),
            (
                TOTAL_WEIGHT_KEY.to_string(),
                to_json_binary(&amp;self.0.total_weight)?,
            ),
            (
                POOL_PARAMS_KEY.to_string(),
                to_json_binary(&amp;self.0.pool_params)?,
            ),
        ]);

        if let Some(shares) = &amp;self.0.total_shares {
            domain_specific_fields
                .insert(SHARES_DENOM_KEY.to_string(), to_json_binary(&amp;shares.denom)?);
        }

        for asset in &amp;self.0.pool_assets {
            if let Some(token) = &amp;asset.token {
                domain_specific_fields.insert(
                    format!("pool_asset_{}_weight", token.denom),
                    to_json_binary(&amp;asset.weight)?,
                );
            }
        }

        let mut assets = vec![];
        for asset in &amp;self.0.pool_assets {
            if let Some(t) = &amp;asset.token {
                assets.push(coin(u128::from_str(&amp;t.amount)?, t.denom.to_string()));
            }
        }

        let total_shares = self
            .0
            .total_shares
            .clone()
            .map(|shares| shares.amount)
            .unwrap_or_default();

        Ok(ValenceType::XykPool(ValenceXykPool {
            assets,
            total_shares,
            domain_specific_fields,
        }))
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="try_from_canonical"><a class="header" href="#try_from_canonical"><code>try_from_canonical</code></a></h4>
<p>Other part of enabling Valence Type integration is the implementation of <code>try_from_canonical</code>.
This method will be called when converting from canonical back to the native version of the types.
For osmosis gamm pool, the implementation may look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ValenceTypeAdapter for OsmosisXykPool {
    type External = Pool;

    fn try_from_canonical(canonical: ValenceType) -&gt; Result&lt;Self::External, MiddlewareError&gt; {
        let inner = match canonical {
            ValenceType::XykPool(pool) =&gt; pool,
            _ =&gt; {
                return Err(MiddlewareError::CanonicalConversionError(
                    "canonical inner type mismatch".to_string(),
                ))
            }
        };
        // unpack domain specific fields from inner type
        let address: String = inner.get_domain_specific_field(ADDRESS_KEY)?;
        let id: u64 = inner.get_domain_specific_field(ID_KEY)?;
        let future_pool_governor: String =
            inner.get_domain_specific_field(FUTURE_POOL_GOVERNOR_KEY)?;
        let pool_params: Option&lt;PoolParams&gt; = inner.get_domain_specific_field(POOL_PARAMS_KEY)?;
        let shares_denom: String = inner.get_domain_specific_field(SHARES_DENOM_KEY)?;
        let total_weight: String = inner.get_domain_specific_field(TOTAL_WEIGHT_KEY)?;

        // unpack the pool assets
        let mut pool_assets = vec![];
        for asset in &amp;inner.assets {
            let pool_asset = PoolAsset {
                token: Some(Coin {
                    denom: asset.denom.to_string(),
                    amount: asset.amount.into(),
                }),
                weight: inner
                    .get_domain_specific_field(&amp;format!("pool_asset_{}_weight", asset.denom))?,
            };
            pool_assets.push(pool_asset);
        }

        Ok(Pool {
            address,
            id,
            pool_params,
            future_pool_governor,
            total_shares: Some(Coin {
                denom: shares_denom,
                amount: inner.total_shares,
            }),
            pool_assets,
            total_weight,
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="valence-types-1"><a class="header" href="#valence-types-1">Valence Types</a></h1>
<p><strong>Valence Types</strong> are a set of canonical type wrappers to be used inside
Valence Programs.</p>
<p>Primary operational domain of Valence Protocol will need to consume, interpret,
and otherwise manipulate data from external domains. For that reason, canonical
representations of such types are defined in order to form an abstraction layer
that all Valence Programs can reason about.</p>
<h2 id="canonical-type-integrations"><a class="header" href="#canonical-type-integrations">Canonical Type integrations</a></h2>
<p>Canonical types to be used in Valence Programs are enabled by the Valence Protocol.</p>
<p>For instance, consider Astroport XYK and Osmosis GAMM pool types. These are two
distinct data types that represent the same underlying concept - a constant product
pool.</p>
<p>These types can be unified in the Valence Protocol context by being mapped to and
from the following Valence Type definition:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ValenceXykPool {
    /// assets in the pool
    pub assets: Vec&lt;Coin&gt;,

    /// total amount of shares issued
    pub total_shares: String,

    /// any other fields that are unique to the external pool type
    /// being represented by this struct
    pub domain_specific_fields: BTreeMap&lt;String, Binary&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>For a remote type to be integrated into the Valence Protocol means that there are
available adapters that map between the canonical and original type definitions.</p>
<p>These adapters can be implemented by following the design outlined by <a href="middleware/./type_registry.html"><em>type registries</em></a>.</p>
<h2 id="active-valence-types"><a class="header" href="#active-valence-types">Active Valence Types</a></h2>
<p>Active Valence types provide the interface for integrating remote domain representations
of the same underlying concepts. Remote types can be integrated into Valence Protocol
if and only if there is an enabled Valence Type representing the same underlying primitive.</p>
<p>Currently enabled Valence types are:</p>
<ul>
<li>XYK pool</li>
<li>Balance response</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<p>Here are some examples of Valence Programs that you can use to get started.</p>
<ul>
<li><a href="examples/./token_swap.html">Token Swap</a></li>
<li><a href="examples/./crosschain_vaults.html">Crosschain Vaults</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="token-swap-program"><a class="header" href="#token-swap-program">Token Swap Program</a></h1>
<p>This example demonstrates a simple <em>token swap</em> program whereby two parties wish to exchange specific amounts of (different) tokens they each hold, at a rate they have previously agreed on. The program ensures the swap happens atomically, so neither party can withdraw without completing the trade.</p>
<pre class="mermaid">---
title: Valence token swap program
---
graph LR
	InA((Party A Deposit))
	InB((Party B Deposit))
	OutA((Party A Withdraw))
	OutB((Party B Withdraw))
	SSA[Splitter A]
	SSB[Splitter B]
	subgraph Neutron
	InA --&gt; SSA --&gt; OutB
	InB --&gt; SSB --&gt; OutA
	end
</pre>
<p>The program is composed of the following components:</p>
<ul>
<li><strong>Party A Deposit account</strong>: a <a href="examples/../components/accounts.html">Valence account</a> which Party A will deposit their tokens into, to be exchanged with Party B's tokens.</li>
<li><strong>Splitter A</strong>: an instance of the <a href="examples/../libraries/splitter.html">Splitter library</a> that will transfer Party A's tokens from its input account (i.e. the <strong>Party A Deposit account</strong>) to its output account (i.e. the <strong>Party B Withdraw account</strong>) upon execution of its <code>split</code> function.</li>
<li><strong>Party B Withdraw account</strong>: the account from which Party B can withdraw Party A's tokens after the swap has successfully completed. Note: this can be a <a href="examples/../components/accounts.html">Valence account</a>, but it could also be a regular chain account, or a smart contract.</li>
<li><strong>Party B Deposit account</strong>:  a <a href="examples/../components/accounts.html">Valence account</a> which Party B will deposit their funds into, to be exchanged with Party A's funds.</li>
<li><strong>Splitter B</strong>: an instance of the <a href="examples/../libraries/splitter.html">Splitter library</a> that will transfer Party B's tokens from its input account (i.e. the <strong>Party B Deposit account</strong>) to its output account (i.e. the <strong>Party A Withdraw account</strong>) upon execution of its <code>split</code> function.</li>
<li><strong>Party A Withdraw account</strong>: the account from which Party A can withdraw Party B's tokens after the swap has successfully completed. Note: this can be a <a href="examples/../components/accounts.html">Valence account</a>, but it could also be a regular chain account, or a smart contract.</li>
</ul>
<p>The way the program is able to fulfil the requirement for an <em>atomic exchange of tokens</em> between the two parties is done by implementing an <strong>atomic subroutine</strong> composed of two function calls:</p>
<ol>
<li><strong>Splitter A</strong>'s <code>split</code> function</li>
<li><strong>Splitter B</strong>'s <code>split</code> function</li>
</ol>
<p>The Authorizations component will ensure that either both succeed, or none is executed, thereby ensuring that <strong>funds remain safe at all time</strong> (either remaining in the respective deposit accounts, or transferred to the respective withdraw accounts).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crosschain-vaults"><a class="header" href="#crosschain-vaults">Crosschain Vaults</a></h1>
<p><strong>Note:</strong> <em>This example is still in the design phase and includes new or experimental features of Valence Programs that may not be supported in the current production release.</em></p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>You can use Valence Programs to create crosschain vaults. Users interact with a vault on one chain while the tokens are held on another chain where yield is generated.</p>
<p>Note: In our initial implementation we use Neutron for co-processing and Hyperlane for general message passing between the co-processor and the target domain. Deployment of Valence programs as zk RISC-V co-processors with permissionless message passing will be available in the coming months.</p>
<p>In this example, we have made the following assumptions:</p>
<ul>
<li>Users can deposit tokens into a standard ERC-4626 vault on Ethereum.</li>
<li>ERC-20 shares are issued to users on Ethereum.</li>
<li>If a user wishes to redeem their tokens, they can issue a withdrawal request which will burn the user's shares when tokens are redeemed.</li>
<li>The redemption rate that tells us how many tokens can be redeemed per shares is given by: \( R = \frac{TotalAssets}{TotalIssuedShares} = \frac{TotalInVault + TotalInTransit + TotalInPostion}{TotalIssuedShares}\)</li>
<li>A permissioned actor called the "Strategist" is authorized to transport funds from Ethereum to Neutron where they are locked in some DeFi protocol. And vice-versa, the Strategist can withdraw from the position so the funds are redeemable on Ethereum. The redemption rate must be adjusted by the Strategist accordingly.</li>
</ul>
<pre class="mermaid">---
title: Crosschain Vaults Overview
---
graph LR
	User
	EV(Ethereum Vault)
	NP(Neutron Position)

	User -- Tokens --&gt; EV
	EV -- Shares --&gt; User
	EV -- Strategist Transport --&gt; NP
	NP -- Strategist Transport --&gt; EV
</pre>
<p>While we have chosen Ethereum and Neutron as examples here, one could similarly construct such vaults between any two chains as long as they are supported by Valence Programs.</p>
<h2 id="implementing-crosschain-vaults-as-a-valence-program"><a class="header" href="#implementing-crosschain-vaults-as-a-valence-program">Implementing Crosschain Vaults as a Valence Program</a></h2>
<p>Recall that Valence Programs are comprised of Libraries and Accounts. Libraries are a collection of Functions that perform token oprations on the Accounts. Since there are two chains here, Libraries and Accounts will exist on both chains.</p>
<p>Since gas is cheaper on Neutron than on Ethereum, computationally expensive operations, such as constraining the Strategist actions will be done on Neutron. Authorized messages will then be executed by each chain's Processor. Hyperlane is used to pass messages from the Authorization contract on Neutron to the Processor on Ethereum.</p>
<pre class="mermaid">---
title: Program Control
---
graph BT
	Strategist
	subgraph Ethereum
		EP(Processor)
		EHM(Hyperlane Mailbox)
		EL(Ethereum Valence Libraries)
		EVA(Valence Accounts)
	end
	subgraph Neutron
		A(Authorizations)
		NP(Processor)
		EE(EVM Encoder)
		NHM(Hyperlane Mailbox)
		NL(Neutron Valence Libraries)
		NVA(Valence Accounts)
	end

	Strategist --&gt; A
	A --&gt; EE --&gt; NHM --&gt; Relayer --&gt; EHM --&gt; EP --&gt; EL --&gt; EVA
	A --&gt; NP --&gt; NL--&gt; NVA
</pre>
<h3 id="libraries-and-accounts-needed"><a class="header" href="#libraries-and-accounts-needed">Libraries and Accounts needed</a></h3>
<p>On Ethereum, we'll need Accounts for:</p>
<ul>
<li><strong>Deposit</strong>: To hold user deposited tokens. Tokens from this pool can be then transported to Neutron.</li>
<li><strong>Withdraw</strong>: To hold tokens received from Neutron. Tokens from this pool can then be redeemed for shares.</li>
</ul>
<p>On Neutron, we'll need Accounts for:</p>
<ul>
<li><strong>Deposit</strong>: To hold tokens bridged from Ethereum. Tokens from this pool can be used to enter into the position on Neutron.</li>
<li><strong>Position</strong>: Will hold the vouchers or shares associated with the position on Neutron.</li>
<li><strong>Withdraw</strong>: To hold the tokens that are withdrawn from the position. Tokens from this pool can be bridged back to Ethereum.</li>
</ul>
<p>We'll need the following Libraries on Ethereum:</p>
<ul>
<li><strong>Bridge Transfer</strong>: To transfer funds from the Ethereum Deposit Account to the Neutron Deposit Account.</li>
<li><strong>Forwarder</strong>: To transfer funds between the Deposit and Withdraw Accounts on Ethereum. Two instances of the Library will be required.</li>
</ul>
<p>We'll need the following Libraries on Neutron:</p>
<ul>
<li><strong>Position Depositor</strong>: To take funds in the Deposit and create a position with them. The position is held by the Position account.</li>
<li><strong>Position Withdrawer</strong>: To redeem a position for underlying funds that are then transferred to the Withdraw Account on Neutron.</li>
<li><strong>Bridge Transfer</strong>: To transfer funds from the Neutron Withdraw Account to the Ethereum Withdraw Account.</li>
</ul>
<p>Note that the Accounts mentioned here the standard <a href="examples/../components/accounts.html">Valence Accounts</a>. Th Bridge Transfer library will depend on the token being transferred, but will offer similar functionality to the <a href="examples/../libraries/generic-ibc-transfer.html">IBC Transfer</a> library. The Position Depositor and Withdrawer will depend on the type of position, but can be similar to the <a href="examples/../libraries/astroport-lper.html">Liqudity Provider</a> and <a href="examples/../libraries/astroport-withdrawer.html">Liquidity Withdrawer</a>.</p>
<h3 id="vault-contract"><a class="header" href="#vault-contract">Vault Contract</a></h3>
<p>The Vault contract is a special contract on Ethereum that has an ERC-4626 interface.</p>
<h4 id="user-methods-to-deposit-funds"><a class="header" href="#user-methods-to-deposit-funds">User methods to deposit funds</a></h4>
<ul>
<li><strong>Deposit</strong>: Deposit funds into the registered Deposit Account. Receive shares back based on the redemption rate.
<pre><code>Deposit {
	amount: Uint256,
	receiver: String
}
</code></pre>
</li>
<li><strong>Mint</strong>: Mint shares from the vault. Expects the user to provide sufficient tokens to cover the cost of the shares based on the current redemption rate.
<pre><code>Mint {
	shares: Uint256,
	receiver: String
}
</code></pre>
</li>
</ul>
<pre class="mermaid">---
title: User Deposit and Share Mint Flow
---
graph LR
	User
	subgraph Ethereum
		direction LR
		EV(Vault)
		ED((Deposit))
	end
	
	User -- 1/ Deposit Tokens --&gt; EV
	EV -- 2/ Send Shares --&gt; User
	EV -- 3/ Send Tokens --&gt; ED
</pre>
<h4 id="user-methods-to-withdraw-funds"><a class="header" href="#user-methods-to-withdraw-funds">User methods to withdraw funds</a></h4>
<ul>
<li><strong>Redeem</strong>: Send shares to redeem assets. This creates a <code>WithdrawRecord</code> in a queue. This record is processed at the next <code>Epoch</code>
<pre><code>Redeem {
	shares: Uint256,
	receiver: String,
	max_loss_bps: u64
}
</code></pre>
</li>
<li><strong>Withdraw</strong>: Withdraw amount of assets. It expects the user to have sufficient shares. This creates a <code>WithdrawRecord</code> in a queue. This record is processed at the next <code>Epoch</code>.
<pre><code>Withdraw {
	amount: Uint256,
	receiver: String,
	max_loss_bps: u64
}
</code></pre>
</li>
</ul>
<p>Withdraws are subject to a lockup period after the user has initiated a redemption. During this time the redemption rate may change. Users can specify an acceptable loss in case the the redemption rate decreases using the <code>max_loss_bps</code> parameter.</p>
<p>After the <code>Epoch</code> has completed, a user may complete the withdrawal by executing the following message:</p>
<ul>
<li><strong>CompleteWithdraw</strong>: Pop the <code>WithdrawRecord</code>. Pull funds from the Withdraw Account and send to user. Burn the user's deposited shares.</li>
</ul>
<pre class="mermaid">---
title: User Withdraw Flow
---
graph RL
	subgraph Ethereum
		direction RL
		EV(Vault)
		EW((Withdraw))
	end
	EW -- 2/ Send Tokens --&gt; EV -- 3/ Send Tokens --&gt; User
	User -- 1/ Deposit Shares --&gt; EV

</pre>
<h3 id="strategist-methods-to-manage-the-vault"><a class="header" href="#strategist-methods-to-manage-the-vault">Strategist methods to manage the vault</a></h3>
<p>The vault validates that the Processor is making calls to it. On Neutron, the Authorization contract limits the calls to be made only by a trusted Strategist. The Authorization contract can further constrain when or how Strategist actions can be taken.</p>
<ul>
<li><strong>Update</strong>: The strategist can update the current redemption rate.
<pre><code>Update {
  rate: Uint256
}
</code></pre>
</li>
<li><strong>Pause and Unpause</strong>: The strategist can pause and unpause vault operations.
<pre><code>Pause {}
</code></pre>
</li>
</ul>
<h3 id="program-subroutines"><a class="header" href="#program-subroutines">Program subroutines</a></h3>
<p>The program authorizes the Strategist to update the redemption rate and transport funds between various Accounts.</p>
<h4 id="allowing-the-strategist-to-transport-funds"><a class="header" href="#allowing-the-strategist-to-transport-funds">Allowing the Strategist to transport funds</a></h4>
<pre class="mermaid">---
title: From Ethereum Deposit Account to Neutron Position Account
---
graph LR
	subgraph Ethereum
		ED((Deposit))
		ET(Bridge Transfer)
	end
	subgraph Neutron
		NPH((Position Holder))
		NPD(Position Depositor)
		ND((Deposit))
	end

	ED --&gt; ET --&gt; ND --&gt; NPD --&gt; NPH
</pre>
<pre class="mermaid">---
title: From Neutron Position Account to Ethereum Withdraw Account
---
graph RL
	subgraph Ethereum
		EW((Withdraw))
	end
	subgraph Neutron
		NPH((Position Holder))
		NW((Widthdraw))
		NT(Bridge Transfer)
		NPW(Position Withdrawer)
	end

	NPH --&gt; NPW --&gt; NW --&gt; NT --&gt; EW

</pre>
<pre class="mermaid">---
title: Between Ethereum Deposit and Ethereum Withdraw Accounts
---
graph
	subgraph Ethereum
		ED((Deposit))
		EW((Withdraw))
		FDW(Forwarder)
	end
	ED --&gt; FDW --&gt; EW
</pre>
<h2 id="design-notes"><a class="header" href="#design-notes">Design notes</a></h2>
<p>This is a simplified design to demonstrate how a cross-chain vault can be implemented with Valence Programs. Production deployments will need to consider additional factors not covered here including:</p>
<ul>
<li>Fees for gas, bridging, and for entering/exiting the position on Neutron. It is recommend that the vault impose withdraw fee and platform for users.</li>
<li>How to constrain Strategist behavior to ensure they set redemption rates correctly.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-your-programs"><a class="header" href="#testing-your-programs">Testing your programs</a></h1>
<p>Our testing infrastructure is built on several tools that work together to provide a comprehensive local testing environment:</p>
<h3 id="core-testing-framework"><a class="header" href="#core-testing-framework">Core Testing Framework</a></h3>
<p>We use <a href="https://github.com/strangelove-ventures/interchaintest/tree/main/local-interchain">local-interchain</a>, a component of the <a href="https://github.com/strangelove-ventures/interchaintest">interchaintest</a> developer toolkit. This allows you to deploy and run chains in a local environment, providing a controlled testing space for your blockchain applications.</p>
<h3 id="localic-utils"><a class="header" href="#localic-utils">Localic Utils</a></h3>
<p>To make these tools more accessible in Rust, we've developed <a href="https://github.com/timewave-computer/localic-utils">localic-utils</a>. This Rust library provides convenient interfaces to interact with the local-interchain testing framework.</p>
<h3 id="program-manager"><a class="header" href="#program-manager">Program Manager</a></h3>
<p>We provide a tool called <code>Program Manager</code> that helps you manage your programs. We've created all the abstractions and helper functions to create your programs more efficiently together with local-interchain.</p>
<p>The Program Manager use is optional, it abstracts a lot of functionality and allows creating programs in much less code. But if you want to have more fine-grained control over your programs, we provide helper functions to create and interact with your programs directly without it. In this section, we'll show you two different examples on how to test your programs, one using the Program Manager and the other without it. There are also many more examples each of them for different use cases. They are all in the <code>examples</code> folder of <a href="https://github.com/timewave-computer/valence-protocol/tree/main/local-interchaintest">our local-interchaintest folder</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="initial-testing-set-up"><a class="header" href="#initial-testing-set-up">Initial Testing Set Up</a></h1>
<p>For testing your programs, no matter if you want to use the manager or not, there is a common set up that needs to be done. This set up is necessary to initialize the testing context with all the required information of the local-interchain environment.</p>
<h2 id="1-setting-the-testcontext-using-the-testcontextbuilder"><a class="header" href="#1-setting-the-testcontext-using-the-testcontextbuilder">1. Setting the TestContext using the TestContextBuilder</a></h2>
<p>The <code>TestContext</code> is the interchain environment in which your program will run. Let's say you want to configure the Neutron chain and Osmosis chain, you may set it up as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut test_ctx = TestContextBuilder::default()
        .with_unwrap_raw_logs(true)
        .with_api_url(LOCAL_IC_API_URL)
        .with_artifacts_dir(VALENCE_ARTIFACTS_PATH)
        .with_chain(ConfigChainBuilder::default_neutron().build()?)
        .with_chain(ConfigChainBuilder::default_osmosis().build()?)
        .with_log_file_path(LOGS_FILE_PATH)
        .with_transfer_channels(NEUTRON_CHAIN_NAME, OSMOSIS_CHAIN_NAME)
        .build()?;
<span class="boring">}</span></code></pre></pre>
<p>This will instantiate a <code>TestContext</code> with two chains, Neutron and Osmosis, that are connected via IBC by providing the <code>transfer_channels</code> parameter. The <code>api_url</code> is the URL of the local-interchain API, and the <code>artifacts_dir</code> is the path where the compiled programs are stored. The <code>log_file_path</code> is the path where the logs will be stored. The most important part here are the chains, which are created using the <code>ConfigChainBuilder</code> with the default configurations for Neutron and Osmosis and the transfer channels between them. We provide builders for most chains but you can also create your own configurations.</p>
<h2 id="2-custom-chain-specific-setup"><a class="header" href="#2-custom-chain-specific-setup">2. Custom chain-specific setup</a></h2>
<p>Some chains require additional setup to interact with others. For example, if you are going to use a liquid staking chain like Persistence, you need to register and activate the host zone to allow liquid staking of its native token. We provide helper functions that do this for you, here's an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    info!("Registering host zone...");
    register_host_zone(
        test_ctx
            .get_request_builder()
            .get_request_builder(PERSISTENCE_CHAIN_NAME),
        NEUTRON_CHAIN_ID,
        &amp;connection_id,
        &amp;channel_id,
        &amp;native_denom,
        DEFAULT_KEY,
    )?;


    info!("Activating host zone...");
    activate_host_zone(NEUTRON_CHAIN_ID)?;
<span class="boring">}</span></code></pre></pre>
<p>Other examples of this would be deploying Astroport contracts, creating Osmosis pools... We provider helper functions for pretty much all of them and we have examples for all of them in the <code>examples</code> folder.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-without-program-manager"><a class="header" href="#example-without-program-manager">Example without Program Manager</a></h1>
<p>This example demonstrates how to test your program without the Program Manager after your initial testing set up has been completed as described in the <a href="testing/./setup.html">Initial Testing Set Up</a> section.</p>
<blockquote>
<p><strong>Use-case</strong>: In this particular example, we will show you how to create a program that liquid stakes NTRN tokens on a Persistence chain directly from a base account without the need of using libraries. Note that this example is just for demonstrating purposes. In a real-world scenario, you would not liquid stake NTRN as it is not a staking token. We also are not using a liquid staking library for this example, although one could be creating for this purpose.</p>
</blockquote>
<p>The full code for this example can be found in the <a href="https://github.com/timewave-computer/valence-protocol/blob/main/local-interchaintest/examples/persistence_ls.rs">Persistence Liquid Staking example</a>.</p>
<ol>
<li>Set up the authorization contract and processor on the <code>Main Domain</code> (Neutron).</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let now = SystemTime::now();
    let salt = hex::encode(
        now.duration_since(SystemTime::UNIX_EPOCH)?
            .as_secs()
            .to_string(),
    );

    let (authorization_contract_address, _) =
        set_up_authorization_and_processor(&amp;mut test_ctx, salt.clone())?;
<span class="boring">}</span></code></pre></pre>
<p>This code sets up the authorization contract and processor on Neutron. We use a time based salt to ensure that each test run the generated contract addresses are different. The <code>set_up_authorization_and_processor</code> function is a helper function instantiates both the processor and authorization contracts on Neutron and provides the contract addresses to interact with both. As you can see, we are not using the processor on Neutron here, but we are still setting it up.</p>
<ol start="2">
<li>Set up an external domain and create a channel to start relaying messages.</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let processor_on_persistence = set_up_external_domain_with_polytone(
        &amp;mut test_ctx,
        PERSISTENCE_CHAIN_NAME,
        PERSISTENCE_CHAIN_ID,
        PERSISTENCE_CHAIN_ADMIN_ADDR,
        LOCAL_CODE_ID_CACHE_PATH_PERSISTENCE,
        "neutron-persistence",
        salt,
        &amp;authorization_contract_address,
    )?;
<span class="boring">}</span></code></pre></pre>
<p>This function does the following:</p>
<ul>
<li>Instantiates all the Polytone contracts on both the main domain and the new external domain. The information of the external domain is provided in the function arguments.</li>
<li>Creates a channel between the Polytone contracts that the relayer will use to relay messages between the authorization contract and the processor.</li>
<li>Instantiates the Processor contract on the external domain with the correct Polytone information and the authorization contract address.</li>
<li>Adds the external domain to authorization contract with the Polytone information and the processor address on the external domain.</li>
</ul>
<p>After this is done, we can start creating authorizations for that external domain and when we send messages to the authorization contract, the relayer will relay the messages to the processor on the external domain and return the callbacks.</p>
<ol start="3">
<li>Create one or more base accounts on a domain.</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let base_accounts = create_base_accounts(
        &amp;mut test_ctx,
        DEFAULT_KEY,
        PERSISTENCE_CHAIN_NAME,
        base_account_code_id,
        PERSISTENCE_CHAIN_ADMIN_ADDR.to_string(),
        vec![processor_on_persistence.clone()],
        1,
        None,
    );
    let persistence_base_account = base_accounts.first().unwrap();
<span class="boring">}</span></code></pre></pre>
<p>This function creates a base account on the external domain and grants permission to the processor address to execute messages on its behalf. If we were using a library instead, we would be granting permission to the library contract instead of the processor address in the array provided.</p>
<ol start="4">
<li>Create the authorization</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let authorizations = vec![AuthorizationBuilder::new()
        .with_label("execute")
        .with_subroutine(
            AtomicSubroutineBuilder::new()
                .with_function(
                    AtomicFunctionBuilder::new()
                        .with_domain(Domain::External(PERSISTENCE_CHAIN_NAME.to_string()))
                        .with_contract_address(LibraryAccountType::Addr(
                            persistence_base_account.clone(),
                        ))
                        .with_message_details(MessageDetails {
                            message_type: MessageType::CosmwasmExecuteMsg,
                            message: Message {
                                name: "execute_msg".to_string(),
                                params_restrictions: None,
                            },
                        })
                        .build(),
                )
                .build(),
        )
        .build()];

    info!("Creating execute authorization...");
    let create_authorization = valence_authorization_utils::msg::ExecuteMsg::PermissionedAction(
        valence_authorization_utils::msg::PermissionedMsg::CreateAuthorizations { authorizations },
    );

    contract_execute(
        test_ctx
            .get_request_builder()
            .get_request_builder(NEUTRON_CHAIN_NAME),
        &amp;authorization_contract_address,
        DEFAULT_KEY,
        &amp;serde_json::to_string(&amp;create_authorization).unwrap(),
        GAS_FLAGS,
    )
    .unwrap();
    std::thread::sleep(std::time::Duration::from_secs(3));
    info!("Execute authorization created!");
<span class="boring">}</span></code></pre></pre>
<p>In this code snippet, we are creating an authorization to execute a message on the persistence base account. For this particular example, since we are going to execute a <code>CosmosMsg::Stargate</code> directly on the account passing the protobuf message, we are not going to set up any param restrictions. If we were using a library, we could potentially set up restrictions for the json message that the library would expect.</p>
<ol start="5">
<li>Send message to the authorization contract</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>info!("Send the messages to the authorization contract...");

    let msg_liquid_stake = MsgLiquidStake {
        amount: Some(Coin {
            denom: neutron_on_persistence.clone(),
            amount: amount_to_liquid_stake.to_string(),
        }),
        delegator_address: persistence_base_account.clone(),
    };
    #[allow(deprecated)]
    let liquid_staking_message = CosmosMsg::Stargate {
        type_url: msg_liquid_stake.to_any().type_url,
        value: Binary::from(msg_liquid_stake.to_proto_bytes()),
    };

    let binary = Binary::from(
        serde_json::to_vec(&amp;valence_account_utils::msg::ExecuteMsg::ExecuteMsg {
            msgs: vec![liquid_staking_message],
        })
        .unwrap(),
    );
    let message = ProcessorMessage::CosmwasmExecuteMsg { msg: binary };
    let send_msg = valence_authorization_utils::msg::ExecuteMsg::PermissionlessAction(
        valence_authorization_utils::msg::PermissionlessMsg::SendMsgs {
            label: "execute".to_string(),
            messages: vec![message],
            ttl: None,
        },
    );

    contract_execute(
        test_ctx
            .get_request_builder()
            .get_request_builder(NEUTRON_CHAIN_NAME),
        &amp;authorization_contract_address,
        DEFAULT_KEY,
        &amp;serde_json::to_string(&amp;send_msg).unwrap(),
        GAS_FLAGS,
    )
    .unwrap();
    std::thread::sleep(std::time::Duration::from_secs(3));
<span class="boring">}</span></code></pre></pre>
<p>In this code snippet, we are sending a message to the authorization contract to execute the liquid staking message on the base account on Persistence. Note that we are using the same label that we used in the authorization creation. This is important because the authorization contract will check if the label matches the one in the authorization. If it does not match, the execution will fail. The authorization contract will send the message to the corresponding Polytone contract that will send it via IBC to the processor on the external domain.</p>
<ol start="6">
<li>Tick the processor</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    tick_processor(
        &amp;mut test_ctx,
        PERSISTENCE_CHAIN_NAME,
        DEFAULT_KEY,
        &amp;processor_on_persistence,
    );
    std::thread::sleep(std::time::Duration::from_secs(3));
<span class="boring">}</span></code></pre></pre>
<p>The message must now be sitting on the processor on Persistence, therefore we need to tick the processor to trigger the execution. This will execute the message and send a callback with the result to the authorization contract, which completes the full testing cycle.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-with-program-manager"><a class="header" href="#example-with-program-manager">Example with Program Manager</a></h1>
<p>This example demonstrates how to test your program using the Program Manager after your initial testing set up has been completed as described in the <a href="testing/./setup.html">Initial Testing Set Up</a> section.</p>
<blockquote>
<p><strong>Use-case:</strong> This example outlines the steps needed to create a program that provides and withdraws liquidity from an Osmosis Concentrated Liquidity pool using two library contracts: a CL Liquidity Provider and a CL Liquidity Withdrawer.</p>
</blockquote>
<h2 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h2>
<p>Before proceeding, ensure you have:</p>
<ul>
<li>A basic understanding of Osmosis, Neutron, CosmWasm, and Valence</li>
<li>Completed the initial testing setup as described in the setup section</li>
<li>Installed all necessary dependencies and have a working development environment</li>
</ul>
<h2 id="solution-overview"><a class="header" href="#solution-overview">Solution Overview</a></h2>
<p>Full working code for this example can be found in the <a href="https://github.com/timewave-computer/valence-protocol/blob/main/local-interchaintest/examples/osmo_cl.rs">Osmosis Concentrated Liquidity example</a>.</p>
<p>Our solution includes the following:</p>
<ul>
<li>We create three accounts on Osmosis
<ul>
<li>CL Input holds tokens ready to join the pool</li>
<li>CL Output holds the position of the pool</li>
<li>Final Output holds tokens after they've been withdrawn from the pool</li>
</ul>
</li>
<li>We instantiate the Concentrated Liquidity Provider and Concentrated Liquidity Withdrawer libraries on Osmosis
<ul>
<li>The Liquidity Provider library will draw tokens from the CL Input account and use them to enter the pool</li>
<li>The Liquidity Withdrawer library will exit the pool from the position held in the CL Output account and deposit redeemed tokens to the Final Output account</li>
</ul>
</li>
<li>We add two permissionless authorizations on Neutron:
<ul>
<li>Provide Liquidity: When executed, it'll call the the provide liquidity function</li>
<li>Withdraw Liquidity: When executed, it'll call the withdraw liquidity function</li>
</ul>
</li>
</ul>
<p>The following is a visual representation of the system we are building:</p>
<pre class="mermaid">graph TD;
    subgraph Osmosis
        A1((CL Input))
        A2((CL Output))
        A3((Final Output))
        L1[Liquidity Provider]
        L2[Liquidity Withdrawer]
        EP[Processor]
    end

    subgraph Neutron
        A[Authorizations]
        MP[Processor]
    end

    A1 --&gt; L1 --&gt; A2
    A2 --&gt; L2 --&gt; A3

    User --Execute Msg--&gt; A --Enqueue Batch --&gt; EP
    EP --&gt; L1
    EP --&gt; L2
</pre>
<h2 id="code-walkthrough"><a class="header" href="#code-walkthrough">Code walkthrough</a></h2>
<p>Before we begin, we set up the <code>TestContext</code> as explained in the previous <a href="testing/setup.html">setup section</a>. Then we can move on to steps pertinent to testing this example.</p>
<h3 id="1-setting-up-the-program"><a class="header" href="#1-setting-up-the-program">1. Setting up the program</a></h3>
<h4 id="11-set-up-the-concentrated-liquidity-pool-on-osmosis"><a class="header" href="#11-set-up-the-concentrated-liquidity-pool-on-osmosis">1.1 Set up the Concentrated Liquidity pool on Osmosis</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ntrn_on_osmo_denom = test_ctx
    .get_ibc_denom()
    .base_denom(NEUTRON_CHAIN_DENOM.to_owned())
    .src(NEUTRON_CHAIN_NAME)
    .dest(OSMOSIS_CHAIN_NAME)
    .get();

let pool_id = setup_cl_pool(&amp;mut test_ctx, &amp;ntrn_on_osmo_denom, OSMOSIS_CHAIN_DENOM)?;
<span class="boring">}</span></code></pre></pre>
<p>This sets up a CL pool on Osmosis using NTRN and OSMO as the trading pair.
Because NTRN on Osmosis will be transferred over IBC, a helper function is used to get the correct denom on Osmosis.</p>
<h4 id="12-set-up-the-program-config-builder-and-prepare-the-relevant-accounts"><a class="header" href="#12-set-up-the-program-config-builder-and-prepare-the-relevant-accounts">1.2 Set up the Program config builder and prepare the relevant accounts</a></h4>
<p>The Program Manager uses a builder pattern to construct the program configuration. We set up the three accounts that will be used in the liquidity provision and withdrawal flow.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut builder = ProgramConfigBuilder::new(NEUTRON_CHAIN_ADMIN_ADDR.to_string());
let osmo_domain = Domain::CosmosCosmwasm(OSMOSIS_CHAIN_NAME.to_string());
let ntrn_domain = Domain::CosmosCosmwasm(NEUTRON_CHAIN_NAME.to_string());

// Create account information for LP input, LP output and final (LW) output accounts
let cl_input_acc_info = AccountInfo::new("cl_input".to_string(), &amp;osmo_domain, AccountType::default());
let cl_output_acc_info = AccountInfo::new("cl_output".to_string(), &amp;osmo_domain, AccountType::default());
let final_output_acc_info = AccountInfo::new("final_output".to_string(), &amp;osmo_domain, AccountType::default());

// Add accounts to builder
let cl_input_acc = builder.add_account(cl_input_acc_info);
let cl_output_acc = builder.add_account(cl_output_acc_info);
let final_output_acc = builder.add_account(final_output_acc_info);
<span class="boring">}</span></code></pre></pre>
<h4 id="13-configure-the-libraries"><a class="header" href="#13-configure-the-libraries">1.3 Configure the libraries</a></h4>
<p>Next we configure the libraries for providing and withdrawing liquidity. Each library is configured with input and output accounts and specific parameters for their operation.</p>
<p>Note how <code>cl_output_acc</code> serves a different purpose for each of those libraries:</p>
<ul>
<li>for liquidity provider library it is the output account</li>
<li>for liquidity withdrawer library it is the input account</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Configure Liquidity Provider library
let cl_lper_config = LibraryConfig::ValenceOsmosisClLper({
    input_addr: cl_input_acc.clone(),
    output_addr: cl_output_acc.clone(),
    lp_config: LiquidityProviderConfig {
        pool_id: pool_id.into(),
        pool_asset_1: ntrn_on_osmo_denom.to_string(),
        pool_asset_2: OSMOSIS_CHAIN_DENOM.to_string(),
        global_tick_range: TickRange {
            lower_tick: Int64::from(-1_000_000),
            upper_tick: Int64::from(1_000_000),
        },
    },
});

// Configure Liquidity Withdrawer library
let cl_lwer_config = LibraryConfig::ValenceOsmosisClWithdrawer({
    input_addr: cl_output_acc.clone(),
    output_addr: final_output_acc.clone(),
    pool_id: pool_id.into(),
});

// Add libraries to builder
let cl_lper_library = builder.add_library(LibraryInfo::new(
    "test_cl_lper".to_string(),
    &amp;osmo_domain,
    cl_lper_config,
));

let cl_lwer_library = builder.add_library(LibraryInfo::new(
    "test_cl_lwer".to_string(),
    &amp;osmo_domain,
    cl_lwer_config,
));
<span class="boring">}</span></code></pre></pre>
<h4 id="14-create-links-between-accounts-and-libraries"><a class="header" href="#14-create-links-between-accounts-and-libraries">1.4 Create links between accounts and libraries</a></h4>
<p>Input links (first array in the <code>add_link()</code> call) are meant to enable libraries permission to execute on the specified accounts. Output links specify where the fungible results of a given function execution should be routed to.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Link input account -&gt; liquidity provider -&gt; output account
builder.add_link(&amp;cl_lper_library, vec![&amp;cl_input_acc], vec![&amp;cl_output_acc]);
// Link output account -&gt; liquidity withdrawer -&gt; final output account
builder.add_link(&amp;cl_lwer_library, vec![&amp;cl_output_acc], vec![&amp;final_output_acc]);
<span class="boring">}</span></code></pre></pre>
<h4 id="15-create-authorizations"><a class="header" href="#15-create-authorizations">1.5 Create authorizations</a></h4>
<p>Next we create authorizations for both providing and withdrawing liquidity. Each authorization contains a subroutine that specifies which function to call on which library. By default, calling these subroutines will be permissionless, however using the <code>AuthorizationBuilder</code> we can constrain the authorizations as necessary.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>builder.add_authorization(
    AuthorizationBuilder::new()
        .with_label("provide_liquidity")
        .with_subroutine(
            AtomicSubroutineBuilder::new()
                .with_function(cl_lper_function)
                .build(),
        )
        .build(),
);

builder.add_authorization(
    AuthorizationBuilder::new()
        .with_label("withdraw_liquidity")
        .with_subroutine(
            AtomicSubroutineBuilder::new()
                .with_function(cl_lwer_function)
                .build(),
        )
        .build(),
);
<span class="boring">}</span></code></pre></pre>
<h4 id="16-set-up-the-polytone-connections"><a class="header" href="#16-set-up-the-polytone-connections">1.6 Set up the Polytone connections</a></h4>
<p>In order for cross-domain Programs to be able to communicate between
different domains, we instantiate the Polytone contracts and save the
configuration in our Program Manager.</p>
<p><code>setup_polytone</code> sets up the connection between two domains and therefore expects the following parameters:</p>
<ul>
<li>source and destination chain names</li>
<li>source and destination chain ids</li>
<li>source and destination chain native denoms</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// prior to initializing the manager, we do the middleware plumbing
setup_polytone(
    &amp;mut test_ctx,
    NEUTRON_CHAIN_NAME,
    OSMOSIS_CHAIN_NAME,
    NEUTRON_CHAIN_ID,
    OSMOSIS_CHAIN_ID,
    NEUTRON_CHAIN_DENOM,
    OSMOSIS_CHAIN_DENOM,
)?;
<span class="boring">}</span></code></pre></pre>
<h4 id="17-initialize-the-program"><a class="header" href="#17-initialize-the-program">1.7 Initialize the program</a></h4>
<p>Calling <code>builder.build()</code> here acts as a snapshot of the existing builder state.</p>
<p>That state is then passed on to the <code>use_manager_init()</code> call, which consumes it and builds the final program configuration before initializing it.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut program_config = builder.build();
use_manager_init(&amp;mut program_config)?;
<span class="boring">}</span></code></pre></pre>
<p>Congratulations! The program is now initialized across the two chains!</p>
<h3 id="2-executing-the-program"><a class="header" href="#2-executing-the-program">2. Executing the Program</a></h3>
<p>After the initialization, we are ready to start processing  messages. For a message to be executed, it first needs to be enqueued to the processor.</p>
<h4 id="21-providing-liquidity"><a class="header" href="#21-providing-liquidity">2.1 Providing Liquidity</a></h4>
<p>If there are tokens available in the CL Input account, we are ready to provide liquidity. To enqueue provide liquidity message:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// build the processor message for providing liquidity
let lp_message = ProcessorMessage::CosmwasmExecuteMsg {
    msg: Binary::from(serde_json::to_vec(
        &amp;valence_library_utils::msg::ExecuteMsg::&lt;_, ()&gt;::ProcessFunction(
            valence_osmosis_cl_lper::msg::FunctionMsgs::ProvideLiquidityDefault {
                bucket_amount: Uint64::new(10),
            },
        ),
    )?),
};

// wrap the processor message in an authorization module call
let provide_liquidity_msg = valence_authorization_utils::msg::ExecuteMsg::PermissionlessAction(
    valence_authorization_utils::msg::PermissionlessMsg::SendMsgs {
        label: "provide_liquidity".to_string(),
        messages: vec![lp_message],
        ttl: None,
    },
);

contract_execute(
    test_ctx
        .get_request_builder()
        .get_request_builder(NEUTRON_CHAIN_NAME),
    &amp;authorization_contract_address,
    DEFAULT_KEY,
    &amp;serde_json::to_string(&amp;provide_liquidity_msg)?,
    GAS_FLAGS,
)?;
<span class="boring">}</span></code></pre></pre>
<p>Now anyone can tick the processor to execute the message. After receiving a <code>tick</code>, the processor will execute the message at the head of the queue and send a callback to the authorization contract with the result.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>contract_execute(
    test_ctx
        .get_request_builder()
        .get_request_builder(OSMOSIS_CHAIN_NAME),
    &amp;osmo_processor_contract_address,
    DEFAULT_KEY,
    &amp;serde_json::to_string(
        &amp;valence_processor_utils::msg::ExecuteMsg::PermissionlessAction(
            valence_processor_utils::msg::PermissionlessMsg::Tick {},
        ),
    )?,
    &amp;format!(
        "--gas=auto --gas-adjustment=3.0 --fees {}{}",
        5_000_000, OSMOSIS_CHAIN_DENOM
    ),
)?;
<span class="boring">}</span></code></pre></pre>
<h4 id="22-withdraw-liquidity"><a class="header" href="#22-withdraw-liquidity">2.2 Withdraw Liquidity</a></h4>
<p>To enqueue withdraw liquidity message:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// build the processor message for withdrawing liquidity
let lw_message = ProcessorMessage::CosmwasmExecuteMsg {
    msg: Binary::from(serde_json::to_vec(
        &amp;valence_library_utils::msg::ExecuteMsg::&lt;_, ()&gt;::ProcessFunction(
            valence_osmosis_cl_withdrawer::msg::FunctionMsgs::WithdrawLiquidity {
                position_id: output_acc_cl_position.position_id.into(),
                liquidity_amount: Some(liquidity_amount),
            },
        ),
    )?),
};

// wrap the processor message in an authorization module call
let withdraw_liquidity_msg = valence_authorization_utils::msg::ExecuteMsg::PermissionlessAction(
    valence_authorization_utils::msg::PermissionlessMsg::SendMsgs {
        label: "withdraw_liquidity".to_string(),
        messages: vec![lw_message],
        ttl: None,
    },
);

contract_execute(
    test_ctx
        .get_request_builder()
        .get_request_builder(NEUTRON_CHAIN_NAME),
    &amp;authorization_contract_address,
    DEFAULT_KEY,
    &amp;serde_json::to_string(&amp;withdraw_liquidity_msg)?,
    GAS_FLAGS,
)?;
<span class="boring">}</span></code></pre></pre>
<p>The above enqueues the message to withdraw liquidity. The processor will execute it next time it is ticked.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>contract_execute(
    test_ctx
        .get_request_builder()
        .get_request_builder(OSMOSIS_CHAIN_NAME),
    &amp;osmo_processor_contract_address,
    DEFAULT_KEY,
    &amp;serde_json::to_string(
        &amp;valence_processor_utils::msg::ExecuteMsg::PermissionlessAction(
            valence_processor_utils::msg::PermissionlessMsg::Tick {},
        ),
    )?,
    &amp;format!(
        "--gas=auto --gas-adjustment=3.0 --fees {}{}",
        5_000_000, OSMOSIS_CHAIN_DENOM
    ),
)?;
<span class="boring">}</span></code></pre></pre>
<p>This concludes the walkthrough. You have now initialized the program and used it to provide and withdraw liquidity on Osmosis from Neutron!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="security"><a class="header" href="#security">Security</a></h1>
<p>Valence Programs have been independently audited. Please find audit reports <a href="https://github.com/timewave-computer/valence-protocol/tree/main/audits/">here</a>.</p>
<p>If you believe you've found a security-related issue with Valence Programs, please disclose responsibly by contacting the Timewave team at <a href="mailto:security@timewave.computer">security@timewave.computer</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
