<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Valence Protocol Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "ayu";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Valence Protocol Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/timewave-computer/valence-protocol" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<blockquote>
<p>üöß Valence Protocol architecture and developer documentation is still evolving rapidly. Portions of the toolchain have stabilized to build cross-chain vaults, and extending vaults with multi-party agreements. Send us a message on <a href="https://x.com/valencezone">X</a> if you'd like to get started!</p>
</blockquote>
<p><strong>Valence</strong> is a unified development environment that enables building <em>trust-minimized cross-chain DeFi applications</em>, called <strong>Valence Programs</strong>.</p>
<p>Valence Programs are:</p>
<ul>
<li><strong>Easy to understand</strong> and <strong>quick to deploy</strong>: a program can be set up with a configuration file and no code.</li>
<li><strong>Extensible</strong>: if we don't yet support a DeFi integration out of the box, new integrations can be written in a matter of hours!</li>
</ul>
<blockquote>
<p><strong>Example Use Case</strong>:</p>
<p>A DeFi protocol wants to bridge tokens to another chain and deposit them into a vault. After a certain date, it wants to unwind the position. While the position is active, it may also want to delegate the right to change vault parameters to a designated committee so long as the parameters are within a certain range.
Without Valence Programs, the protocol would have two choices:</p>
<ol>
<li>Give the tokens to a <strong>multisig</strong> to execute actions on the protocol's behalf</li>
<li>Write <strong>custom smart contracts</strong> and deploy them across multiple chains to handle the cross-chain token operations.</li>
</ol>
<p><strong>Valence Programs</strong> offer the DeFi protocol a third choice: rapidly configure and deploy a secure solution that meets its needs without trusting a multisig or writing complex smart contracts.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="valence-programs"><a class="header" href="#valence-programs">Valence Programs</a></h1>
<p>There are two ways to execute Valence Programs.</p>
<ol>
<li>
<p><strong>On-chain Execution</strong>:
Valence currently supports CosmWasm and EVM. SVM support coming soon. The rest of this section provides a high-level breakdown of the components that comprise a Valence Program using on-chain coprocessors.</p>
<ul>
<li><a href="components/./domains.html">Domains</a></li>
<li><a href="components/../accounts/_overview.html">Accounts</a></li>
<li><a href="components/./libraries_and_functions.html">Libraries and Functions</a></li>
<li><a href="components/./programs_and_authorizations.html">Programs and Authorizations</a></li>
<li><a href="components/./middleware.html">Middleware</a></li>
</ul>
</li>
<li>
<p><strong>Off-chain Execution via ZK Coprocessor</strong>:
Early specifications for the <a href="components/./../zk/_overview.html">Valence ZK System</a>. We aim to move as much computation off-chain as possible since off-chain computation is a more scalable approach to building a cross-chain execution environment.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="domains"><a class="header" href="#domains">Domains</a></h1>
<p>A <strong>domain</strong> is an environment in which the components that form a program (more on these later) can be instantiated (deployed).</p>
<p><strong>Domains</strong> are defined by <strong>three properties</strong>:</p>
<ol>
<li>The <strong>chain</strong>: the blockchain's name <em>e.g. Neutron, Osmosis, Ethereum mainnet</em>.</li>
<li>The <strong>execution environment</strong>: the environment under which programs (typically smart contracts) can be executed on that particular chain <em>e.g. CosmWasm, EVM, SVM</em>.</li>
<li>The type of <strong>bridge</strong> used from the <strong>main domain</strong> to other domains <em>e.g. Polytone over IBC, Hyperlane</em>.</li>
</ol>
<p>Within a particular ecosystem of blockchains (e.g. Cosmos), the Valence Protocol usually defines one specific domain as the <strong>main domain</strong>, on which some supporting infrastructure components are deployed. Think of it as the <em>home base</em> supporting the execution and operations of Valence Programs. This will be further clarified in the <a href="components/../authorizations_processors/_overview.html">Authorizations &amp; Processors</a> section.</p>
<p>Below is a simplified representation of a <em>program transferring tokens</em> from a given <strong>input account</strong> on the <strong>Neutron domain</strong>, a CosmWasm-enabled smart contract platform secured by the Cosmos Hub, to a specified <strong>output account</strong> on the <strong>Osmosis domain</strong>, a well-known DeFi platform in the Cosmos ecosystem.</p>
<pre class="mermaid">---
title: Valence Cross-Domain Program
---
graph LR
  IA((Input
      Account))
  OA((Output
		  Account))
  subgraph Neutron
  IA
  end
  subgraph Osmosis
  IA -- Transfer tokens --&gt; OA
  end
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="valence-accounts"><a class="header" href="#valence-accounts">Valence Accounts</a></h1>
<p>Valence Programs usually perform operations on tokens accross multiple domains. To ensure that the funds remain safe throughout a program's execution, Valence Programs rely on a primitive called Valence Accounts. Additionally, Valence Accounts can also be used to store data that is not directly related to tokens.</p>
<p>In this section we will introduce all the different types of Valence Accounts and explain their purpose.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="base-accounts"><a class="header" href="#base-accounts">Base Accounts</a></h1>
<p>A <strong>Valence Base Account</strong> is an escrow contract that can hold balances for various supported token types (e.g., in Cosmos <code>ics-20</code> or <code>cw-20</code>) and ensure that only a restricted set of operations can be performed on the held tokens.
<strong>Valence Base Accounts</strong> are created (i.e., instantiated) on a specific <strong>domain</strong> and bound to a specific <strong>Valence Program</strong>. <strong>Valence Programs</strong> will typically use multiple accounts during the program's lifecycle for different purposes. <strong>Valence Base Accounts</strong> are generic by nature; their use in forming a program is entirely up to the program's creator.</p>
<p>Using a simple <em>token swap program</em> as an example: the program receives an amount of <strong>Token A</strong> in an <strong>input account</strong> and will <strong>swap</strong> these <strong>Token A</strong> for <strong>Token B</strong> using a <strong>DEX</strong> on the <strong>same domain</strong> (e.g., Neutron). After the swap operation, the received amount of <strong>Token B</strong> will be temporarily held in a <strong>transfer account</strong> before being transfered to a final <strong>output account</strong> on another domain (e.g., Osmosis).</p>
<p>For this, the program will create the following accounts:</p>
<ul>
<li>A <strong>Valence Base Account</strong> is created on the <strong>Neutron domain</strong> to act as the <strong>Input account</strong>.</li>
<li>A <strong>Valence Base Account</strong> is created on the <strong>Neutron domain</strong> to act as the <strong>Transfer account</strong>.</li>
<li>A <strong>Valence Base Account</strong> is created on the <strong>Osmosis domain</strong> to act as the <strong>Output account</strong>.</li>
</ul>
<pre class="mermaid">---
title: Valence Token Swap Program
---
graph LR
  IA((Input
    Account))
  TA((Transfer
    Account))
  OA((Output
	Account))
  DEX
  subgraph Neutron
  IA -- Swap Token A --&gt; DEX
  DEX -- Token B --&gt; TA
  end
  subgraph Osmosis
  TA -- Transfer token B --&gt; OA
  end
</pre>
<p>Note: this is a simplified representation.</p>
<p><strong>Valence Base Accounts</strong> do not perform any operation by themselves on the held funds, the operations are performed by <strong><a href="accounts/../components/libraries_and_functions.html">Valence Libraries</a></strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="valence-storage-account"><a class="header" href="#valence-storage-account">Valence Storage Account</a></h1>
<p>The Valence Storage Account is a type of Valence account that can store Valence Type data
objects.</p>
<p>Like all other accounts, Storage Accounts follow the same pattern of approving and revoking
authorized libraries from being able to post Valence Types into a given account.</p>
<p>While regular Valence (Base) accounts are meant for storage of fungible tokens, Valence Storage
accounts are meant for storage of non-fungible objects.</p>
<h2 id="api"><a class="header" href="#api">API</a></h2>
<h3 id="execute-methods"><a class="header" href="#execute-methods">Execute Methods</a></h3>
<p>Storage Account is a simple component exposing the following execute methods:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum ExecuteMsg {
    // Add library to approved list (only admin)
    ApproveLibrary { library: String },
    // Remove library from approved list (only admin)
    RemoveLibrary { library: String },
    // stores the given `ValenceType` variant under storage key `key`
    StoreValenceType { key: String, variant: ValenceType },
}
<span class="boring">}</span></code></pre></pre>
<p>Library approval and removal follow the same implementation as that of the fund accounts.</p>
<p><code>StoreValenceType</code> is the key method of this contract. It takes in a <em>key</em> of type <code>String</code>, and its
associated value of type <code>ValenceType</code>.</p>
<p>If <code>StoreValenceType</code> is called by the owner or an approved library, it will persist the <em>key-value</em>
mapping in its state. Storage here works in an overriding manner, meaning that posting data
for a key that already exists will override its previous value and act as an update method.</p>
<h3 id="query-methods"><a class="header" href="#query-methods">Query Methods</a></h3>
<p>Once a given type has been posted into the storage account using <code>StoreValenceType</code> call, it becomes available
for querying.</p>
<p>Storage account exposes the following <code>QueryMsg</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum QueryMsg {
    // Get list of approved libraries
    #[returns(Vec&lt;String&gt;)]
    ListApprovedLibraries {},
    // Get Valence type variant from storage
    #[returns(ValenceType)]
    QueryValenceType { key: String },
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interchain-accounts"><a class="header" href="#interchain-accounts">Interchain Accounts</a></h1>
<p>A <strong>Valence Interchain Account</strong> is a contract that creates an <a href="https://ibc.cosmos.network/v8/apps/interchain-accounts/overview/">ICS-27 Interchain Account</a> over IBC on a different domain. It will then send protobuf messages to the ICA over IBC for them to be executed remotely. It's specifically designed to interact with other chains in the Cosmos ecosystem, and more in particular with chains that don't support smart contracts.
To use this account contract, the remote chain must have ICA host functionality enabled and should have an allowlist that includes the messages being executed.</p>
<p><strong>Valence Interchain Accounts</strong> are created (i.e., instantiated) on <strong>Neutron</strong> and bound to a specific <strong>Valence Program</strong>. <strong>Valence Programs</strong> will typically use these accounts to trigger remote execution of messages on other domains.</p>
<p>As a simple example, consider a <strong>Valence Program</strong> that needs to bridge USDC from Cosmos to Ethereum via the <a href="https://www.noble.xyz/">Noble Chain</a>. Noble doesn't support CosmWasm or any other execution environment, so the <strong>Valence Program</strong> will use a <strong>Valence Interchain Account</strong> to first, create an ICA on Noble, and then send a message to the ICA to interact with the corresponding native module on Noble with the funds previously sent to the ICA.</p>
<p>For this, the program will create a <strong>Valence Interchain Account</strong> on the <strong>Neutron domain</strong> to create an ICA on the <strong>Noble domain</strong>:</p>
<pre class="mermaid">---
title: Valence Interchain Account
---
graph LR
    subgraph Neutron
      IA[Interchain Account]
    end
    subgraph Noble
      OA[Cosmos ICA]
    end
    IA -- &quot;MsgDepositForBurn
    protobuf&quot; --&gt; OA
</pre>
<p><strong>Valence Interchain Accounts</strong> do not perform any operation by themselves, the operations are performed by <strong><a href="accounts/../components/libraries_and_functions.html">Valence Libraries</a></strong>.</p>
<h2 id="api-1"><a class="header" href="#api-1">API</a></h2>
<h3 id="instantiation"><a class="header" href="#instantiation">Instantiation</a></h3>
<p><strong>Valence Interchain Accounts</strong> are instantiated with the following message:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct InstantiateMsg {
    pub admin: String, // Initial owner of the contract
    pub approved_libraries: Vec&lt;String&gt;,
    pub remote_domain_information: RemoteDomainInfo, // Remote domain information required to register the ICA and send messages to it
}

pub struct RemoteDomainInfo {
    pub connection_id: String,
    pub ica_timeout_seconds: Uint64, // relative timeout in seconds after which the packet times out
}
<span class="boring">}</span></code></pre></pre>
<p>In this message, the <code>connection_id</code> of the remote domain and the timeout for the ICA messages are specified.</p>
<h3 id="execute-methods-1"><a class="header" href="#execute-methods-1">Execute Methods</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum ExecuteMsg {
    ApproveLibrary { library: String }, // Add library to approved list (only admin)
    RemoveLibrary { library: String },  // Remove library from approved list (only admin)
    ExecuteMsg { msgs: Vec&lt;CosmosMsg&gt; }, // Execute a list of Cosmos messages, useful to retrieve funds that were sent here by the owner for example.
    ExecuteIcaMsg { msgs: Vec&lt;AnyMsg&gt; }, // Execute a protobuf message on the ICA
    RegisterIca {},                      // Register the ICA on the remote chain
}
<span class="boring">}</span></code></pre></pre>
<p>Library approval and removal follow the same implementation as that of the fund accounts.</p>
<p><code>ExecuteMsg</code> works in the same way as for the base account.</p>
<p><code>ExecuteIcaMsg</code> is a list of protobuf messages that will be sent to the ICA on the remote chain. Each message contains
the <code>type_url</code> and the protobuf encoded bytes to be delivered.</p>
<p><code>RegisterIca</code> is a permissionless call that will register the ICA on the remote chain. This call requires the
<strong>Valence Interchain Account</strong> to not have another ICA created and open on the remote chain.</p>
<h3 id="query-methods-1"><a class="header" href="#query-methods-1">Query Methods</a></h3>
<p>Interchain account exposes the following <code>QueryMsg</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum QueryMsg {
    #[returns(Vec&lt;String&gt;)]
    ListApprovedLibraries {}, // Get list of approved libraries
    #[returns(IcaState)]
    IcaState {}, // Get the state of the ICA
    #[returns(RemoteDomainInfo)]
    RemoteDomainInfo {}, // Get the remote domain information
}

pub enum IcaState {
    NotCreated, // Not created yet
    Closed,     // Was created but closed, so creation should be retriggered
    InProgress, // Creation is in progress, waiting for confirmation
    Created(IcaInformation),
}

pub struct IcaInformation {
    pub address: String,
    pub port_id: String,
    pub controller_connection_id: String,
}
<span class="boring">}</span></code></pre></pre>
<p>There are two specific queries for the <strong>Valence Interchain Account</strong>. The first one is <code>IcaState</code> which returns the state of the ICA. The second one is <code>RemoteDomainInfo</code> which returns the remote domain information that was provided during instantiation.
ICAs can only be registered if the <code>IcaState</code> is <code>NotCreated</code> or <code>Closed</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libraries-and-functions"><a class="header" href="#libraries-and-functions">Libraries and Functions</a></h1>
<p><strong>Valence Libraries</strong> contain the business logic that can be applied to the funds held by <strong>Valence Base Accounts</strong>. Most often, this logic is about <em>performing operations on tokens</em>, such as splitting, routing, or providing liquidity on a DEX. A <strong>Valence Base Account</strong> has to first approve (authorize) a <strong>Valence Library</strong> for it to perform operations on that account's balances. <strong>Valence Libraries</strong> expose <strong>Functions</strong> that it supports. <strong>Valence Programs</strong> can be composed of a more or less complex graph of <strong>Valence Base Accounts</strong> and <strong>Valence Libraries</strong> to form a more or less sophisticated cross-chain workflow. During the course of a <strong>Valence Program</strong>'s execution, <strong>Functions</strong> are called by external parties that trigger the library's operations on the linked accounts.</p>
<p>A typical pattern for a <strong>Valence Library</strong> is to have one (or more) <strong>input account(s)</strong> and one (or more) <strong>output account(s)</strong>. While many libraries implement this pattern, it is by no means a requirement.</p>
<p><strong>Valence Libraries</strong> play a critical role in integrating <strong>Valence Programs</strong> with existing decentralized apps and services that can be found in many blockchain ecosystems (e.g., DEXes, liquid staking, etc.).</p>
<p>Now that we know accounts cannot perform any operations by themselves, we need to revisit the <em>token swap program</em> example (mentioned on the <a href="components/../accounts/base_accounts.html">Base Accounts</a> page) and bring <strong>Valence Libraries</strong> into the picture: the program receives an amount of <strong>Token A</strong> in an <strong>input account</strong>, and a <strong>Token Swap</strong> library exposes a <strong>swap</strong> function that, when called, will perform a swap operation of <strong>Token A</strong> held by the <strong>input account</strong> for <strong>Token B</strong> using a <strong>DEX</strong> on the <strong>same domain</strong> (e.g., Neutron), and transfer them to the <strong>transfer account</strong>. A <strong>Token Transfer</strong> library that exposes a <strong>transfer</strong> function will transfer the <strong>Token B</strong> amount (when the function is called) to a final <strong>output account</strong> on another domain (e.g. Osmosis). In this scenario, the <strong>DEX</strong> is an existing service found on the host domain (e.g. <strong>Astroport</strong> on <strong>Neutron</strong>), so it is not part of the <strong>Valence Protocol</strong>.</p>
<p>The program is then composed of the following accounts &amp; libraries:</p>
<ul>
<li>A <strong>Valence Base Account</strong> is created on the <strong>Neutron domain</strong> to act as the <strong>input account</strong>.</li>
<li>A <strong>Valence Base Account</strong> is created on the <strong>Neutron domain</strong> to act as the <strong>transfer account</strong>.</li>
<li>A <strong>Token Swap Valence Library</strong> is created on the <strong>Neutron domain</strong>, <em>authorized</em> by the <strong>input account</strong> (to be able to act on the held Token A balance), and <em>configured</em> with the <strong>input account</strong> and <strong>transfer account</strong> as the respective input and output for the swap operation.</li>
<li>A <strong>Token Transfer Valence Library</strong> is created on the <strong>Neutron domain</strong>, <em>authorized</em> by the <strong>transfer account</strong> (to be able to act on the held Token B balance), and <em>configured</em> with the <strong>transfer account</strong> and <strong>output account</strong> as the respective input and output for the swap operation.</li>
<li>A <strong>Valence Base Account</strong> is created on the <strong>Osmosis domain</strong> to act as the <strong>output account</strong>.</li>
</ul>
<pre class="mermaid">---
title: Valence Token Swap Program
---
graph LR
  FC[[Function call]]
  IA((Input
	Account))
  TA((Transfer
	Account))
  OA((Output
	Account))
  TS((Token
  	Swap Library))
  TT((Token
  	Transfer Library))
  DEX
  subgraph Neutron
  FC -- 1/Swap --&gt; TS
  TS -- Swap Token A --&gt; IA
  IA -- Token A --&gt; DEX
  DEX -- Token B --&gt; TA
  FC -- 2/Transfer --&gt; TT
  TT -- Transfer Token B --&gt; TA
  end
  subgraph Osmosis
  TA -- Token B --&gt; OA
  end
</pre>
<p>This example highlights the crucial role that <strong>Valence Libraries</strong> play for integrating <strong>Valence Programs</strong> with pre-existing decentralized apps and services.</p>
<p>However, one thing remains unclear in this example: how are <strong>Functions</strong> called? This is where <a href="components/./programs_and_authorizations.html">Programs and Authorizations</a> come into the picture.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="programs-and-authorizations"><a class="header" href="#programs-and-authorizations">Programs and Authorizations</a></h1>
<p>A <strong>Valence Program</strong> is an instance of the <strong>Valence Protocol</strong>. It is a particular arrangement and configuration of <a href="components/../accounts/_overview.html">Accounts</a> and <a href="components/./libraries_and_functions.html">libraries</a> across multiple <a href="components/./domains.html">domains</a> (e.g., a POL (protocol-owned liquidity) lending relationship between two parties). Similarly to how a <em>library</em> exposes executable <em>functions</em>, programs are associated with a set of executable <strong>Subroutines</strong>.</p>
<p>A <strong>Subroutine</strong> is a vector of <strong>Functions</strong>. A <strong>Subroutine</strong> can call out to one or more <strong>Function(s)</strong> from a single library, or from different libraries. A <strong>Subroutine</strong> is limited to <strong>one execution domain</strong> (i.e., <strong>Subroutines</strong> cannot use functions from libraries instantiated on multiple domains).</p>
<p>A <strong>Subroutine</strong> can be:</p>
<ul>
<li><strong>Non Atomic</strong> (e.g., Execute function one. If that succeeds, execute function two. If that succeeds, execute function three. And so on.)</li>
<li>or <strong>Atomic</strong> (e.g., execute function one, function two, and function three. If any of them fail, then revert all steps.)</li>
</ul>
<p><strong>Valence Programs</strong> are typically used to implement complex cross-chain workflows that perform financial operations in a trust-minimized way. Because multiple parties may be involved in a <strong>Valence Program</strong>, the parties to a <strong>Valence Program</strong> may wish for limitations on what various parties are authorized to do.</p>
<p>To specify fine-grained controls over who can initiate the execution of a <strong>Subroutine</strong>, program creators use the <strong>Authorizations</strong> module.</p>
<p>The <strong>Authorizations</strong> module is a powerful and flexible system that supports access control configuration schemes, such as:</p>
<ul>
<li><strong>Anyone</strong> can initiate execution of a <strong>Subroutine</strong></li>
<li>Only <strong>permissioned actors</strong> can initiate execution of a <strong>Subroutine</strong></li>
<li>Execution can only be initiated <strong>after a starting timestamp/block height</strong></li>
<li>Execution can only be initiated <strong>up to a certain timestamp/block height</strong></li>
<li>Authorizations are <strong>tokenized</strong>, which means they can be transferred by the holder or used in more sophisticated DeFi scenarios</li>
<li>Authorizations can <strong>expire</strong></li>
<li>Authorizations can be <strong>enabled/disabled</strong></li>
<li>Authorizations can tightly <strong>constrain parameters</strong> (e.g., an authorization to execute a token transfer message can limit the execution to only supply the amount argument, not the denom or receiver in the transfer message)</li>
</ul>
<p>To support the on-chain execution of <strong>Valence Programs</strong>, the <strong>Valence Protocol</strong> provides two important contracts: the <strong>Authorizations Contract</strong> and the <strong>Processor Contract</strong>.</p>
<p>The <strong>Authorizations Contract</strong> is the entry point for users. The user sends a set of messages to the Authorizations Contract and the label (id) of the authorization they want to execute. The Authorizations Contract then verifies that the sender is authorized and that the messages are valid, constructs a <em>MessageBatch</em> based on the subroutine, and passes this batch to the <strong>Processor Contract</strong> for execution. The authority to execute any <strong>Subroutine</strong> is tokenized so that these tokens can be transferred on-chain.</p>
<p>The <strong>Processor Contract</strong> receives a <em>MessageBatch</em> and executes the contained <em>Messages</em> in sequence. It does this by maintaining execution queues where the queue items are <strong>Subroutines.</strong> The processor exposes a <code>Tick</code> message that allows anyone to trigger the processor, whereby the first batch of the queue is executed or moved to the back of the queue if it's not executable yet (e.g., retry period has not passed).</p>
<pre class="mermaid">graph LR;
	User --&gt; |Subroutine| Auth(Authorizations)
	Auth --&gt; |Message Batch| P(Processor)
	P --&gt; |Function 1| S1[Library 1]
	P --&gt; |Function 2| S2[Library 2]
	P --&gt; |Function N| S3[Library N]
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wip-middleware"><a class="header" href="#wip-middleware">WIP: Middleware</a></h1>
<p>The Valence Middleware is a set of components that provide a unified interface for the Valence Type system.</p>
<p>At its core, middleware is made up from the following components.</p>
<h2 id="design-goals"><a class="header" href="#design-goals">Design goals</a></h2>
<p>TODO: describe modifiable middleware, design goals and philosophy behind it</p>
<p>These means are achieved with three key components:</p>
<ul>
<li>brokers</li>
<li>type registries</li>
<li>Valence types</li>
</ul>
<h2 id="middleware-brokers"><a class="header" href="#middleware-brokers">Middleware Brokers</a></h2>
<p>Middleware brokers are responsible for managing the lifecycle of middleware instances and their associated types.</p>
<h2 id="middleware-type-registries"><a class="header" href="#middleware-type-registries">Middleware Type Registries</a></h2>
<p>Middleware Type Registries are responsible for unifying a set of foreign types to be used in Valence Programs.</p>
<h2 id="valence-types"><a class="header" href="#valence-types">Valence Types</a></h2>
<p>Valence Types are the canonical representations of various external domain implementations of some types.</p>
<h2 id="valence-asserter"><a class="header" href="#valence-asserter">Valence Asserter</a></h2>
<p>Valence Asserter enables Valence Programs to assert specific predicates during runtime. This is useful for programs that wish to enable conditional execution of a given function as long as some predicate evaluates to <code>true</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-valence-zk"><a class="header" href="#introduction-to-valence-zk">Introduction to Valence ZK</a></h1>
<p>The Valence Protocol provides Zero-Knowledge proofs and a dedicated ZK Coprocessor system to enhance its capabilities, particularly in areas requiring complex computation, privacy, and verifiable off-chain operations. This ZK integration allows Valence to bridge the gap between the rich, flexible environment of off-chain processing and the trust-minimized, verifiable nature of blockchain execution.</p>
<p>At a high level, ZK proofs enable one party (the prover, in this case, the ZK Coprocessor) to prove to another party (the verifier, typically on-chain smart contracts) that a certain statement is true, without revealing any information beyond the validity of the statement itself. In Valence, this means that computationally intensive or private tasks can be executed off-chain by a "guest program" running on the ZK Coprocessor. This guest program produces a result along with a cryptographic proof attesting to the correctness of that result according to the program's logic.</p>
<p>This proof, which is relatively small and efficient to check, is then submitted to the Valence smart contracts on-chain. The on-chain contracts only need to verify this succinct proof to be assured that the off-chain computation was performed correctly, rather than having to re-execute the entire complex computation themselves. This model brings several advantages, including reduced gas costs, increased transaction throughput, the ability to handle private data, and the capacity to implement more sophisticated logic than would be feasible purely on-chain.</p>
<p>Key terms you will encounter in this documentation include:</p>
<ul>
<li><strong>ZK Coprocessor:</strong> An off-chain service responsible for running "guest programs" and generating ZK proofs of their execution.</li>
<li><strong>Guest Program:</strong> A piece of software designed by developers for off-chain execution on the ZK Coprocessor. It comprises two main parts: the <strong>ZK Circuit</strong> (which defines the core ZK-provable computations) and the <strong>Controller</strong> (Wasm-compiled logic that prepares inputs for the circuit, handles its outputs, and interacts with the Coprocessor environment).</li>
<li><strong>zkVM (Zero-Knowledge Virtual Machine):</strong> An environment that can execute arbitrary programs and produce a ZK proof of that execution. The Valence ZK Coprocessor leverages such technology (e.g., SP1) to run guest programs.</li>
<li><strong>Encoders:</strong> Systems that compress blockchain state into formats suitable for ZK proofs. The Unary Encoder handles single-chain state transitions, while the Merkleized Encoder manages cross-chain state dependencies.</li>
<li><strong>Proof:</strong> A small piece of cryptographic data that demonstrates a computation was performed correctly according to a specific program, without revealing all the details of the computation.</li>
<li><strong>Public Inputs/Outputs:</strong> The specific data points that are part of the public statement being proven. The ZK proof attests that the guest program correctly transformed certain public inputs into certain public outputs.</li>
<li><strong>Witness:</strong> The complete set of inputs, both public (known to prover and verifier) and private (known only to the prover), required by a ZK circuit to perform its computation and allow the generation of a proof. The ZK proof demonstrates that the computation was performed correctly using this witness, without revealing the private inputs.</li>
</ul>
<p>This set of documentation will guide you through understanding how this ZK system works within Valence, how to develop your own guest programs for the Coprocessor, and how to integrate these ZK-proven results with the on-chain components of the Valence Protocol. For detailed information on how blockchain state is encoded for ZK proofs and cross-chain coordination, see <a href="zk/./07_state_encoding_and_encoders.html">State Encoding and Encoders</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="valence-zk-system-overview"><a class="header" href="#valence-zk-system-overview">Valence ZK System Overview</a></h1>
<p>The Valence Zero-Knowledge (ZK) system facilitates the execution of complex or private computations off-chain, with their correctness verified on-chain through cryptographic proofs. This overview describes the primary components and the general flow of information and operations within this system. The foundational concepts of ZK proofs in Valence are introduced in <a href="zk/./_overview.html">Introduction to Valence ZK</a>.</p>
<p>At its core, the system integrates an off-chain ZK Coprocessor Service with on-chain smart contracts, primarily the <code>Authorization</code> and <code>VerificationGateway</code> contracts. A key technical challenge is encoding blockchain state into formats suitable for zero-knowledge proofs, enabling pure functions to operate on committed state transitions. For detailed information on state encoding mechanisms and cross-chain coordination, see <a href="zk/./07_state_encoding_and_encoders.html">State Encoding and Encoders</a>.</p>
<h3 id="component-roles"><a class="header" href="#component-roles">Component Roles</a></h3>
<p>The Valence ZK system comprises several key components, each with distinct responsibilities.</p>
<p>The <strong>ZK Coprocessor Service</strong>, operating off-chain, is a persistent service that manages ZK "guest programs." It deploys new guest programs, executes them with specific inputs, manages proving using an underlying zkVM (like SP1), and makes generated proofs available. Developers interact with this service to deploy ZK applications and initiate proof generation.</p>
<p>A <strong>Guest Program</strong> is application-specific code developed by users. It consists of two parts: the <strong>Controller</strong> (Wasm-compiled Rust code running in the Coprocessor's sandbox) takes input data, processes it to generate a "witness" for the ZK circuit, and coordinates proof generation. The <strong>ZK Circuit</strong> (e.g., SP1 circuit) performs the core computation and assertions, taking the witness and producing a proof and public output (<code>Vec&lt;u8&gt;</code>) that forms the primary data for on-chain contracts.</p>
<p>The <strong><code>Authorization</code> Contract</strong> (e.g., <code>Authorization.sol</code> for EVM chains) serves as the entry point for submitting ZK proofs for verification. It handles ZK-specific authorization logic, checking if proof submitters are authorized for given ZK programs (by <code>registry</code> ID) and managing replay protection.</p>
<p>The <strong><code>VerificationGateway</code> Contract</strong> performs actual cryptographic verification of ZK proofs. The <code>Authorization</code> contract delegates verification to a configured <code>VerificationGateway</code>, which stores Verification Keys (VKs) for registered guest programs and uses them with submitted proofs and public inputs to confirm proof validity.</p>
<h3 id="zk-program-flows"><a class="header" href="#zk-program-flows">ZK Program Flows</a></h3>
<p>The following diagrams illustrate the key workflows in the Valence ZK system:</p>
<h4 id="deployment-flow"><a class="header" href="#deployment-flow">Deployment Flow</a></h4>
<p>Developers prepare and register their ZK applications, initializing the application before execution. They build guest program components, deploy them to the coprocessor service, and register verification keys on-chain.</p>
<pre class="mermaid">graph TD
    Dev[Developer Machine&lt;br/&gt;- Develops Guest Program&lt;br/&gt;- Builds Controller + Circuit] -- Deploys via cargo-valence --&gt; Coproc[ZK Coprocessor Service]
    Dev -- Registers Verification Key --&gt; OnChain[On-Chain Contracts&lt;br/&gt;Authorization + VerificationGateway]
    
    Coproc -- Assigns --&gt; CID[Controller ID]
    OnChain -- Associates --&gt; RegID[Registry ID]
    
    classDef dev fill:#e3f2fd
    classDef onchain fill:#f3e5f5
    classDef service fill:#e8f5e8
    classDef data fill:#fff3e0
    
    class Dev dev
    class OnChain onchain
    class Coproc service
    class CID,RegID data
</pre>
<h4 id="runtime-flow"><a class="header" href="#runtime-flow">Runtime Flow</a></h4>
<p>Strategists execute ZK-proven actions on-chain through an operational process. They request proof generation from the coprocessor and then submit verified proofs to trigger on-chain execution.</p>
<pre class="mermaid">graph TD
    Strategist[Strategist&lt;br/&gt;- Requests proof generation&lt;br/&gt;- Retrieves proof&lt;br/&gt;- Submits ZKMessage] -- Requests proof generation --&gt; Coproc[ZK Coprocessor Service]
    Coproc -- Executes Guest Program --&gt; Proof[ZK Proof + Public Output]
    Strategist -- Retrieves proof --&gt; Coproc
    Strategist -- Submits ZKMessage + Proof --&gt; OnChain[On-Chain Contracts&lt;br/&gt;Authorization + VerificationGateway]
    OnChain -- Verifies proof --&gt; Valid{Proof Valid?}
    Valid -- Yes --&gt; Processor[Processor Contract]
    Processor -- Executes validated message --&gt; State[Blockchain State Changes]
    
    classDef strategist fill:#fff8e1
    classDef service fill:#e8f5e8
    classDef onchain fill:#f3e5f5
    classDef data fill:#fff3e0
    classDef decision fill:#ffebee
    
    class Strategist strategist
    class Coproc service
    class OnChain,Processor onchain
    class Proof,State data
    class Valid decision
</pre>
<h3 id="operation"><a class="header" href="#operation">Operation</a></h3>
<p>The process of executing an off-chain computation and verifying it on-chain generally follows a sequence of interconnected steps.</p>
<p><strong>Development and Deployment</strong></p>
<p>During development and deployment (off-chain), a developer creates a guest program, defining its Controller and ZK <code>circuit</code>. This guest program is compiled (Controller to Wasm, circuit to target representation) and deployed to the ZK Coprocessor service using <code>cargo-valence</code> CLI, which assigns a unique Controller ID. The Verification Key (VK) for the circuit is registered with the on-chain <code>VerificationGateway</code> and associated with a <code>registry</code> ID that the <code>Authorization</code> contract uses.</p>
<p><strong>Proof Request and Generation</strong></p>
<p>Proof request and generation (off-chain) is initiated when an off-chain entity requests the ZK Coprocessor service to execute the deployed guest program with specific input data using <code>cargo-valence</code> CLI. The Coprocessor runs the Controller, which generates the necessary witness for the ZK <code>circuit</code>. The <code>circuit</code> executes with this witness, and the Coprocessor generates the ZK proof and circuit's public output. The Controller may store this proof and output in its virtual filesystem.</p>
<p><strong>Proof Submission and Verification</strong></p>
<p>Following proof generation, the off-chain entity retrieves the ZK proof and circuit's public output from the Coprocessor. It constructs a <code>ZKMessage</code>, which includes the circuit's public output (forming the <code>processorMessage</code>), the <code>registry</code> ID, a <code>blockNumber</code> for replay protection, and the target <code>authorizationContract</code> address. This <code>ZKMessage</code> and ZK proof are submitted to the <code>executeZKMessage</code> function of the <code>Authorization</code> contract.</p>
<p><strong>On-Chain Processing</strong></p>
<p>This triggers on-chain processing. The <code>Authorization</code> contract performs initial checks, verifying sender authorization for the <code>registry</code> ID and ensuring replay protection using the <code>blockNumber</code>. If checks pass, it calls the <code>verify</code> function on the <code>VerificationGateway</code>, passing the ZK proof and relevant public inputs from the <code>ZKMessage</code>. The <code>VerificationGateway</code> uses the <code>registry</code> ID to fetch the correct VK and verify the proof. The first 32 bytes of public inputs are a "Coprocessor Root" hash, with application-specific circuit output following.</p>
<p><strong>Execution of Proven Action</strong></p>
<p>Upon successful proof verification, the <code>Authorization</code> contract considers the <code>ZKMessage</code> contents (specifically the <code>processorMessage</code>) authentic and authorized. It dispatches this <code>processorMessage</code> to the appropriate Valence <code>Processor</code> contract for execution, leading to blockchain state changes based on the ZK-proven off-chain computation.</p>
<p>This system allows Valence to securely integrate complex off-chain logic with its on-chain operations, opening up a wide range of advanced application possibilities.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="developing-valence-coprocessor-apps"><a class="header" href="#developing-valence-coprocessor-apps">Developing Valence Coprocessor Apps</a></h1>
<p>This guide is designed for developers looking to build Zero-Knowledge (ZK) applications, or "guest programs," for the Valence ZK Coprocessor. It focuses on using the <code>valence-coprocessor-app</code> template as a foundation. Before diving in, it is beneficial to have a grasp of the concepts presented in <a href="zk/./_overview.html">Introduction to Valence ZK</a> and <a href="zk/./01_system_overview.html">Valence ZK System Overview</a>.</p>
<p>The <a href="https://github.com/timewave-computer/valence-coprocessor-app">valence-coprocessor-app template repository</a> serves as the primary starting point and practical reference for this guide.</p>
<h3 id="core-structure-of-a-coprocessor-app"><a class="header" href="#core-structure-of-a-coprocessor-app">Core Structure of a Coprocessor App</a></h3>
<p>A Valence Coprocessor App (a Guest Program), when based on the template, is primarily structured around two main Rust crates, which compile into the two logical parts of the Guest Program: the Controller and the ZK Circuit.</p>
<ol>
<li>
<p><strong>The <code>controller</code> Crate (compiles to the Controller):</strong> This component contains off-chain logic executed as Wasm within the Valence ZK Coprocessor's sandboxed environment. This <strong>Controller</strong> acts as an intermediary between user inputs and the ZK circuit. Key responsibilities include receiving input arguments (often JSON) for proof requests, processing inputs to generate a "witness" (private and public data the ZK circuit needs), and interacting with the Coprocessor service to initiate proof generation. The Controller handles proof computation results; it has an entrypoint function the Coprocessor calls upon successful proof generation, allowing the Controller to store the proof or log information. The Controller can utilize a virtual filesystem provided by the Coprocessor, which is FAT-16 based (implying constraints like 3-character file extensions and case-insensitive paths), for persistent data storage.</p>
</li>
<li>
<p><strong>The <code>circuit</code> Crate (defines the ZK Circuit):</strong> This crate defines the <strong>ZK Circuit</strong> itself. The ZK Circuit is the heart of the ZK application, containing the actual computations and assertions whose correctness will be proven. It's typically written using a specialized language or Domain-Specific Language (DSL) that compiles down to a ZK proving system supported by the Coprocessor (for example, SP1). The ZK Circuit receives the witness data prepared by the Controller. It then performs its defined computations and assertions. If all these pass, it produces a public output (as a <code>Vec&lt;u8&gt;</code>), which represents the public statement that will be cryptographically verified on-chain. This output forms a crucial part of the "public inputs" of the ZK proof.</p>
</li>
</ol>
<p>While these two crates form the core, the template might also include an optional <strong><code>./crates/domain</code></strong> crate. This is generally intended for more advanced scenarios, such as defining how to derive state proofs from JSON arguments or for validating block data that might be incorporated within the Coprocessor's operations, though its direct use can vary significantly depending on the specific application's needs.</p>
<h3 id="general-development-workflow"><a class="header" href="#general-development-workflow">General Development Workflow</a></h3>
<p>Developing a Coprocessor App typically follows a sequence of steps from setup to deployment and testing:</p>
<ol>
<li>
<p><strong>Environment Setup:</strong> The initial step involves preparing your development environment. This requires installing Docker, a recent Rust toolchain, and the <a href="https://github.com/timewave-computer/valence-coprocessor/tree/v0.1.13?tab=readme-ov-file#cli-helper">Cargo Valence subcommand</a>. You would then clone the <code>valence-coprocessor-app</code> template repository to serve as the foundation for your new ZK application. For development, you can either use the public Valence ZK Coprocessor service at <code>prover.timewave.computer:37281</code> or optionally run a <a href="https://github.com/timewave-computer/valence-coprocessor/tree/v0.1.13?tab=readme-ov-file#local-execution">local Valence coprocessor instance</a>.</p>
</li>
<li>
<p><strong>ZK Circuit Development (<code>./crates/circuit</code>):</strong> The next phase is to define the logic of your ZK circuit. This involves specifying the exact computations to be performed, the private inputs (the witness) that the circuit will consume, and the public inputs or outputs it will expose. The public output of your ZK circuit (a <code>Vec&lt;u8&gt;</code>) is of particular importance, as this is the data that will ultimately be verified on-chain. It's essential to remember that the first 32 bytes of the <em>full</em> public inputs (as seen by the on-chain verifier) are reserved by the Coprocessor for its own internal root hash; your application-specific public output data will follow these initial 32 bytes.</p>
</li>
<li>
<p><strong>Controller Development (<code>./crates/controller</code>):</strong> Concurrently, you'll develop the Controller logic within the <code>controller</code> crate. This includes implementing the logic to parse incoming JSON arguments that are provided when a proof is requested for your application. You will also need to write the code that transforms these user-provided arguments into the precise witness format required by your ZK circuit. A key part of the Controller is its entrypoint function; this function is called by the Coprocessor service when a proof for your program has been successfully generated and is ready. This entrypoint typically receives the proof itself, the initial arguments that triggered the request, and any logs generated during the process. You must also implement how your Controller should handle this generated proof ‚Äì a common pattern is to store it to a specific path (e.g., <code>/var/share/proof.bin</code>) within its virtual filesystem using a <code>store</code> command payload directed to the Coprocessor.</p>
</li>
<li>
<p><strong>Application Build and Deployment:</strong> Once the ZK Circuit (from <code>circuit</code> crate) and Controller (from <code>controller</code> crate) are developed, you build and deploy your Guest Program to the Coprocessor using the <code>cargo-valence</code> CLI tool. This is typically done by running the command <code>cargo-valence --socket prover.timewave.computer:37281 deploy circuit --controller ./crates/controller --circuit &lt;circuit-crate-project-name&gt;</code> from your app template directory. If you're using a local coprocessor instance, you can omit the <code>--socket</code> parameter. This command compiles both crates (Controller to Wasm) and packages them into a single application bundle, which is then submitted to the Coprocessor service. Upon successful deployment, the Coprocessor service will return a unique Controller ID (e.g., <code>8965493acca61dfc26193978c4b9a785d24192a0a314143f1c497402859df783</code>). This Controller ID is crucial as it's used to reference your deployed ZK application in subsequent interactions.</p>
</li>
<li>
<p><strong>Requesting Proof Generation:</strong> With your Guest Program deployed and its Controller ID known, you can instruct the Coprocessor to generate a proof. This is done using a command like <code>cargo-valence --socket prover.timewave.computer:37281 prove -j '{"value": 42}' -p /var/share/proof.bin &lt;CONTROLLER_ID&gt;</code>. You must replace <code>'{"value": 42}'</code> with the specific JSON input that your Controller is designed to expect. The <code>-p /var/share/proof.bin</code> argument is a suggestion to your Controller's entrypoint, indicating where it might store the resulting proof within its virtual filesystem after it has been generated and delivered back by the Coprocessor. The argument <code>-j '{"value": 42}'</code> will be forwarded to <code>./crates/controller/src/lib.rs:get_witnesses</code>, and the output of this function will be forwarded to the circuit for proving.</p>
</li>
<li>
<p><strong>Retrieving Proofs and Public Inputs:</strong> After the proof generation is complete and your Controller's entrypoint has handled and stored the proof, you can retrieve it from the program's virtual filesystem. This is typically done with a command like <code>cargo-valence --socket prover.timewave.computer:37281 storage -p /var/share/proof.bin &lt;CONTROLLER_ID&gt; | jq -r '.data' | base64 -d | jq</code>. To inspect the public inputs associated with the generated proof (which will include your ZK circuit's specific output along with the Coprocessor's root hash), you can use a command like <code>cargo-valence --socket prover.timewave.computer:37281 proof-inputs -p /var/share/proof.bin &lt;CONTROLLER_ID&gt; | jq -r '.inputs' | base64 -d | hexdump -C</code>. When examining the hexdump, your circuit's specific output data will appear after the initial 32-byte Coprocessor root hash.</p>
</li>
</ol>
<p>This workflow allows for an iterative development process, enabling you to test and refine your ZK guest programs effectively.</p>
<h3 id="incorporating-verifiable-external-state"><a class="header" href="#incorporating-verifiable-external-state">Incorporating Verifiable External State</a></h3>
<p>Guest programs on the Valence Coprocessor can be designed to utilize verifiable state from external blockchains, like Ethereum. This allows ZK applications to react to or incorporate off-chain data in a trust-minimized way. Services such as the state proof service facilitate this by generating state proofs (e.g., Merkle proofs for account balances or storage slots on Ethereum at specific block heights). Currently, this interaction for fetching external state is often achieved via ABI-encoded HTTP calls, though future implementations might support other protocols like WebSockets.</p>
<p>When developing a guest program, you would design its Controller (within the <code>controller</code> crate) to accept such state proofs as part of its input. The ZK <code>circuit</code> can then use the proven external state in its computations. The resulting ZK proof from the Valence Coprocessor will thus attest to the correctness of operations performed on this externally verified data. More detailed architectural considerations for this pattern, including how the Coprocessor environment might support or interact with such external proofs, are discussed in <a href="zk/./04_coprocessor_internals.html">ZK Coprocessor Internals</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integrating-zk-proofs-with-on-chain-contracts"><a class="header" href="#integrating-zk-proofs-with-on-chain-contracts">Integrating ZK Proofs with On-Chain Contracts</a></h1>
<p>This document details the process of integrating Zero-Knowledge (ZK) proofs, generated by a Valence Coprocessor guest program, with the Valence Protocol's on-chain smart contracts. It assumes an understanding of the ZK system as outlined in <a href="zk/./01_system_overview.html">Valence ZK System Overview</a> and how guest programs are developed as described in <a href="zk/./02_developing_coprocessor_apps.html">Developing Valence Coprocessor Apps</a>.</p>
<p>The core of on-chain integration revolves around submitting the ZK proof and its associated public data to the <code>Authorization.sol</code> contract (for EVM chains), which then collaborates with a <code>VerificationGateway.sol</code> to cryptographically verify the proof's authenticity and correctness.</p>
<h3 id="preparing-data-for-on-chain-submission"><a class="header" href="#preparing-data-for-on-chain-submission">Preparing Data for On-Chain Submission</a></h3>
<p>After your guest program successfully executes on the ZK Coprocessor and a proof is generated, two key pieces of data are essential for on-chain interaction:</p>
<ol>
<li><strong>The ZK Proof:</strong> This is the raw cryptographic proof data (e.g., SP1 proof bytes) generated by the Coprocessor, attesting to the correct execution of your guest program's ZK circuit.</li>
<li><strong>The Circuit's Public Output:</strong> Your ZK circuit is designed to produce a public output (<code>Vec&lt;u8&gt;</code>). This output is critical because it represents the data that, once proven correct by the ZK proof, will be used to form the <code>processorMessage</code> for execution by the on-chain Valence <code>Processor</code> contract. It's important to remember that when the full "public inputs" are presented to the on-chain verifier, the first 32 bytes are a prefix that contains the Coprocessor Root hash. The remaining bytes are relevant for constructing on-chain messages.</li>
</ol>
<p>An off-chain system, such as a script, bot, or backend service, is responsible for retrieving these pieces of data from the Coprocessor (typically after the guest program stores them in its virtual filesystem) and then initiating the on-chain transaction.</p>
<h3 id="the-zkmessage-structure"><a class="header" href="#the-zkmessage-structure">The <code>ZKMessage</code> Structure</a></h3>
<p>To submit a ZK-proven action to the Valence Protocol, the off-chain system must construct a <code>ZKMessage</code>. This structure is specifically designed for the <code>executeZKMessage</code> function within the <code>Authorization.sol</code> contract. The <code>ZKMessage</code> encapsulates all necessary information for the on-chain contracts to process the request:</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>registry</code></td><td>uint64</td><td>Unique identifier for the deployed ZK guest program. Used by the Authorization contract to look up the correct Verification Key (VK) from VerificationGateway.</td></tr>
<tr><td><code>blockNumber</code></td><td>uint64</td><td>Current or recent block number for replay protection. Ensures proofs aren't submitted multiple times, or after that they're no longer relevant.</td></tr>
<tr><td><code>authorizationContract</code></td><td>address</td><td>Address of the target Authorization contract. Acts as a safeguard to ensure message is processed by the correct instance.</td></tr>
<tr><td><code>processorMessage</code></td><td>bytes</td><td>Core payload dispatched to Processor contract if ZK proof is valid. Derived from circuit's public output and encoded for ProcessorMessageTypes.</td></tr>
</tbody></table>
</div>
<h3 id="on-chain-verification-sequence"><a class="header" href="#on-chain-verification-sequence">On-Chain Verification Sequence</a></h3>
<p>Once the <code>ZKMessage</code> is constructed and the ZK proof is obtained, the off-chain system submits these to the <code>executeZKMessage</code> function of the <code>Authorization.sol</code> contract. The on-chain processing then unfolds as follows:</p>
<ol>
<li>
<p><strong>Initial Checks by <code>Authorization.sol</code>:</strong> The <code>Authorization</code> contract first performs several preliminary checks. It verifies if the <code>msg.sender</code> (the account submitting the transaction) is authorized to provide proofs for the given <code>registry</code> ID. It also typically checks the <code>blockNumber</code> from the <code>ZKMessage</code> against its record of the last executed block for that <code>registry</code> to prevent replay attacks.</p>
</li>
<li>
<p><strong>Delegation to <code>VerificationGateway.sol</code>:</strong> If the initial checks pass, <code>Authorization.sol</code> delegates the task of cryptographic proof verification to the <code>VerificationGateway.sol</code> contract whose address it has been configured with. It calls a <code>verify</code> function on the gateway, passing along the ZK proof, the <code>registry</code> ID (so the gateway can find the correct VK), and a hash derived from the <code>ZKMessage</code> contents (crucially including the <code>processorMessage</code> which represents your circuit's output).</p>
</li>
<li>
<p><strong>Proof Verification by <code>VerificationGateway.sol</code>:</strong> The <code>VerificationGateway</code> retrieves the pre-registered Verification Key (VK) associated with the <code>registry</code> ID. It then uses this VK, the submitted ZK proof, and the public inputs to perform the cryptographic verification. The public inputs are a critical piece of data: they include the Coprocessor Root hash (the first 32 bytes) followed by your circuit's specific output (which is embedded within the hashed <code>ZKMessage</code>). This Coprocessor Root hash acts as a commitment to the integrity of all Coprocessor state. It implicitly contains all the embedded state proofs of the domain relevant to that ZK proof, managed via its Sparse Merkle Tree (SMT). Every new block appended to a chain relevant to the proof's domain is included in this SMT with a ZK domain proof, and the verifications of these inclusions are cryptographically embedded into this Coprocessor Root. If the proof is valid for the VK and these comprehensive public inputs, the gateway returns a success status to the <code>Authorization.sol</code> contract.</p>
</li>
<li>
<p><strong>Dispatch to <code>Processor.sol</code>:</strong> If the <code>VerificationGateway</code> confirms the proof's validity, <code>Authorization.sol</code> considers the <code>processorMessage</code> within the <code>ZKMessage</code> to be authentic and authorized for execution. It then typically updates its state for replay protection (e.g., storing the <code>blockNumber</code> as the last executed for that <code>registry</code>) and dispatches the <code>processorMessage</code> to the appropriate Valence <code>Processor.sol</code> contract.</p>
</li>
<li>
<p><strong>Execution by <code>Processor.sol</code>:</strong> The <code>Processor.sol</code> contract receives the <code>processorMessage</code> and executes the sequence of on-chain actions (e.g., calls to various Valence Libraries or other smart contracts) as defined within that message. This is where the result of your ZK-proven off-chain computation translates into tangible on-chain state changes.</p>
</li>
</ol>
<p>This integration pathway ensures that off-chain computations, once proven correct by the ZK Coprocessor, can be securely and reliably acted upon by the Valence on-chain contracts.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zk-coprocessor-internals"><a class="header" href="#zk-coprocessor-internals">ZK Coprocessor Internals</a></h1>
<p>This document provides an in-depth look into the internal architecture and operational mechanics of the Valence ZK Coprocessor service. It is intended for those who wish to understand more about the Coprocessor's design beyond the scope of typical application development. Familiarity with <a href="zk/./01_system_overview.html">Valence ZK System Overview</a> is assumed.</p>
<p>The Valence ZK Coprocessor is designed as a persistent off-chain service that registers and executes Zero-Knowledge (ZK) guest applications.</p>
<h3 id="service-architecture"><a class="header" href="#service-architecture">Service Architecture</a></h3>
<p>The Coprocessor service consists of several coordinated components that work together to provide a complete ZK execution environment. It's important to note a key architectural separation: the <code>coprocessor</code> itself (which handles API requests, controller execution, and virtual filesystem management) is distinct from the <code>prover</code>. While they work in tandem, they can be deployed and scaled independently. For instance, Valence runs a dedicated, high-performance prover instance at <code>prover.timewave.computer:37282</code>. Coprocessor instances, including those run locally for development, can connect to this remote prover (typically requiring a <code>VALENCE_PROVER_SECRET</code> for access). This separation also allows developers to run a local coprocessor instance completely isolated from a real prover, using mocked ZK proofs. This is invaluable for rapid iteration and debugging of controller logic without incurring the overhead of actual proof generation.</p>
<p>The main components of the Coprocessor service include:</p>
<p>The <strong>API Layer</strong> serves as the primary external interface, exposing REST endpoints (typically on port <code>37281</code> for the coprocessor service itself) for core operations. Developers can deploy guest programs by submitting <code>controller</code> and <code>circuit</code> bundles, they can request proofs for deployed programs, query the status of ongoing tasks, and retrieve data stored in the virtual filesystem such as generated proofs or execution logs.</p>
<p><strong>Request Management &amp; Database</strong> - This component validates incoming requests and queues them for processing. It maintains persistent storage for deployed guest program details including Controller IDs, circuit specifications, and controller bundles, while also tracking proof generation status and execution metadata.</p>
<p>The <strong>Controller Executor / Sandbox</strong> provides an isolated execution environment for <code>controller</code> crate logic. This sandbox runs a WebAssembly runtime for controller code and provides a crucial interface that allows controllers to signal when witness preparation is complete and proof generation should commence. Controllers can also perform filesystem operations through this interface.</p>
<p><strong>Proving Engine Integration</strong> - Orchestrates the actual ZK proof generation process using underlying zkVM systems like SP1 or Groth16. This component manages prover resources, handles the translation of circuits and witnesses into the required formats for specific proving backends, and processes the resulting proof data and public outputs.</p>
<p>The <strong>Virtual Filesystem Manager</strong> allocates FAT-16 based virtual filesystems to each guest program, enabling controllers to store proofs and logs through <code>store</code> commands. This filesystem has certain limitations on filename length and character sets that developers must consider.</p>
<h3 id="the-coprocessor-process"><a class="header" href="#the-coprocessor-process">The Coprocessor Process</a></h3>
<p><strong>Coprocessor Root Hash</strong> is a notable internal detail where the Coprocessor prepends a 32-byte hash to application-specific public outputs from the ZK circuit. This combined data forms the complete "public inputs" that are cryptographically bound to the proof, ensuring that proofs are tied to the specific Coprocessor instance that produced them. On-chain verifiers must account for this structure when validating proofs.</p>
<p><strong>Task Lifecycle</strong> involves proof generation requests progressing through several distinct stages: initial queuing, controller execution for witness generation, circuit proving, and finally proof delivery back to the controller entrypoint. The API provides mechanisms to track task status throughout this lifecycle.</p>
<p><strong>Persistent Job Queues</strong> enable the Coprocessor service to handle multiple concurrent proof requests efficiently and reliably through persistent job queues, and worker nodes for computationally intensive proving tasks.</p>
<h3 id="handling-verifiable-state-proofs"><a class="header" href="#handling-verifiable-state-proofs">Handling Verifiable State Proofs</a></h3>
<p>Guest programs can incorporate state from external blockchains through a structured integration pattern that enhances their capabilities significantly.</p>
<p>External State Proof Services, such as the <code>eth-state-proof-service</code>, connect to external chains via RPC, query desired state at specific block heights, and construct Merkle proofs relative to known block hashes. These services play a crucial role in bridging external blockchain data into the ZK environment.</p>
<p>The guest program integration follows a clear pattern. During <strong>Proof Ingestion</strong>, the controller receives external state proofs via JSON payloads and extracts state values along with relevant metadata like block hashes. In the <strong>Witness Preparation</strong> phase, the controller incorporates this external state into the witness for the ZK circuit. The <strong>Circuit Logic</strong> then performs computations using the external state data, with the option to verify external proofs directly within the circuit for stronger security guarantees.</p>
<p><strong>Trust Model Considerations</strong> - The ZK proof fundamentally attests that given a set of provided inputs (which may include externally proven state at the latest block height), the circuit executed correctly to produce the specified outputs. The Coprocessor provides a state proof interface for each chain that exposes a light client prover wrapped in a recursive circuit. All light client circuits are initialized at a trusted height, where block hash and committee composition are taken as "weakly subjective" public inputs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sparse-merkle-trees-in-valence"><a class="header" href="#sparse-merkle-trees-in-valence">Sparse Merkle Trees in Valence</a></h1>
<p>A sparse Merkle tree (SMT) is a specialized Merkle tree with leaf indices defined by an injective function from predefined arguments. The verification key of a ZK circuit, being injective to the circuit's definition, serves as an index for available programs.</p>
<p>Since ZK proofs are uniquely tied to their verification keys, we can use these keys to index and organize proofs from different programs. This makes each verification key a unique identifier for its corresponding proof within the collection.</p>
<h2 id="merkle-tree"><a class="header" href="#merkle-tree">Merkle Tree</a></h2>
<p>A Merkle tree is an authenticated data structure consisting of leaves and nodes that form a tree shape. Each node in this tree represents the cryptographic hash of its children, while the leaves hold an arbitrary piece of data‚Äîusually the hash value of some variable input.</p>
<p>For a hash function <code>H</code>, if we insert data items A, B, C into a Merkle tree, the resulting structure would look like:</p>
<pre class="mermaid">graph TB
    %% Root node
    r[&quot;R := H(t10, t11)&quot;]
    
    %% Level 1
    m1[&quot;t10 := H(t00, t01)&quot;] --&gt; r
    m2[&quot;t11 := H(t02, t03)&quot;] --&gt; r
    
    %% Level 2
    c1[&quot;t00 := H(A)&quot;] --&gt; m1
    c2[&quot;t01 := H(B)&quot;] --&gt; m1
    c3[&quot;t02 := H(C)&quot;] --&gt; m2
    c4[&quot;t03 := 0&quot;] --&gt; m2
</pre>
<p><em>Figure 1: Basic Merkle tree structure. The node labeling uses a coordinate system where the first digit represents the tree level (0 = leaves, 1 = intermediate nodes, etc.) and the second digit represents the position at that level. Each parent node is computed as the hash of its two children in this binary tree structure.</em></p>
<h3 id="membership-proof"><a class="header" href="#membership-proof">Membership Proof</a></h3>
<p>A Merkle tree serves as an efficient data structure for validating the membership of a leaf node within a set in logarithmic time, making it especially useful for handling large sets and well-suited for random insertion patterns. A Merkle opening (or Merkle proof) represents an array of sibling nodes that outline a Merkle Path leading to a commitment Root. If the verifier possesses the root and employs a cryptographic hash function, the pre-image of the hash is non-malleable; in a cryptographic hash, it's unfeasible to discover a set of siblings resulting in the root, except for the valid inputs. Given that the leaf node is known to the verifier, a Merkle Proof will consist of a sequence of hashes leading up to the root. This allows the verifier to compute the root value and compare it with the known Merkle root, thereby confirming the membership of any provided alleged member without relying on the trustworthiness of the source. Consequently, a single hash commitment ensures that any verifier can securely validate the membership of any proposed member supplied by an untrusted party.</p>
<p>To prove that <code>C</code> is in the tree, the Merkle proof includes the sibling nodes along the path from <code>C</code> to the root: <code>[t03, t10]</code>. So the verifier, that knows <code>R</code> beforehand, will compute:</p>
<ol>
<li><code>t02 := H(C)</code></li>
<li><code>t11 := H(t02, t03)</code></li>
<li><code>R' := H(t10, t11)</code></li>
</ol>
<p>If <code>R == R'</code>, then <code>C</code> is a member of the set.</p>
<p>Note that the depth of the tree is the length of its Merkle opening, that is: we open up to a node with depth equal to the length of the proof.</p>
<h2 id="sparse-data"><a class="header" href="#sparse-data">Sparse Data</a></h2>
<p>Let's consider a public function <code>f</code> that accepts a member and returns a tuple. This tuple consists of the index within the tree as a <code>u64</code> value, and the hash of the leaf: <code>(i, h) = f(X)</code>.</p>
<p>For the example above, let's assume two members:</p>
<ul>
<li><code>(3, a) := f(A)</code></li>
<li><code>(1, b) := f(B)</code></li>
</ul>
<pre class="mermaid">graph TB
    %% Root node
    r[&quot;R := H(t10, t11)&quot;]
    
    %% Level 1
    m1[&quot;t10 := H(t00, t01)&quot;] --&gt; r
    m2[&quot;t11 := H(t02, t03)&quot;] --&gt; r
    
    %% Level 2
    c1[&quot;t00 := 0&quot;] --&gt; m1
    c2[&quot;t01 := b&quot;] --&gt; m1
    c3[&quot;t02 := 0&quot;] --&gt; m2
    c4[&quot;t03 := a&quot;] --&gt; m2
</pre>
<p>The primary distinction of a sparse Merkle tree lies in the deterministic leaf index, making it agnostic to input order. In essence, this structure forms an unordered set whose equivalence remains consistent irrespective of the sequence in which items are appended.</p>
<p>In addition to membership proofs sparse Merkle trees also support generating proofs of non-membership. To achieve this, we carry out a Merkle opening at the specified target index, and expect the returned value to be <code>0</code>.</p>
<p>Let's assume a non-member <code>X</code> to be <code>(0, x) := f(X)</code>. To verify that <code>X</code> is not in the tree, given the root <code>R</code> and the non-membership proof <code>[b, t11]</code>, the verifier:</p>
<ol>
<li>Computes <code>(0, x) := f(X)</code> to find where <code>X</code> should be located (index 0)</li>
<li>Reconstructs <code>t10 := H(0, b)</code> using the empty slot (0) and sibling <code>b</code></li>
<li>Computes the root <code>R' := H(t10, t11)</code> and checks if <code>R' == R</code></li>
</ol>
<p>If <code>R == R'</code>, then <code>0</code> is at the slot of <code>X</code>. Since we know <code>X</code> to not be the pre-image of <code>0</code> in <code>H</code>, then <code>X</code> is not a member of the tree.</p>
<h2 id="the-valence-smt"><a class="header" href="#the-valence-smt">The Valence SMT</a></h2>
<p>Valence's sparse Merkle tree is designed to utilize the hash of the verifying key generated by the ZK circuit as its index. The tree's leaf data will encompass the proof and input arguments for the ZK program. For this particular implementation, we can consider the input arguments as a generic type, which will be specifically defined during development. These input arguments will constitute the key-value pairs that define a subset of the contract state essential for state transition. The proof will be a vector of bytes.</p>
<p>The tree depth is adaptive, representing the smallest value required to traverse from a leaf node to the root, given the number of elements involved. This approach avoids writing nodes that contain unused entries. So if a tree contains two adjacent nodes indexed at <code>[(0,0), (0,1)]</code>, the Merkle opening will contain a single element: the sibling leaf of the validated node.</p>
<p>If the tree comprises two nodes with indices <code>[(0,0), (0,2)]</code>, the Merkle opening will have two elements, allowing for a complete traversal from the leaves to the root.</p>
<h3 id="precomputed-empty-subtrees"><a class="header" href="#precomputed-empty-subtrees">Precomputed Empty Subtrees</a></h3>
<p>The Valence SMT implementation includes a precomputed set of empty subtrees based on the selected hash primitive. For example, when a tree contains only empty nodes, all hash values are constant:</p>
<pre class="mermaid">graph TB
    %% Root node
    r[&quot;R := H(t10, t11)&quot;]
    
    %% Level 1
    m1[&quot;t10 := H(t00, t01)&quot;] --&gt; r
    m2[&quot;t11 := H(t02, t03)&quot;] --&gt; r
    
    %% Level 2
    c1[&quot;t00 := 0&quot;] --&gt; m1
    c2[&quot;t01 := 0&quot;] --&gt; m1
    c3[&quot;t02 := 0&quot;] --&gt; m2
    c4[&quot;t03 := 0&quot;] --&gt; m2
</pre>
<p>In practice, sparse Merkle trees often have many empty positions, especially when the index space is large but only a few positions are occupied. This creates opportunities for optimization through precomputation.</p>
<p>Consider a more realistic scenario where we have a sparse tree with a single leaf <code>X</code> at index 2:</p>
<pre class="mermaid">graph TB
    %% Root
    r[&quot;R := H(t20, K2)&quot;]
    
    %% Level 1
    t20[&quot;t20 := H(K1, t11)&quot;] --&gt; r
    t21[&quot;K2&quot;] --&gt; r
    
    %% Level 2
    m1[&quot;K1&quot;] --&gt; t20
    m2[&quot;t11 := H(X, K0)&quot;] --&gt; t20
    
    %% Level 3
    c3[&quot;X&quot;] --&gt; m2
    c4[&quot;K0&quot;] --&gt; m2
</pre>
<p>Rather than computing <code>(K0, K1, K2)</code> each time, these values can be precomputed since they represent known constants: <code>K0 := H(0)</code>, <code>K1 := H(K0, K0)</code>, <code>K2 := H(K1, K1)</code>.</p>
<p>By using SMTs, Valence can efficiently manage and verify large collections of authenticated data, including ZK proofs from coprocessor applications and commitments to program states.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="valence-zk-guest-environment"><a class="header" href="#valence-zk-guest-environment">Valence ZK Guest Environment</a></h1>
<p>This document describes the specific execution environment provided by the Valence Coprocessor for "guest applications." Understanding this environment is crucial for developers building robust and efficient ZK applications. It complements the information found in <a href="zk/./02_developing_coprocessor_apps.html">Developing Valence Coprocessor Apps</a>.</p>
<p>When a guest program's <code>controller</code> crate logic is executed by the Valence ZK Coprocessor, it runs within a specialized, sandboxed environment. This environment imposes certain characteristics and provides specific interfaces for interaction.</p>
<h3 id="execution-sandbox"><a class="header" href="#execution-sandbox">Execution Sandbox</a></h3>
<p>The primary purpose of the sandbox is to securely execute the guest program's Rust code (often compiled to WebAssembly or a similar intermediate representation) that is responsible for generating the witness for the ZK circuit. This isolation prevents a guest program from interfering with the Coprocessor service itself or other concurrently running guest programs.</p>
<p>While the exact nature of the sandbox can evolve, developers should assume an environment with constrained resources. This means that overly complex or long-running computations within the <code>controller</code> crate (before handing off to the ZK circuit for proving) should be approached with caution. The main computationally intensive work should ideally be designed into the ZK circuit itself, as that is what the proving system is optimized for.</p>
<h3 id="virtual-filesystem"><a class="header" href="#virtual-filesystem">Virtual Filesystem</a></h3>
<p>Each deployed guest program is provided with its own private virtual filesystem by the Coprocessor. This filesystem is essential for storing intermediate data, logs, and most importantly, the generated ZK proofs.</p>
<p>Key characteristics and limitations of this virtual filesystem, as indicated by the <code>valence-coprocessor-app</code> template examples, include:</p>
<ul>
<li><strong>FAT-16 Basis:</strong> The underlying structure often emulates a FAT-16 filesystem. This implies certain legacy constraints that developers must be aware of.</li>
<li><strong>Extension Length:</strong> File extensions are typically limited to a maximum of three characters (e.g., <code>.bin</code>, <code>.txt</code>, <code>.log</code>).</li>
<li><strong>Case Insensitivity:</strong> File and directory names are generally treated as case-insensitive (e.g., <code>Proof.bin</code> and <code>proof.bin</code> would refer to the same file).</li>
<li><strong>Path Structure:</strong> Paths are typically Unix-like (e.g., <code>/var/share/my_proof.bin</code>).</li>
<li><strong>Interaction:</strong> The <code>controller</code> crate interacts with this filesystem by sending specific commands to the Coprocessor service rather than through direct OS-level file I/O calls. For example, to store a generated proof, the <code>controller</code> constructs a <code>store</code> command with the target path and data, which the Coprocessor then writes to the program's virtual disk image.</li>
</ul>
<p>Developers should design their <code>controller</code> logic to work within these constraints, particularly when choosing filenames for storing proofs or other outputs.</p>
<h3 id="interfacing-with-the-coprocessor-service"><a class="header" href="#interfacing-with-the-coprocessor-service">Interfacing with the Coprocessor Service</a></h3>
<p>From within its sandboxed execution, the <code>controller</code> crate logic needs to communicate with the host Coprocessor service for several key operations:</p>
<ul>
<li><strong>Signaling Witness Readiness:</strong> After processing inputs and preparing the witness for the ZK circuit, the <code>controller</code> must inform the Coprocessor that it is ready for the proving phase to begin.</li>
<li><strong>Receiving Proof Results:</strong> The Coprocessor calls a designated entrypoint function within the <code>controller</code> crate upon completion of a proof generation task (successful or failed). This entrypoint receives the proof data, initial arguments, and any logs.</li>
<li><strong>Filesystem Operations:</strong> As mentioned above, storing data (like the received proof) or logging information involves sending structured requests to the Coprocessor to perform actions on the program's virtual filesystem.</li>
</ul>
<p>The exact mechanism for this interaction (e.g., specific function calls, message passing, predefined environment variables or handles) is defined by the Coprocessor's execution environment for guest programs.</p>
<h3 id="resource-constraints"><a class="header" href="#resource-constraints">Resource Constraints</a></h3>
<p>Guest applications run with finite system resources including limited memory, CPU time, and storage space. Developers should aim for efficiency in their <code>controller</code> crate logic, focusing on input processing, witness generation, and handling results rather than performing heavy computations that are better suited for the ZK circuit itself.</p>
<p>Understanding these environment constraints enables developers to build ZK applications that run efficiently on the Valence Coprocessor.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="state-encoding-and-encoders"><a class="header" href="#state-encoding-and-encoders">State Encoding and Encoders</a></h1>
<p>This document explains how the Valence ZK Coprocessor handles state encoding for zero-knowledge proofs and cross-chain state synchronization. Understanding these concepts is essential for building applications that work across multiple blockchains.</p>
<blockquote>
<p><strong>Implementation Status:</strong> The state encoding mechanisms described in this document represent the design goals and architecture for the Valence ZK Coprocessor. While the core coprocessor infrastructure exists (as shown in the <a href="https://github.com/timewave-computer/valence-coprocessor-app">valence-coprocessor-app template</a>), the full state encoding and cross-chain coordination features are still in active development.</p>
</blockquote>
<h2 id="the-state-encoding-challenge"><a class="header" href="#the-state-encoding-challenge">The State Encoding Challenge</a></h2>
<p>The core challenge in ZK coprocessor design lies in encoding state. ZK applications are pure functions that must utilize existing state as arguments to produce an evaluated output state. This means we need a way to compress blockchain state into a format suitable for zero-knowledge proofs.</p>
<p>For any state transition, we can describe it as a pure function: <code>f(A) = B</code>, where <code>A</code> is the initial state and <code>B</code> is the resulting state after applying function <code>f</code>.</p>
<h2 id="pure-functions-in-zkvms"><a class="header" href="#pure-functions-in-zkvms">Pure Functions in zkVMs</a></h2>
<p>The Valence ZK Coprocessor leverages zero-knowledge virtual machines (zkVMs) to execute Rust programs and generate proofs of their execution. Specifically, Valence uses a RISC-V zkVM, currently Succinct's SP1. For state encoding purposes, these applications must be structured as pure functions <code>f(x) = y</code>.</p>
<p>The zkVM workflow for state transitions follows the following pattern:</p>
<ol>
<li><strong>Application definition</strong>: The state transition logic is written in Rust as a pure function</li>
<li><strong>Key generation</strong>: The compiled application produces a proving key <code>pk</code> and verifying key <code>vk</code></li>
<li><strong>Proof generation</strong>: Given inputs <code>x</code>, the zkVM calls <code>prove(pk, x)</code> to generate proof <code>p</code></li>
<li><strong>Verification</strong>: The proof is verified by calling <code>verify(vk, x, y, p)</code></li>
</ol>
<p>This pure function constraint is what necessitates the state encoding mechanisms described in this document - we must compress mutable blockchain state into immutable inputs and outputs suitable for zero-knowledge proving.</p>
<h2 id="unary-encoder"><a class="header" href="#unary-encoder">Unary Encoder</a></h2>
<p>The Unary Encoder compresses account state transitions into zero-knowledge proofs. It handles the transformation from on-chain state mutations to ZK-provable computations.</p>
<h3 id="basic-state-transition-example"><a class="header" href="#basic-state-transition-example">Basic State Transition Example</a></h3>
<p>Consider an account with a key-value store that maps addresses to balances. A traditional on-chain transfer function might look like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn transfer(&amp;mut self, signature: Signature, from: Address, to: Address, value: u64) {
    assert!(signature.verify(&amp;from));
    assert!(value &gt; 0);
    
    let balance_from = self.get(&amp;from).unwrap();
    let balance_to = self.get(&amp;to).unwrap_or(0);
    
    self.insert(from, balance_from.checked_sub(value).unwrap());
    self.insert(to, balance_to.checked_add(value).unwrap());
}
<span class="boring">}</span></code></pre></pre>
<p>For ZK execution, we can create a trusted version that delegates signature verification to the ZK circuit:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn transfer_trusted(&amp;mut self, from: Address, to: Address, value: u64) {
    let balance_from = self.get(&amp;from).unwrap();
    let balance_to = self.get(&amp;to).unwrap_or(0);
    
    self.insert(from, balance_from - value);
    self.insert(to, balance_to + value);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="zk-application-structure"><a class="header" href="#zk-application-structure">ZK Application Structure</a></h3>
<p>In the current Valence Coprocessor template, ZK applications consist of two components: a controller and a circuit. The controller processes inputs and generates witnesses, while the circuit performs the ZK-provable computation.</p>
<p><strong>Controller (processes JSON inputs and generates witnesses):</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn get_witnesses(args: Value) -&gt; anyhow::Result&lt;Vec&lt;Witness&gt;&gt; {
    let (signature, from, to, value) = parse_transfer_args(args);
    
    // Verify signature off-chain and prepare witness data
    signature.verify(&amp;from)?;
    
    let witness_data = TransferWitness {
        from,
        to, 
        value,
        initial_state: get_current_state(),
    };
    
    Ok(vec![Witness::Data(witness_data.encode())])
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Circuit (performs ZK computation):</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn circuit(witnesses: Vec&lt;Witness&gt;) -&gt; Vec&lt;u8&gt; {
    let witness_data = TransferWitness::decode(witnesses[0].as_data().unwrap());
    let mut state = witness_data.initial_state;
    
    // Perform trusted transfer (signature already verified in controller)
    state.transfer_trusted(witness_data.from, witness_data.to, witness_data.value);
    
    // Return state commitment for on-chain verification
    state.commitment().encode()
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Note:</strong> The above examples show the conceptual structure for state encoding. The current template implementation uses simpler examples (like incrementing a counter), as the full state encoding mechanisms are still in development.</p>
</blockquote>
<h3 id="on-chain-verification"><a class="header" href="#on-chain-verification">On-Chain Verification</a></h3>
<p>When the target chain receives the proof and circuit output, it can verify execution correctness:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn verify(&amp;self, proof: Proof, circuit_output: Vec&lt;u8&gt;) {
    let current_commitment = self.state.commitment();
    
    // Extract the new state commitment from circuit output
    let new_commitment = StateCommitment::decode(circuit_output);
    
    // Verify the ZK proof
    proof.verify(&amp;self.vk, &amp;[current_commitment, new_commitment].concat());
    
    // Apply the proven state transition
    self.state.apply_commitment(new_commitment);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="merkleized-encoder"><a class="header" href="#merkleized-encoder">Merkleized Encoder</a></h2>
<p>For cross-chain applications, the Merkleized Encoder handles state transition dependencies across multiple domains. This enables parallel execution while maintaining correctness for chains that depend on each other's state.</p>
<h3 id="cross-chain-state-dependencies"><a class="header" href="#cross-chain-state-dependencies">Cross-Chain State Dependencies</a></h3>
<p>Consider three chains where:</p>
<ul>
<li>Chain 1 executes independently</li>
<li>Chain 2 executes independently</li>
<li>Chain 3 depends on the result from Chain 1</li>
</ul>
<p>The Merklelized Encoder creates a Merkle tree structure:</p>
<pre><code class="language-text">        R (Root)
       /         \
     M1           M2
    /  \         /  \
   C1   C2      C3   0
   |    |       |
Chain1 Chain2 Chain3
</code></pre>
<p>Each leaf contains the encoded state transition for its respective chain:</p>
<ul>
<li><code>C1</code>: <code>(S1 ‚Üí T1), K1</code> (Chain 1 transition)</li>
<li><code>C2</code>: <code>(S2 ‚Üí T2), K2</code> (Chain 2 transition)</li>
<li><code>C3</code>: <code>(S3 ‚Üí T3), K3</code> (Chain 3 transition, depends on T1)</li>
</ul>
<h3 id="parallel-and-sequential-execution"><a class="header" href="#parallel-and-sequential-execution">Parallel and Sequential Execution</a></h3>
<p>The ZK coprocessor can execute proofs in parallel where possible:</p>
<ol>
<li><strong>Independent execution</strong>: Chain 1 and Chain 2 can execute in parallel</li>
<li><strong>Sequential dependency</strong>: Chain 3 waits for Chain 1's result <code>T1</code></li>
<li><strong>State sharing</strong>: Chain 3 receives <code>T1</code> and validates the foreign state while processing</li>
</ol>
<h3 id="optimized-verification"><a class="header" href="#optimized-verification">Optimized Verification</a></h3>
<p>The Merkle tree structure provides logarithmic verification efficiency. Each chain only needs:</p>
<ul>
<li>Its own state transition arguments</li>
<li>The Merkle path to the root <code>R</code></li>
<li>Any dependent state from other chains</li>
</ul>
<p>For example, Chain 2 only needs <code>C1</code> and <code>M2</code> for its Merkle proof, not the complete state data from Chains 1 and 3.</p>
<h3 id="on-chain-proof-distribution"><a class="header" href="#on-chain-proof-distribution">On-Chain Proof Distribution</a></h3>
<p>Each chain receives the minimal data needed for verification:</p>
<ul>
<li><strong>Chain 1</strong>: <code>(R1, T1)</code></li>
<li><strong>Chain 2</strong>: <code>(R2, T2)</code></li>
<li><strong>Chain 3</strong>: <code>(R3, T3, R1, T1, C2)</code></li>
</ul>
<p>Chain 3's verification process includes:</p>
<ol>
<li>Verify its own transition: <code>verify(R3, T3)</code></li>
<li>Verify the dependency: <code>verify(R1, T1)</code></li>
<li>Query the foreign state: <code>query(T1)</code></li>
<li>Reconstruct the commitments and validate the Merkle root</li>
</ol>
<p>This architecture enables the Valence Coprocessor to securely and efficiently coordinate complex cross-chain programs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="authorization--processors"><a class="header" href="#authorization--processors">Authorization &amp; Processors</a></h1>
<p>The <strong>Authorization</strong> and <strong>Processor</strong> contracts are foundational pieces of the <strong>Valence Protocol</strong>, as they enable on-chain (and cross-chain) execution of <strong>Valence Programs</strong> and enforce access control to the program's <strong>Subroutines</strong> via <strong>Authorizations</strong>.</p>
<p>This section explains the rationale for these contracts and shares insights into their technical implementation, as well as how end-users can interact with <strong>Valence Programs</strong> via <strong>Authorizations</strong>.</p>
<h2 id="rationale"><a class="header" href="#rationale">Rationale</a></h2>
<ul>
<li>To have a general purpose set of smart contracts that provide users with a single point of entry to interact with the Valence Program, which can have libraries and accounts deployed on multiple chains.</li>
<li>To have all the user authorizations for multiple domains in a single place, making it very easy to control the application.</li>
<li>To have a single address (Processor) that will execute the messages for all the contracts in a domain using execution queues.</li>
<li>To only tick a single contract (Processor) that will go through the queues to route and execute the messages.</li>
<li>To create, edit, or remove different application permissions with ease.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assumptions"><a class="header" href="#assumptions">Assumptions</a></h1>
<ul>
<li>
<p><strong>Funds</strong>: You cannot send funds with the messages.</p>
</li>
<li>
<p><strong>Bridging</strong>: We are assuming that messages can be sent and confirmed bidirectionally between domains. The Authorization contract on the main domain communicates with the processor in a different domain in one direction and the callback confirming the correct or failed execution in the other direction.</p>
</li>
<li>
<p><strong>Instantiation</strong>: All these contracts can be instantiated beforehand and off-chain having predictable addresses. Here is an example instantiation flow using Polytone:</p>
<ul>
<li>Predict <code>authorization</code> contract address.</li>
<li>Instantiate polytone contracts &amp; set up relayers.</li>
<li>Predict <code>proxy</code> contract address for the <code>authorization</code> contract on each external domain.</li>
<li>Predict <code>proxy</code> contract address on the main domain for each processor on external domains.</li>
<li>Instantiate all <code>processors</code>. The sender on external domains will be the predicted <code>proxy</code> and on the main domain it will be the Authorization contract iself.</li>
<li>Instantiate Authorization contract with all the processors and their predicted proxies for external domains and the processor on the main domain.</li>
</ul>
</li>
<li>
<p><strong>Relaying</strong>: Relayers will be running once everything is instantiated.</p>
</li>
<li>
<p><strong>Tokenfactory</strong>: The main domain has the token factory module with no token creation fee so that we can create and mint these nonfungible tokens with no additional cost.</p>
</li>
<li>
<p><strong>Domains</strong>: In the current version, actions in each authorization will be limited to a single domain.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="authorization-contract"><a class="header" href="#authorization-contract">Authorization Contract</a></h1>
<p>The Authorization contract will be a single contract deployed on the main domain and that will define the authorizations of the top-level application, which can include libraries in different domains (chains). For each domain, there will be one Processor in charge of executing the functions on the libraries. The Authorization contract will connect to all of the Processor contracts using a connector (e.g. Polytone Note, Hyperlane Mailbox‚Ä¶) and will route the message batches to be executed to the right domain. At the same time, for each external domain, we will have a proxy contract (e.g. Polytone Proxy, Hyperlane Mailbox...) in the main domain which will receive the callbacks sent from the processor on the external domain with the <code>ExecutionResult</code> of the <code>MessageBatch</code>.</p>
<p>The contract will be instantiated once at the very beginning and will be used during the entire top-level application lifetime. Users will never interact with the individual Smart Contracts of each program, but with the Authorization contract directly.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="instantiation-1"><a class="header" href="#instantiation-1">Instantiation</a></h1>
<p>When the contract is instantiated, it will be provided the following information:</p>
<ul>
<li>
<p>Processor contract on main domain.</p>
</li>
<li>
<p>Owner of the contract.</p>
</li>
<li>
<p>List of subowners (if any). Users that can execute the same actions as the owner except adding/removing other subowners.</p>
</li>
</ul>
<p>Once the Authorization contract is deployed, we can already start adding and executing authorizations on the domain that the Authorization contract was deployed on. To execute functions on other domains, the owner will have to add external domains to the Authorization contract with all the information required for the Authorization contract to route the messages to that domain.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="owner-functions"><a class="header" href="#owner-functions">Owner Functions</a></h1>
<ul>
<li>
<p><code>create_authorizations(vec[Authorization])</code>: provides an authorization list which is the core information of the Authorization contract, it will include all the possible set of functions that can be executed. It will contain the following information:</p>
<ul>
<li>
<p>Label: unique name of the authorization. This label will be used to identify the authorization and will be used as subdenom of the tokenfactory token in case it is permissioned. Due to tokenfactory module restrictions, the max length of this field is 44 characters.
Example: If the label is <code>withdraw</code> and only address <code>neutron123</code> is allowed to execute this authorization, we will create the token <code>factory/&lt;contract_addr&gt;/withdraw</code> and mint one to that address. If <code>withdraw</code> was permissionless, there is no need for any token, so it's not created.</p>
</li>
<li>
<p>Mode: can either be <code>Permissioned</code> or <code>Permissionless</code>. If <code>Permissionless</code> is chosen, any address can execute this function list. In case of <code>Permissioned</code>, we will also say what type of permissioned type we want (with <code>CallLimit</code> or without), a list of addresses will be provided for both cases. In case there is a <code>CallLimit</code> we will mint a certain amount of tokens for each address that is passed, in case there isn‚Äôt we will only mint one token and that token will be used all the time.</p>
</li>
<li>
<p>NotBefore: from what time the authorization can be executed. We can specify a block height or a timestamp.</p>
</li>
<li>
<p>Expiration: until when (what block or timestamp) this authorization is valid.</p>
</li>
<li>
<p>MaxConcurrentExecutions (default 1): to avoid DDoS attacks and to clog the execution queues, we will allow certain authorizations subroutines to be present a maximum amount of times (default 1 unless overwritten) in the execution queue.</p>
</li>
<li>
<p>Subroutine: set of functions in a specific order to be executed. Subroutines can be of two types: <code>Atomic</code> or <code>NonAtomic</code>. For the <code>Atomic</code> subroutines, we will provide an array of <code>Atomic</code> functions, an optional <code>expiration_time</code> and an optional <code>RetryLogic</code> for the entire subroutine. For the <code>NonAtomic</code> subroutines we will just provide an array of <code>NonAtomic</code> functions and an optional <code>expiration_time</code>. The <code>expiration_time</code> defines how long messages that are executing a subroutine will be valid for once they are sent from the authorization contract. This is particularly useful for domains that use relayers without timeouts (e.g. Hyperlane). If the <code>expiration_time</code> is not provided, the relayer can go down for an indefinite amount of time and the messages will still be valid and execute when it's back up. If the <code>expiration_time</code> is provided, the messages will be valid for that amount of time, by adding the current block timestamp to the <code>expiration_time</code>, and if the relayer is down for longer than that, the messages will be considered expired once the execution is attempted in the Processor contract, returning an <code>Expired</code> result.</p>
<ul>
<li>
<p><code>AtomicFunction</code>: each Atomic function has the following parameters:</p>
<ul>
<li>
<p>Domain of execution (must be the same for all functions in v1).</p>
</li>
<li>
<p>MessageDetails: type (e.g. CosmwasmExecuteMsg, EvmCall ...) and message information. Depending on the type of the message that is being sent, we might need to provide additional values and/or only some specific <code>ParamRestrictions</code> can be applied:</p>
<ul>
<li>If we are sending messages that are not for a <code>CosmWasm ExecutionEnvironment</code> and the message passed doesn't contain Raw bytes for that particular VM (e.g. <code>EvmRawCall</code>), we need to provide the <code>Encoder</code> information for that message along with the name of the library that the <code>Encoder</code> will use to encode that message. For example, if we are sending a message for an <code>EvmCall</code> on an EVM domain, we need to provide the address of the <code>Encoder Broker</code> and the <code>version</code> of the <code>Encoder</code> that the broker needs to route the message to along with the name of the library that the <code>Encoder</code> will use to encode that message (e.g. <code>forwarder</code>).</li>
<li>For all messages that are not raw bytes (<code>json</code> formatted), we can apply any of the following <code>ParamRestrictions</code>:
<ul>
<li><code>MustBeIncluded</code>: the parameter must be included in the message.</li>
<li><code>CannotBeIncluded</code>: the parameter cannot be included in the message.</li>
<li><code>MustBeValue</code>: the parameter must have a specific value.</li>
</ul>
</li>
<li>For all messages that are raw bytes, we can only apply the <code>MustBeBytes</code> restriction, which matches that the bytes sent are the same as the ones provided in restriction, limiting the authorization execution to only one specific message.</li>
</ul>
</li>
<li>
<p>Contract address that will execute it.</p>
</li>
</ul>
</li>
<li>
<p><code>NonAtomicFunction</code>: each NonAtomic function has the following parameters:</p>
<ul>
<li>
<p>Domain of execution</p>
</li>
<li>
<p>MessageDetails (same as above).</p>
</li>
<li>
<p>Contract address that will execute it.</p>
</li>
<li>
<p>RetryLogic (optional, self-explanatory).</p>
</li>
<li>
<p>CallbackConfirmation (optional): This defines if a <code>NonAtomicFunction</code> is completed after receiving a callback (Binary) from a specific address instead of after a correct execution. This is used in case of the correct message execution not being enough to consider the message completed, so it will define what callback we should receive from a specific address to flag that message as completed. For this, the processor will append an <code>execution_id</code> to the message which will be also passed in the callback by the service to identify what function this callback is for.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Priority (default Med): priority of a set of functions can be set to High. If this is the case, they will go into a preferential execution queue. Messages in the <code>High</code> priority queue will be taken over messages in the <code>Med</code> priority queue.
All authorizations will have an initial state of <code>Enabled</code> .</p>
</li>
</ul>
<p>Here is an example of an Authorization table after its creation:</p>
<p><img src="authorizations_processors/../img/authorization_table.png" alt="Authorization Table" /></p>
</li>
<li>
<p><code>add_external_domains([external_domains])</code>: to add an <code>ExternalDomain</code> to the Authorization contract, the owner will specify what type of <code>ExecutionEnvironment</code> it has (e.g. <code>CosmWasm</code>, <code>Evm</code>...) and all the information required for each type of <code>ExecutionEnvironment</code>. For example, if the owner is adding a domain that uses <code>CosmWasm</code> as ExecutionEnvironment, they need to provide all the Polytone information; if they are adding a domain that uses <code>EVM</code> as ExecutionEnvironment, they need to provide all the Hyperlane information and the <code>Encoder</code> to be used for correctly encoding messages in the corresponding format.</p>
</li>
<li>
<p><code>modify_authorization(label, updated_values)</code>: can modify certain updatable fields of the authorization: start_time, expiration, max_concurrent_executions and priority.</p>
</li>
<li>
<p><code>disable_authorization(label)</code>: puts an Authorization to state <code>Disabled</code>. These authorizations can not be run anymore.</p>
</li>
<li>
<p><code>enable_authorization(label)</code>: puts an Authorization to state <code>Enabled</code> so that they can be run again.</p>
</li>
<li>
<p><code>mint_authorization(label, vec[(addresses, Optional: amounts)])</code>: if the authorization is <code>Permissioned</code> with <code>CallLimit: true</code>, this function will mint the corresponding token amounts of that authorization to the addresses provided. If <code>CallLimit: false</code> it will mint 1 token to the new addresses provided.</p>
</li>
<li>
<p><code>pause_processor(domain)</code>: pause the processor of the domain.</p>
</li>
<li>
<p><code>resume_processor(domain)</code>: resume the processor of the domain.</p>
</li>
<li>
<p><code>insert_messages(label, queue_position, queue_type, vec[ProcessorMessage])</code>: adds these set of messages to the queue at a specific position in the queue.</p>
</li>
<li>
<p><code>evict_messages(label, queue_position, queue_type)</code>: remove the set of messages from the specific position in a queue.</p>
</li>
<li>
<p><code>add_sub_owners(vec[addresses])</code>: add the current addresses as 2nd tier owners. These sub_owners can do everything except adding/removing admins.</p>
</li>
<li>
<p><code>remove_sub_owners(vec[addresses])</code>: remove these addresses from the sub_owner list.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="user-actions"><a class="header" href="#user-actions">User Actions</a></h1>
<ul>
<li>
<p><code>send_msgs(label, vec[ProcessorMessage])</code>: users can run an authorization with a specific label. If the authorization is <code>Permissioned (without limit)</code>, the Authorization contract will check if their account is allowed to execute by checking that the account holds the token in its wallet. If the authorization is <code>Permissioned (with limit)</code> the account must attach the authorization token to the contract execution. Along with the authorization label, the user will provide an array of encoded messages, together with the message type (e.g. <code>CosmwasmExecuteMsg</code>, <code>EvmCall</code>, etc.) and any other parameters for that specific ProcessorMessage (e.g. for a <code>CosmwasmMigrateMsg</code> we need to also pass a code_id). The contract will then check that the messages match those defined in the authorization, that the messages appear in correct order, and that any applied parameter restrictions are correct.</p>
<p>If all checks are correct, the contract will route the messages to the correct Processor with an <code>execution_id</code> for the processor to callback with. This <code>execution_id</code> is unique for the entire application.
If execution of all actions is confirmed via a callback, the authorization token is burned. If execution fails, the token is sent back.
Here is an example flowchart of how a user interacts with the Authorization contract to execute functions on an external CosmWasm domain that is connected to the main domain with Polytone:</p>
</li>
</ul>
<p><img src="authorizations_processors/../img/user_flowchart.png" alt="User flowchart" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="processor-contract"><a class="header" href="#processor-contract">Processor Contract</a></h1>
<p>The Processor will be a contract on each domain within the program. The Processor handles execution of message batches it receives from the Authorization contract.
Depending on the Processor type in use, its features will vary. There are currently two types of processors: Lite Processor and Processor. The former is a simplified version of the latter. The Lite Processor has limited functionality to optimize for gas-constrained domains.</p>
<p>The Processor will be instantiated in advance with the correct address that can send messages to them, according to the <em>InstantiationFlow</em> described in the <a href="authorizations_processors/assumptions.html">Assumptions</a> section.</p>
<p>In the table below we summarize the main characteristics of the processors supported:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th>Processor</th><th>Lite Processor</th></tr></thead><tbody>
<tr><td><strong>Execution Environment</strong></td><td>CosmWasm</td><td>EVM</td></tr>
<tr><td><strong>Stores batches in queues</strong></td><td>Yes, FIFO queue with priority</td><td>No, executed immediately by relayer</td></tr>
<tr><td><strong>Needs to be ticked</strong></td><td>Yes, permissionlessly</td><td>No</td></tr>
<tr><td><strong>Messages can be retried</strong></td><td>Yes</td><td>No</td></tr>
<tr><td><strong>Can confirm non-atomic function with callback</strong></td><td>Yes</td><td>No</td></tr>
<tr><td><strong>Supports Pause operation</strong></td><td>Yes</td><td>Yes</td></tr>
<tr><td><strong>Supports Resume operation</strong></td><td>Yes</td><td>Yes</td></tr>
<tr><td><strong>Supports SendMsgs operation</strong></td><td>Yes</td><td>Yes</td></tr>
<tr><td><strong>Supports InsertMsgs operation</strong></td><td>Yes</td><td>No, no queues to insert in</td></tr>
<tr><td><strong>Supports EvictMsgs operation</strong></td><td>Yes</td><td>No, no queues to remove from</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="processor"><a class="header" href="#processor">Processor</a></h1>
<p>This version of the processor is currently available for <code>CosmWasm</code> Execution Environment only. It contains all the features and full functionality of the processor as described below.</p>
<p>It handles two execution queues: <code>High</code> and <code>Med</code>, which allow giving different priorities to message batches. The Authorization contract will send the message batches to the Processor specifying the priority of the queue where they should be enqueued.</p>
<p>The Processor can be <code>ticked</code> permissionlessly, which will trigger the execution of the message batches in the queues in a <code>FIFO</code> manner. It will handle the <code>Retry</code> logic for each batch (if the batch is atomic) or function (if the batch is non-atomic). In the particular case that the current batch at the top of the queue is not retriable yet, the processor will rotate it to the back of the queue. After a <code>MessageBatch</code> has been executed successfully or it reached the maximum amount of retries, it will be removed from the execution queue and the Processor will send a callback with the execution information to the Authorization contract.</p>
<p>The Authorization contract will be the only address allowed to add message batches to the execution queues. It will also be allowed to Pause/Resume the Processor or to arbitrarily remove functions from the queues or add certain messages at a specific position in any of them.</p>
<h3 id="execution"><a class="header" href="#execution">Execution</a></h3>
<p>When a processor is <code>Ticked</code>, the first <code>Message Batch</code> will be taken from the queue (<code>High</code> if there are batches there or <code>Med</code> if there aren‚Äôt).
After taking the <code>Message Batch</code>, the processor will first check if the batch is expired. If that's the case, the processor will discard the batch and return an <code>Expired(executed_functions)</code> <code>ExecutionResult</code> to the Authorization contract. There might be a case that the batch is <code>NonAtomic</code> and it's already partially executed, therefore the processor also returns the number of functions that were executed before the expiration.
If the batch has not expired, the processor will execute the batch according to whether it is <code>Atomic</code> or <code>NonAtomic</code>.</p>
<ul>
<li>
<p>For <code>Atomic</code> batches, the Processor will execute either all functions or none of them. If execution fails, the batch <code>RetryLogic</code> is checked to determine if the match should be re-enqueued. If not, a callback is sent with a <code>Rejected(error)</code> status to the Authorization contract.
If the execution succeeded we will send a callback with <code>Executed</code> status to the Authorization contract.</p>
</li>
<li>
<p>For <code>NonAtomic</code> batches, we will execute the functions one by one and applying the RetryLogic individually to each function if they fail. <code>NonAtomic</code> functions might also be confirmed via <code>CallbackConfirmations</code> in which case we will keep them in a separate storage location until we receive that specific callback.
Each time a function is confirmed, we will re-queue the batch and keep track of what function we have to execute next.
If at some point a function uses up all its retries, the processor will send a callback to the Authorization contract with a <code>PartiallyExecuted(num_of_functions_executed, execution_error)</code> execution result if some succeeded or <code>Rejected(error)</code> if none did. If all functions are executed successfully, an <code>Executed</code> execution result will be sent.
For <code>NonAtomic</code> batches, the processor must be ticked each time the batch is at the top of the queue to continue, so at least as many ticks will be required as the number of functions in the batch.</p>
</li>
</ul>
<h3 id="storage"><a class="header" href="#storage">Storage</a></h3>
<p>The Processor will receive message batches from the Authorization contract and will enqueue them in a custom storage structure called a <code>QueueMap</code>. This structure is a FIFO queue with owner privileges, which allow the owner to insert or remove messages from any position in the queue.
Each ‚Äúitem‚Äù stored in the queue is a <code>MessageBatch</code> object that has the following structure:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct MessageBatch {
    pub id: u64,
    pub msgs: Vec&lt;ProcessorMessage&gt;,
    pub subroutine: Subroutine,
    pub priority: Priority,
    pub retry: Option&lt;CurrentRetry&gt;,
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>id: represents the global id of the batch. The Authorization contract, to understand the callbacks that it will receive from each processor, identifies each batch with an id. This id is unique for the entire application.</li>
<li>msgs: the messages the processor needs to execute for this batch (e.g. a CosmWasm ExecuteMsg or MigrateMsg).</li>
<li>subroutine: This is the config that the authorization table defines for the execution of these functions. With this field we can know if the functions need to be executed atomically or not atomically, for example, and the retry logic for each batch/function depending on the config type.</li>
<li>priority (for internal use): batches will be queued in different priority queues when they are received from the Authorization contract. We also keep this priority here because they might need to be re-queued after a failed execution and we need to know where to re-queue them.</li>
<li>retry (for internal use): we are keeping the current retry we are at (if the execution previously failed) to know when to abort if we exceed the max retry amounts.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lite-processor"><a class="header" href="#lite-processor">Lite Processor</a></h1>
<p>This is a simplified version of the <a href="authorizations_processors/processor.html">Processor</a> contract, with more limited functionality that is optimized for specific domains where gas costs are critical. This version of the processor is currently available for <code>EVM</code> execution environments only.</p>
<p>The main difference between the Lite Processor and the Processor is that the former does not store message batches, but instead executes messages directly when received. The Lite Processor does not handle retries, function callbacks, or queues. More details can be found below.</p>
<h3 id="execution-1"><a class="header" href="#execution-1">Execution</a></h3>
<p>The Lite Processor is not <code>ticked</code>, instead it will receive a <code>MessageBatch</code> from the Authorization contract and execute it immediately. Therefore, the execution gas cost will be paid by the relayer of the batch instead of the user who ticks the processor.
There might be a case that the <code>MessageBatch</code> received is already expired, which can happen if the relayer was not working or was slow to send the batch. In this case, the Processor will discard the batch and return an <code>Expired(0)</code> <code>ExecutionResult</code> to the Authorization contract.</p>
<p>This processor does not store batches or use any queue, instead it will simply receive the batch, execute it atomically or non-atomically, and send a callback to the Authorization contract with the <code>ExecutionResult</code>. The only information stored by this processor is the information of the Authorization contract, the information of the Connector (e.g. Hyperlane Mailbox, origin domain id, ...) and the authorized entities that can also execute batches on it without requiring them to be sent from the main domain.</p>
<p>Since there are no queues, operations like <code>InsertAt</code> or <code>RemoveFrom</code> queue that the owner of the Authorization Contract may perform on the Processor are not available on the Lite Processor. Therefore the operations that the Lite Processor supports from the Authorization contract are limited to: <code>Pause</code>, <code>Resume</code> and <code>SendMsgs</code>.</p>
<p>In addition to the limitations above, the Lite Processor does not support retries or function callbacks. This means that the <code>MessageBatch</code> received will be executed only once and the <code>NonAtomic</code> batches can not be confirmed asynchronously because batch execution will be attempted once, non-atomically, the moment it is received.</p>
<p>In addition to executing batches that come from the Authorization contract, the Lite Processor defines a set of authorized addresses that can send batches to it for execution. Since the Processor can execute batches from any address, we only send a callback if the address that sent the batch is a smart contract. Thus the authorized addresses are in charge of the handling/ignoring of these callbacks.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="execution-environment-differences"><a class="header" href="#execution-environment-differences">Execution Environment Differences</a></h1>
<p>Depending on the type of <code>ExecutionEnvironment</code> being used, the behavior of the Processor may vary. In this section we will describe the main differences in how the Processor behaves in the different execution environments that we support.</p>
<h3 id="execution-success"><a class="header" href="#execution-success">Execution Success</a></h3>
<p>During the execution of a <code>MessageBatch</code>, the Processor will execute each function of the subroutine of that batch. If the execution for a specific function fails, we will consider the execution failed in case of <code>Atomic</code> batches, and we will stop the execution of the next function in case of <code>NonAtomic</code> batches.</p>
<p>Currently, in the <code>CosmWasm</code> execution environment, a function fails if the <code>CosmWasm</code> contract that we are targeting doesn't exist, if the <code>entry point</code> of that contract doesn't exist, or if the execution of the contract fails for any reason. On the contract, in the <code>EVM</code> execution environment, a function only fails if the contract explicitly fails or reverts.</p>
<p>To mitigate the differences in behavior between these two execution environments, an <code>EVM</code> Processor check was included to check if the contract indeed exists and fail execution if the contract does not exist. Behavior was also added in the <code>EVM</code> libraries to revert if the execution of the contract enters the fallback function, which is not allowed in the system. Nevertheless, since Processors are not restricted to <code>Valence Libraries</code> but can call any contract, no guarantee can be made that the contract targeted will fail if an entry point does not exist, because the fallback function might not be defined or might not revert.</p>
<p>In <code>CosmWasm</code>, execution of a contract will always fail if the entry point does not exist. However, for <code>EVM</code> execution, this is not necessarily the case. This is a difference that the owner of the program must take into account when designing and creating their program.</p>
<p><strong><em>In summary</em></strong>: if a function of the subroutine targets a contract that meets all of the following conditions:</p>
<ul>
<li>It is not a <code>Valence Library</code>.</li>
<li>The entry point of that contract does not exist.</li>
<li>The fallback function is either not defined or doesn't explicitly revert.</li>
</ul>
<p>The execution of that function will be considered successful in the <code>EVM</code> execution environment but not in the <code>CosmWasm</code> execution environment equivalent.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="callbacks"><a class="header" href="#callbacks">Callbacks</a></h1>
<p>There are different types of callbacks in our application. Each of them have a specific function and are used in different parts of the application.</p>
<h2 id="function-callbacks"><a class="header" href="#function-callbacks">Function Callbacks</a></h2>
<p>For the execution of <code>NonAtomic</code> batches, each function in the batch can optionally be confirmed with a callback from a specific address. When the processor reaches a function that requires a callback, it will inject the execution_id of the batch into the message that is going to be executed on the library, which means that the library needs to be ready to receive that execution_id and know what the expected callback is and from where it has to come from to confirm that function, otherwise that function will stay unconfirmed and the batch will not move to the next function. The callback will be sent to the processor with the execution_id so that the processor can know what function is being confirmed. The processor will then validate that the correct callback was received from the correct address.</p>
<p>If the processor receives the expected callback from the correct address, the batch will move to the next function. If it receives a different callback than expected from that address, the execution of that function is considered to have failed and it will be retried (if applicable). In either case, a callback must be received to determine if the function was successful or not.</p>
<p>Note: This functionality is not available on the Lite Processor, as this version of the processor is not able to receive asynchronous callbacks from libraries.</p>
<h2 id="processor-callbacks"><a class="header" href="#processor-callbacks">Processor Callbacks</a></h2>
<p>Once a Processor batch is executed or it fails and there are no more retries available, the Processor will send a callback to the Authorizations contract with the execution_id of the batch and the result of the execution. All this information will be stored in the Authorization contract state so the history of all executions can be queried from it. This is how a <code>ProcessorCallback</code> looks like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ProcessorCallbackInfo {
    // Execution ID that the callback was for
    pub execution_id: u64,
    // Timestamp of entry creation
    pub created_at: u64,
    // Timestamp of last update of this entry
    pub last_updated_at: u64,
    // Who started this operation, used for tokenfactory actions
    pub initiator: OperationInitiator,
    // Address that can send a bridge timeout or success for the message (if applied)
    pub bridge_callback_address: Option&lt;Addr&gt;,
    // Address that will send the callback for the processor
    pub processor_callback_address: Addr,
    // Domain that the callback came from
    pub domain: Domain,
    // Label of the authorization
    pub label: String,
    // Messages that were sent to the processor
    pub messages: Vec&lt;ProcessorMessage&gt;,
    // Optional ttl for re-sending in case of bridged timeouts
    pub ttl: Option&lt;Expiration&gt;,
    // Result of the execution
    pub execution_result: ExecutionResult,
}

#[cw_serde]
pub enum ExecutionResult {
    InProcess,
    // Everthing executed successfully
    Success,
    // Execution was rejected, and the reason
    Rejected(String),
    // Partially executed, for non-atomic function batches
    // Indicates how many functions were executed and the reason the next function was not executed
    PartiallyExecuted(usize, String),
    // Removed by Owner - happens when, from the authorization contract, a remove item from queue is sent
    RemovedByOwner,
    // Timeout - happens when the bridged message times out
    // We'll use a flag to indicate if the timeout is retriable or not
    // true - retriable
    // false - not retriable
    Timeout(bool),
    // Expired - happens when the batch wasn't executed in time according to the subroutine configuration
    // Indicates how many functions were executed (non-atomic batches might have executed some functions before the expiration)
    Expired(usize),
    // Unexpected error that should never happen but we'll store it here if it ever does
    UnexpectedError(String),
}
<span class="boring">}</span></code></pre></pre>
<p>The key information from here is the <code>label</code>, to identify the authorization that was executed; the <code>messages</code>, to identify what the user sent; and the <code>execution_result</code>, to know if the execution was successful, partially successful or rejected.</p>
<h2 id="bridge-callbacks"><a class="header" href="#bridge-callbacks">Bridge Callbacks</a></h2>
<p>When messages need to be sent through bridges because we are executing batches on external domains, we need to know if, for example, a timeout happened and keep track of it. For this reason we have callbacks per bridge that we support and specific logic that will be executed if they are received. For <code>Polytone</code> timeouts, we will check if the <code>ttl</code> field has not expired and allow permissionless retries if it's still valid. In case the <code>ttl</code> has expired, we will set the ExecutionResult to timeout and not retriable, then send the authorization token back to the user if the user sent it to execute the authorization.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="connectors"><a class="header" href="#connectors">Connectors</a></h1>
<p>Connectors are a way for the Authorization contract in the main domain to interact with external domains. When adding an <code>ExternalDomain</code> to the Authorization contract, depending on the <code>ExecutionEnvironment</code> we must specify the Connector information to be used. These connectors are responsible for receiving the message batches from the Authorization contract and trigger the necessary actions for the relayers to pick them up and deliver them to the Processor contract in the <code>ExternalDomain</code>. The connector on the <code>ExternalDomain</code> will also receive callbacks with the <code>ExecutionResult</code> from the Processor contract and send them back to the Authorization contract.</p>
<p>We currently support the following connectors:</p>
<h3 id="polytone"><a class="header" href="#polytone">Polytone</a></h3>
<p>To connect <code>ExternalDomains</code> that use <code>CosmWasm</code> as <code>ExecutionEnvironment</code> we use <a href="https://github.com/DA0-DA0/polytone">Polytone</a>. Polytone is a set of smart contracts that are instantiated on both domains that implement logic to pass messages to each other using IBC. Polytone consists of the following contracts:</p>
<ul>
<li>Polytone Note: contract responsible of sending the messages from the Authorization contract to the Processor contract on the external domain and receiving the callback from the Processor contract on the external domain and sending it back to the Authorization contract.</li>
<li>Polytone Voice: contract that receives the message from Polytone Note and instantiates a Polytone Proxy for each sender that will redirect the message to the destination.</li>
<li>Polytone Proxy: contract instantiated by Polytone Voice responsible for sending messages received from Polytone Note to the corresponding contract.</li>
</ul>
<p>To connect the Authorization contract with an external domain that uses Polytone as a connector, we need to provide the Polytone Note address and the predicted Polytone Proxy addresses for both the Authorization contract (when adding the domain) and the Processor Contract (when instantiating the Processor). An IBC relayer must relay these two channels to enable communication.</p>
<p>This is the sequence of messages when using Polytone as a connector:</p>
<pre class="mermaid">graph TD
  %% Execution Result Sequence
  subgraph Execution_Sequence [Execution Result Sequence]
    E2[Processor Contract]
    D2[Polytone Note on
    External Domain]
    C2[Polytone Voice on
    Main Domain]
    B2[Polytone Proxy on
    Main Domain]
    A2[Authorization Contract]

    E2 --&gt;|Step 5: Execution Result| D2
    D2 --&gt;|Step 6: Relayer| C2
    C2 --&gt;|Step 7: Instantiate &amp; Forward Result| B2
    B2 --&gt;|Step 8: Execution Result| A2
  end

  %% Message Batch Sequence
  subgraph Batch_Sequence [Message Batch Sequence]
    A1[Authorization Contract]
    B1[Polytone Note on
    Main Domain]
    C1[Polytone Voice on
    External Domain]
    D1[Polytone Proxy on
    External Domain]
    E1[Processor Contract]

    A1 --&gt;|Step 1: Message Batch| B1
    B1 --&gt;|Step 2: Relayer| C1
    C1 --&gt;|Step 3: Instantiate &amp; Forward Batch| D1
    D1 --&gt;|Step 4: Message Batch| E1
  end
</pre>
<h3 id="hyperlane"><a class="header" href="#hyperlane">Hyperlane</a></h3>
<p>To connect <code>ExternalDomains</code> that use <code>EVM</code> as <code>ExecutionEnvironment</code> we use <a href="https://github.com/hyperlane-xyz/hyperlane-monorepo">Hyperlane</a>. Hyperlane is a set of smart contracts that are deployed on both domains and communicate with one another using the <code>Hyperlane Relayer</code>. The required Hyperlane contracts are the following:</p>
<ul>
<li>Mailbox: contract responsible for receiving the message for another domain and emitting an event with the message to be picked up by the relayer. The mailbox will also receive messages to be executed on a domain from the relayers and will route them to the correct destination contract.</li>
</ul>
<p>To connect the Authorization contract with an external domain that uses Hyperlane as a connector, we need to provide the Mailbox address for both the Authorization contract (when adding the domain) and the Processor contract (when instantiating the Processor). A Hyperlane Relayer must relay these two domains using the Mailbox addresses to make the communication possible.</p>
<p>NOTE: There are other Hyperlane contracts that need to be used to set-up Hyperlane, but they are not used in the context of the Authorization contract or the Processor. For more information on how this works, check Hyperlane's documentation or see the <a href="https://github.com/timewave-computer/valence-protocol/blob/main/e2e/examples/ethereum_integration_tests.rs">Ethereum integration tests</a> we have, where we set up all the required Hyperlane contracts and the relayer in advance before creating our EVM Program.</p>
<p>This is the sequence of messages when using Hyperlane as a connector:</p>
<pre class="mermaid">graph TD
  %% Execution Result Sequence
  subgraph Execution_Sequence [Execution Result Sequence]
    E2[Processor Contract]
    D2[Mailbox on
    External Domain]
    C2[Mailbox on
    Main Domain]
    B2[Authorization Contract]

    E2 --&gt;|Step 5: Execution Result| D2
    D2 --&gt;|Step 6: Relayer| C2
    C2 --&gt;|Step 7: Execution Result| B2
  end

  %% Message Batch Sequence
  subgraph Batch_Sequence [Message Batch Sequence]
    A1[Authorization Contract]
    B1[Mailbox on
    Main Domain]
    C1[Mailbox on
    External Domain]
    D1[Processor Contract]

    A1 --&gt;|Step 1: Message Batch| B1
    B1 --&gt;|Step 2: Relayer| C1
    C1 --&gt;|Step 3: Message Batch| D1
  end
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="encoding"><a class="header" href="#encoding">Encoding</a></h1>
<p>When messages are passed between the Authorization contract and a Processor contract on a domain that is not using a CosmWasm <code>ExecutionEnvironment</code>, we need to encode the messages in a way that the Processor contract and the Libraries it calls can understand them. To do this two new contracts were created: <code>Encoder Broker</code> and <code>Encoder</code>.</p>
<h2 id="encoder-broker"><a class="header" href="#encoder-broker">Encoder Broker</a></h2>
<p>The <code>Encoder Broker</code> is a very simple contract that will route the messages to the correct <code>Encoder</code> contract. It maps from <code>Encoder Version</code> to <code>Encoder Contract Address</code>. The <code>Encoder Broker</code> will be instantiated once on the <code>Main Domain</code> with an owner that can add/remove these mappings. An example of Mapping can be <code>"evm_encoder_v1"</code> to <code>&lt;encoder_contract_address_on_neutron&gt;</code>. The <code>Encoder Broker</code> has two queries: <code>Encode</code> and <code>Decode</code>, which routes the message to encode/decode to the <code>Encoder Version</code> specified.</p>
<h2 id="encoder"><a class="header" href="#encoder">Encoder</a></h2>
<p>The <code>Encoder</code> is the contract that will encode/decode the messages for a specific <code>ExecutionEnvironment</code>. It will be instantiated on the <code>Main Domain</code> an added to the <code>Encoder Broker</code> with a version. <code>Encoders</code> are defined for a specific <code>ExecutionEnvironment</code> and have an <code>Encode</code> and <code>Decode</code> query where we provide the Message to be encoded/decoded. Here is an example of how these queries are performed:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn encode(message: ProcessorMessageToEncode) -&gt; StdResult&lt;Binary&gt; {
    match message {
        ProcessorMessageToEncode::SendMsgs {
            execution_id,
            priority,
            subroutine,
            messages,
        } =&gt; send_msgs::encode(execution_id, priority, subroutine, messages),
        ProcessorMessageToEncode::InsertMsgs {
            execution_id,
            queue_position,
            priority,
            subroutine,
            messages,
        } =&gt; insert_msgs::encode(execution_id, queue_position, priority, subroutine, messages),
        ProcessorMessageToEncode::EvictMsgs {
            queue_position,
            priority,
        } =&gt; evict_msgs::encode(queue_position, priority),
        ProcessorMessageToEncode::Pause {} =&gt; Ok(pause::encode()),
        ProcessorMessageToEncode::Resume {} =&gt; Ok(resume::encode()),
    }
}

fn decode(message: ProcessorMessageToDecode) -&gt; StdResult&lt;Binary&gt; {
    match message {
        ProcessorMessageToDecode::HyperlaneCallback { callback } =&gt; {
            Ok(hyperlane::callback::decode(&amp;callback)?)
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>As we can see above, the <code>Encoder</code> will have a match statement for each type of message that it can encode/decode. The <code>Encoder</code> will be able to encode/decode messages for a specific <code>ExecutionEnvironment</code>. In the case of <code>ProcessorMessages</code> that include messages for a specific library, these messages will include the Library they are targeting. This allows the <code>Encoder</code> to apply the encoding/decoding logic for that specific library.
This <code>Encoder</code> will be called internally through the Authorization contract when the user sends a message to it. Here is an example of this execution flow:</p>
<ol>
<li>The owner adds an <code>ExternalDomain</code> with an <code>EVM ExecutionEnvironment</code> to the Authorization contract, specifying the <code>Encoder Broker</code> address and the <code>Encoder Version</code> to be used.</li>
<li>The owner creates an authorization with a subroutine with an <code>AtomicFunction</code> that is of <code>EvmCall(EncoderInfo, LibraryName)</code> type.</li>
<li>A user executes this authorization passing the message. The Authorization contract will route the message to the <code>Encoder Broker</code> with the <code>Encoder Version</code> specified in <code>EncoderInfo</code> and passing the <code>LibraryName</code> to be used for the message.</li>
<li>The <code>Encoder Broker</code> will route the message to the correct <code>Encoder</code> contract, which will encode the message for that particular library and return the encoded bytes to the Authorization Contract.</li>
<li>The Authorization contract will send the encoded message to the Processor contract on the <code>ExternalDomain</code>, which will be able to decode and interpret the message.</li>
</ol>
<p>We currently have an <code>Encoder</code> for <code>EVM</code> messages, however more Encoders will be added as we support additional <code>ExecutionEnvironments</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="libraries"><a class="header" href="#libraries">Libraries</a></h1>
<p>This section contains a detailed description of the various libraries that can be used to rapidly build Valence cross-chain programs for each execution environment.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cosmwasm-libraries"><a class="header" href="#cosmwasm-libraries">CosmWasm Libraries</a></h1>
<p>This section contains a detailed description of all the libraries that can be used in CosmWasm execution environments.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="astroport-lper-library"><a class="header" href="#astroport-lper-library">Astroport LPer library</a></h1>
<p>The <strong>Valence Astroport LPer library</strong> library allows to <strong>provide liquidity</strong> into an <strong>Astroport Liquidity Pool</strong> from an <strong>input account</strong> and deposit the <strong>LP tokens</strong> into an <strong>output account</strong>.</p>
<h2 id="high-level-flow"><a class="header" href="#high-level-flow">High-level flow</a></h2>
<pre class="mermaid">---
title: Astroport Liquidity Provider
---
graph LR
  IA((Input
      Account))
  OA((Output
		  Account))
  P[Processor]
  S[Astroport
      Liquidity
      Provider]
  AP[Astroport
     Pool]
  P -- 1/Provide Liquidity --&gt; S
  S -- 2/Query balances --&gt; IA
  S -- 3/Compute amounts --&gt; S
  S -- 4/Do Provide Liquidity --&gt; IA
  IA -- 5/Provide Liquidity
				  [Tokens] --&gt; AP
  AP -- 5'/Transfer LP Tokens --&gt; OA

</pre>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>ProvideDoubleSidedLiquidity</strong></td><td><code>expected_pool_ratio_range: Option&lt;DecimalRange&gt;</code></td><td>Provide double-sided liquidity to the pre-configured <strong>Astroport Pool</strong> from the <strong>input account</strong>, and deposit the <strong>LP tokens</strong> into the <strong>output account</strong>. Abort it the pool ratio is not within the <code>expected_pool_ratio</code> range (if specified).</td></tr>
<tr><td><strong>ProvideSingleSidedLiquidity</strong></td><td><code>asset: String</code><br><code>limit: Option&lt;Uint128&gt;</code><br><code>expected_pool_ratio_range: Option&lt;DecimalRange&gt;</code></td><td>Provide single-sided liquidity for the specified <code>asset</code> to the pre-configured <strong>Astroport Pool</strong> from the <strong>input account</strong>, and deposit the <strong>LP tokens</strong> into the <strong>output account</strong>. Abort it the pool ratio is not within the <code>expected_pool_ratio</code> range (if specified).</td></tr>
</tbody></table>
</div>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>The library is configured on instantiation via the <code>LibraryConfig</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LibraryConfig {
    // Account from which the funds are LPed
    pub input_addr: LibraryAccountType,
    // Account to which the LP tokens are forwarded
    pub output_addr: LibraryAccountType,
    // Pool address
    pub pool_addr: String,
    // LP configuration
    pub lp_config: LiquidityProviderConfig,
}

pub struct LiquidityProviderConfig {
    // Pool type, old Astroport pools use Cw20 lp tokens and new pools use native tokens, so we specify here what kind of token we are going to get.
    // We also provide the PairType structure of the right Astroport version that we are going to use for each scenario
    pub pool_type: PoolType,
    // Denoms of both native assets we are going to provide liquidity for
    pub asset_data: AssetData,
    /// Max spread used when swapping assets to provide single sided liquidity
    pub max_spread: Option&lt;Decimal&gt;,
}

#[cw_serde]
pub enum PoolType {
    NativeLpToken(valence_astroport_utils::astroport_native_lp_token::PairType),
    Cw20LpToken(valence_astroport_utils::astroport_cw20_lp_token::PairType),
}


pub struct AssetData {
    pub asset1: String,
    pub asset2: String,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="astroport-withdrawer-library"><a class="header" href="#astroport-withdrawer-library">Astroport Withdrawer library</a></h1>
<p>The <strong>Valence Astroport Withdrawer library</strong> library allows to <strong>withdraw liquidity</strong> from an Astroport Liquidity Pool from an <strong>input account</strong> an deposit the withdrawed tokens into an <strong>output account</strong>.</p>
<h2 id="high-level-flow-1"><a class="header" href="#high-level-flow-1">High-level flow</a></h2>
<pre class="mermaid">---
title: Astroport Liquidity Withdrawal
---
graph LR
  IA((Input
      Account))
  OA((Output
		  Account))
  P[Processor]
  S[Astroport
      Liquidity
      Withdrawal]
  AP[Astroport
     Pool]
  P -- 1/Withdraw Liquidity --&gt; S
  S -- 2/Query balances --&gt; IA
  S -- 3/Compute amounts --&gt; S
  S -- 4/Do Withdraw Liquidity --&gt; IA
  IA -- 5/Withdraw Liquidity
				  [LP Tokens] --&gt; AP
  AP -- 5'/Transfer assets --&gt; OA
</pre>
<h2 id="functions-1"><a class="header" href="#functions-1">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>WithdrawLiquidity</strong></td><td>-</td><td>Withdraw liquidity from the configured <strong>Astroport Pool</strong> from the <strong>input account</strong> and deposit the withdrawed tokens into the configured <strong>output account</strong></td></tr>
</tbody></table>
</div>
<h2 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h2>
<p>The library is configured on instantiation via the <code>LibraryConfig</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LibraryConfig {
    // Account holding the LP position
    pub input_addr: LibraryAccountType,
    // Account to which the withdrawn assets are forwarded
    pub output_addr: LibraryAccountType,
    // Pool address
    pub pool_addr: String,
    // Liquidity withdrawer configuration
    pub withdrawer_config: LiquidityWithdrawerConfig,
}

pub struct LiquidityWithdrawerConfig {
    // Pool type, old Astroport pools use Cw20 lp tokens and new pools use native tokens, so we specify here what kind of token we are will use.
    // We also provide the PairType structure of the right Astroport version that we are going to use for each scenario
    pub pool_type: PoolType,
}

pub enum PoolType {
    NativeLpToken,
    Cw20LpToken,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="valence-clearing-queue-library"><a class="header" href="#valence-clearing-queue-library">Valence Clearing Queue Library</a></h1>
<p>The <strong>Valence Clearing Queue</strong> library allows <strong>registration and settlement of withdrawal obligations</strong> in a FIFO (First-In-First-Out) manner. It maintains a queue of pending withdrawal obligations, with each obligation containing recipient information, payout amounts, and a unique identifier. When settling obligations, funds are pulled from a <strong>settlement input account</strong> and sent to the specified recipients.</p>
<p>The queue processes obligations based on a strict, monotonically increasing order of the obligation ids.
This is meant to prevent any out-of-order errors that may arise from latency or other issues.</p>
<blockquote>
<p><strong>Important:</strong>
This library functions solely as a settlement engine. The settlement account funding (liquidity-management) flow is outside of its scope and is managed by a strategist. This management process likely involves monitoring both the settlement account balance and the obligation queue in order to ensure the settlement account maintains sufficient liquidity for obligation settlements.</p>
</blockquote>
<h2 id="high-level-flow-2"><a class="header" href="#high-level-flow-2">High-level flow</a></h2>
<pre class="mermaid">---
title: Clearing Queue Library
---
graph LR
  IA((Settlement&lt;br&gt;Account))
  R((Recipient))
  P[Processor]
  CQ[Clearing&lt;br&gt;Queue&lt;br&gt;Library]
  P -- 1/Register&lt;br&gt;Obligation --&gt; CQ
  CQ -- 2/Store&lt;br&gt;Obligation --&gt; CQ
  P -- 3/Settle&lt;br&gt;Next&lt;br&gt;Obligation --&gt; CQ
  CQ -- 4/Query Settlement&lt;br&gt;Account Balance --&gt; IA
  CQ -- 5/Validate &amp; Execute Transfer --&gt; IA
  IA -- 6/Send Funds --&gt; R
</pre>
<h2 id="functions-2"><a class="header" href="#functions-2">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>RegisterObligation</strong></td><td><code>recipient: String</code><br><code>payout_amount: Uint128</code><br><code>id: Uint64</code></td><td>Registers a new withdrawal obligation in the queue with the specified recipient, payout coins, and unique ID. Each obligation must have a non-zero payout amount. Recipient must be a valid bech32 address. Obligation id must equal the latest registered obligation id plus 1.</td></tr>
<tr><td><strong>SettleNextObligation</strong></td><td>-</td><td>Settles the oldest withdrawal obligation in the queue by transferring funds from the <strong>settlement input account</strong> to the specified recipient. Fails if there are no pending obligations or if the input account has insufficient balance.</td></tr>
</tbody></table>
</div>
<h2 id="configuration-2"><a class="header" href="#configuration-2">Configuration</a></h2>
<p>The library is configured on instantiation via the <code>LibraryConfig</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LibraryConfig {
    /// settlement input account which we tap into in order
    /// to settle the obligations
    pub settlement_acc_addr: LibraryAccountType,
    /// obligation base denom
    pub denom: String,
    /// latest registered obligation id.
    /// if `None`, defaults to 0
    pub latest_id: Option&lt;Uint64&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>settlement_acc_addr</code> specifies the account from which funds will be pulled to fulfill settlement obligations. The library will check that this account has sufficient balance before attempting to settle each obligation.</p>
<p>Configured <code>denom</code> is the base clearing denomination which will be applied to all obligation amounts.</p>
<p>Lastly, the optional <code>latest_id</code> field allows to configure the library order to start from a specific id.
If <code>None</code>, latest id defaults to 0. Otherwise, it will start from the specified id.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="valence-forwarder-library"><a class="header" href="#valence-forwarder-library">Valence Forwarder library</a></h1>
<p>The <strong>Valence Forwarder</strong> library allows to <strong>continuously forward funds</strong> from an <strong>input account</strong> to an <strong>output account</strong>, following some time <strong>constraints</strong>. It is typically used as part of a <strong>Valence Program</strong>. In that context, a <strong>Processor</strong> contract will be the main contract interacting with the Forwarder library.</p>
<h2 id="high-level-flow-3"><a class="header" href="#high-level-flow-3">High-level flow</a></h2>
<pre class="mermaid">---
title: Forwarder Library
---
graph LR
  IA((Input
      Account))
  OA((Output
		  Account))
  P[Processor]
  S[Forwarder
    Library]
  P -- 1/Forward --&gt; S
  S -- 2/Query balances --&gt; IA
  S -- 3/Do Send funds --&gt; IA
  IA -- 4/Send funds --&gt; OA
</pre>
<h2 id="functions-3"><a class="header" href="#functions-3">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>Forward</strong></td><td>-</td><td>Forward funds from the configured <strong>input account</strong> to the <strong>output account</strong>, according to the <strong>forwarding configs</strong> &amp; <strong>constraints</strong>.</td></tr>
</tbody></table>
</div>
<h2 id="configuration-3"><a class="header" href="#configuration-3">Configuration</a></h2>
<p>The library is configured on instantiation via the <code>LibraryConfig</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LibraryConfig {
    // Account from which the funds are pulled
    pub input_addr: LibraryAccountType,
    // Account to which the funds are sent
    pub output_addr: LibraryAccountType,
    // Forwarding configuration per denom
    pub forwarding_configs: Vec&lt;UncheckedForwardingConfig&gt;,
    // Constraints on forwarding operations
    pub forwarding_constraints: ForwardingConstraints,
}

pub struct UncheckedForwardingConfig {
    // Denom to be forwarded (either native or CW20)
    pub denom: UncheckedDenom,
    // Max amount of tokens to be transferred per Forward operation
    pub max_amount: Uint128,
}

// Time constraints on forwarding operations
pub struct ForwardingConstraints {
    // Minimum interval between 2 successive forward operations,
    // specified either as a number of blocks, or as a time delta.
    min_interval: Option&lt;Duration&gt;,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="valence-generic-ibc-transfer-library"><a class="header" href="#valence-generic-ibc-transfer-library">Valence Generic IBC Transfer library</a></h1>
<p>The <strong>Valence Generic IBC Transfer</strong> library allows to transfer funds over IBC from an <strong>input account</strong> on a source chain to an <strong>output account</strong> on a destination chain. It is typically used as part of a <strong>Valence Program</strong>. In that context, a <strong>Processor</strong> contract will be the main contract interacting with the Forwarder library.</p>
<p><strong>Note</strong>: this library should not be used on <strong>Neutron</strong>, which requires some fees to be paid to relayers for IBC transfers. For Neutron, prefer using the dedicated (and optimized) <strong><a href="libraries/cosmwasm/./neutron_ibc_transfer.html">Neutron IBC Transfer library</a></strong> instead.</p>
<h2 id="high-level-flow-4"><a class="header" href="#high-level-flow-4">High-level flow</a></h2>
<pre class="mermaid">---
title: Generic IBC Transfer Library
---
graph LR
  IA((Input
      Account))
  OA((Output
		  Account))
  P[Processor]
  S[Gen IBC Transfer
    Library]
  subgraph Chain 1
  P -- 1/IbcTransfer --&gt; S
  S -- 2/Query balances --&gt; IA
  S -- 3/Do Send funds --&gt; IA
  end
  subgraph Chain 2
  IA -- 4/IBC Transfer --&gt; OA
  end
</pre>
<h2 id="functions-4"><a class="header" href="#functions-4">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>IbcTransfer</strong></td><td>-</td><td>Transfer funds over IBC from an <strong>input account</strong> on a source chain to an <strong>output account</strong> on a destination chain.</td></tr>
<tr><td><strong>EurekaTransfer</strong></td><td>eureka_fee</td><td>Transfer funds over IBC from an <strong>input account</strong> on a source chain to an <strong>output account</strong> on a destination EVM chain using IBC Eureka. The eureka_fee parameter will contain the amount to be paid to a relayer address on the intermediate chain along with the timeout of this fee. All this information can be obtained from a Skip Go query explained in the IBC Eureka section below. <strong>Important</strong>: the fee timeout is passed in nanoseconds</td></tr>
</tbody></table>
</div>
<h2 id="configuration-4"><a class="header" href="#configuration-4">Configuration</a></h2>
<p>The library is configured on instantiation via the <code>LibraryConfig</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct LibraryConfig {
  // Account from which the funds are pulled (on the source chain)
  input_addr: LibraryAccountType,
  // Account to which the funds are sent (on the destination chain)
  output_addr: LibraryAccountType,
  // Denom of the token to transfer
  denom: UncheckedDenom,
  // Amount to be transferred, either a fixed amount or the whole available balance.
  amount: IbcTransferAmount,
  // Memo to be passed in the IBC transfer message.
  memo: String,
  // Information about the destination chain.
  remote_chain_info: RemoteChainInfo,
  // Denom map for the Packet-Forwarding Middleware, to perform a multi-hop transfer.
  denom_to_pfm_map: BTreeMap&lt;String, PacketForwardMiddlewareConfig&gt;,
  // Configuration used for IBC Eureka transfers
  eureka_config: Option&lt;EurekaConfig&gt;,
}

// Defines the amount to be transferred, either a fixed amount or the whole available balance.
enum IbcTransferAmount {
  // Transfer the full available balance of the input account.
  FullAmount,
  // Transfer the specified amount of tokens.
  FixedAmount(Uint128),
}

pub struct RemoteChainInfo {
  // Channel of the IBC connection to be used.
  channel_id: String,
  // Port of  the IBC connection to be used.
  port_id: Option&lt;String&gt;,
  // Timeout for the IBC transfer.
  ibc_transfer_timeout: Option&lt;Uint64&gt;,
}

// Configuration for a multi-hop transfer using the Packet Forwarding Middleware
struct PacketForwardMiddlewareConfig {
  // Channel ID from the source chain to the intermediate chain
  local_to_hop_chain_channel_id: String,
  // Channel ID from the intermediate to the destination chain
  hop_to_destination_chain_channel_id: String,
  // Temporary receiver address on the intermediate chain. Typically this is set to an invalid address so the entire transaction will revert if the forwarding fails. If not
  // provided it's set to "pfm"
  hop_chain_receiver_address: Option&lt;String&gt;,
}

// Configuration for IBC Eureka transfers
pub struct EurekaConfig {
    /// The address of the contract on intermediate chain that will receive the callback.
    pub callback_contract: String,
    /// The address of the contract on intermediate chain that will trigger the actions, in this case the Eureka transfer.
    pub action_contract: String,
    /// Recover address on intermediate chain in case the transfer fails
    pub recover_address: String,
    /// Source channel on the intermediate chain (e.g. "08-wasm-1369")
    pub source_channel: String,
    /// Optional memo for the Eureka transfer triggered by the contract. Not used right now but could eventually be used.
    pub memo: Option&lt;String&gt;,
    /// Timeout in seconds to be used for the Eureka transfer. For reference, Skip Go uses 12 hours (43200). If not passed we will use that default value
    pub timeout: Option&lt;u64&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="packet-forward-middleware"><a class="header" href="#packet-forward-middleware">Packet-Forward Middleware</a></h3>
<p>The library supports multi-hop IBC transfers using the Packet Forward Middleware (PFM).
This allows tokens to be transferred through an intermediate chain to reach their final
destination. More information about the PFM functionality can be found in the <a href="https://github.com/cosmos/ibc-apps/tree/main/middleware/packet-forward-middleware">official
documentation</a>.</p>
<p>Generic IBC Transfer library can be configured to make use of PFM as follows:</p>
<ul>
<li>
<p><code>output_addr</code> is set to the final receiver address on the final destination chain</p>
</li>
<li>
<p><code>remote_chain_info</code> is configured between the origin and intermediate chain</p>
</li>
<li>
<p><code>denom_to_pfm_map</code> is configured to map the origin denom to its respective
<code>PacketForwardMiddlewareConfig</code> which should contain:</p>
<ul>
<li><code>local_to_hop_chain_channel_id</code> - origin to intermediate chain channel id</li>
<li><code>hop_to_destination_chain_channel_id</code> - intermediate to destination chain channel id</li>
<li><code>hop_chain_receiver_address</code> - address where funds should settle on the intermediate
chain in case of a failure</li>
</ul>
</li>
</ul>
<blockquote>
<p>Official packet-forward-middleware recommends to configure intermediate chain settlement
addresses (<code>hop_chain_receiver_address</code>) with an invalid bech32 string such as <code>"pfm"</code>.
More information about this can be found in the <a href="https://github.com/cosmos/ibc-apps/tree/main/middleware/packet-forward-middleware#full-example---chain-forward-a-b-c-d-with-retry-on-timeout">official documentation</a>.</p>
</blockquote>
<p>Consider an example configuration transferring tokens from Osmosis to Gaia via Juno.
Library config may look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>LibraryConfig {
    input_addr: input_acc,
    output_addr: output_acc,
    denom: UncheckedDenom::Native(target_denom),
    amount: IbcTransferAmount::FixedAmount(transfer_amount),
    memo: "".to_string(),
    remote_chain_info: RemoteChainInfo {
        channel_id: osmosis_to_juno_channel_id,
        ibc_transfer_timeout: Some(500u64.into()),
    },
    denom_to_pfm_map: BTreeMap::from([(
        denom,
        PacketForwardMiddlewareConfig {
            local_to_hop_chain_channel_id: osmosis_to_juno_channel_id,
            hop_to_destination_chain_channel_id: juno_to_gaia_channel_id,
            hop_chain_receiver_address: None, // if not passed, "pfm" is used
        },
    )]),
    eureka_config: None,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="ibc-eureka"><a class="header" href="#ibc-eureka">IBC Eureka</a></h3>
<p>This library supports IBC Eureka transfers using an intermediate chain. This allows tokens to be transferred from the origin chain to EVM chains connected with IBC Eureka using standard IBC transfers together with Skip Go capabilities. For more information on how IBC Eureka works with Skip Go, please refer to this <a href="https://docs.skip.build/go/eureka/eureka-overview">Eureka overview</a>.</p>
<p>Currently, all IBC Eureka transfers are routed through the Cosmos Hub, but the library can be configured to use any other chain as the intermediate chain in the future.
The library can be configured to make use of IBC Eureka as follows:</p>
<ul>
<li><code>output_addr</code> is set to the final receiver address on the final EVM chain (0x address)</li>
<li><code>remote_chain_info</code> is configured between the origin and intermediate chain</li>
<li><code>eureka_config</code> is configured with the addresses used to trigger the actions on the intermediate chain and the callback contract that will be called when the transfer is completed.
<ul>
<li><code>callback_contract</code> - address of the contract on the intermediate chain that will trigger the callback.</li>
<li><code>action_contract</code> - address of the contract on the intermediate chain that will trigger the actions, in this case the Eureka transfer.</li>
<li><code>recover_address</code> - address on the intermediate chain that will be used to recover the funds in case the transfer fails.</li>
<li><code>source_channel</code> - source channel on the intermediate chain</li>
<li><code>memo(Optional)</code> - memo to be passed in the IBC transfer message. Currently not used but could potentially be used in the future.</li>
<li><code>timeout(Optional)</code> - timeout in seconds for the Eureka Transfer. If not provided, a default 43200 seconds (12 hours) will be used. Which is the same that Skip Go uses.</li>
</ul>
</li>
</ul>
<p>Consider an example configuration transferring ATOM tokens from Neutron to Ethereum.
Library config may look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>LibraryConfig {
    input_addr: "neutron1....",
    output_addr: "0x....",
    denom: UncheckedDenom::Native("ibc/C4CFF46FD6DE35CA4CF4CE031E643C8FDC9BA4B99AE598E9B0ED98FE3A2319F9".to_string()),
    amount: IbcTransferAmount::FullAmount,
    memo: "".to_string(),
    remote_chain_info: RemoteChainInfo {
        channel_id: "channel-1", // Neutron to Cosmos Hub channel id
        ibc_transfer_timeout: None, // Default 10 minutes used
    },
    denom_to_pfm_map: BTreeMap::default(),
    eureka_config: {
        callback_contract: "cosmos1lqu9662kd4my6dww4gzp3730vew0gkwe0nl9ztjh0n5da0a8zc4swsvd22".to_string(),
        action_contract: "cosmos1clswlqlfm8gpn7n5wu0ypu0ugaj36urlhj7yz30hn7v7mkcm2tuqy9f8s5".to_string(),
        recover_address: "cosmos1....".to_string(),
        source_channel: "08-wasm-1369".to_string(),
        memo: None,
        timeout: None,
    }
}
<span class="boring">}</span></code></pre></pre>
<p>When configuring the library or executing the <strong>EurekaTransfer</strong> function, the following Skip Go query can be used to get all the required information. Here's an example query to transfer 5 ATOM from Neutron to Ethereum.</p>
<pre><code class="language-bash">curl -X POST "https://go.skip.build/api/skip/v2/fungible/route" \
  -H "Content-Type: application/json" \
  -d '{
    "source_asset_chain_id": "neutron-1",
    "source_asset_denom": "ibc/C4CFF46FD6DE35CA4CF4CE031E643C8FDC9BA4B99AE598E9B0ED98FE3A2319F9",
    "dest_asset_chain_id": "1",
    "dest_asset_denom": "0xbf6Bc6782f7EB580312CC09B976e9329f3e027B3",
    "amount_in": "5000000",
    "allow_unsafe": true,
    "allow_multi_tx": true,
    "go_fast": true,
    "smart_relay": true,
    "smart_swap_options": {
      "split_routes": true,
      "evm_swaps": true
    },
    "experimental_features": [
      "eureka"
    ]
  }'
</code></pre>
<p>This query will return the following key information among other things:</p>
<ul>
<li><code>smart_relay_fee_quote</code> - the <code>eureka_fee</code> information to execute the transfer. <strong>Important</strong>: the timeout for the transfer needs to be passed as nanoseconds.</li>
<li><code>source_client</code> - the <code>source_channel</code> used in the <code>eureka_config</code> when configuring the library.</li>
<li><code>callback_adapter_contract_address</code> - the <code>callback_contract</code> used in the <code>eureka_config</code> when configuring the library.</li>
<li><code>entry_contract_address</code> - the <code>action_contract</code> used in the <code>eureka_config</code> when configuring the library.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="valence-neutron-ibc-transfer-library"><a class="header" href="#valence-neutron-ibc-transfer-library">Valence Neutron IBC Transfer library</a></h1>
<p>The <strong>Valence Neutron IBC Transfer</strong> library allows to transfer funds over IBC from an <strong>input account</strong> on <strong>Neutron</strong> to an <strong>output account</strong> on a destination chain. It is typically used as part of a <strong>Valence Program</strong>. In that context, a <strong>Processor</strong> contract will be the main contract interacting with the Forwarder library.</p>
<p>Note: this library should not be used on another chain other than <strong>Neutron</strong>, which requires some NTRN fees to be paid to relayers for IBC transfers that the <strong>input account</strong> should hold. For other CosmWasm chains, use the <strong><a href="libraries/cosmwasm/./generic_ibc_transfer.html">Generic IBC Transfer library</a></strong> instead.</p>
<h2 id="high-level-flow-5"><a class="header" href="#high-level-flow-5">High-level flow</a></h2>
<pre class="mermaid">---
title: Neutron IBC Transfer Library
---
graph LR
  IA((Input
      Account))
  OA((Output
		  Account))
  P[Processor]
  S[Neutron IBC Transfer
    Library]
  subgraph Neutron
  P -- 1/IbcTransfer --&gt; S
  S -- 2/Query balances --&gt; IA
  S -- 3/Do Send funds --&gt; IA
  end
  subgraph Chain 2
  IA -- 4/IBC Transfer --&gt; OA
  end
</pre>
<h2 id="functions-5"><a class="header" href="#functions-5">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>IbcTransfer</strong></td><td>-</td><td>Transfer funds over IBC from an <strong>input account</strong> on <strong>Neutron</strong> to an <strong>output account</strong> on a destination chain. The <strong>input account</strong> must hold enough NTRN balance to pay for the relayer fees</td></tr>
<tr><td><strong>EurekaTransfer</strong></td><td>eureka_fee</td><td>Transfer funds over IBC from an <strong>input account</strong> on a source chain to an <strong>output account</strong> on a destination EVM chain using IBC Eureka. The eureka_fee parameter will contain the amount to be paid to a relayer address on the intermediate chain along with the timeout of this fee. All this information can be obtained from a Skip Go query explained in the IBC Eureka section below. <strong>Important</strong>: the fee timeout is passed in nanoseconds</td></tr>
</tbody></table>
</div>
<h2 id="configuration-5"><a class="header" href="#configuration-5">Configuration</a></h2>
<p>The library is configured on instantiation via the <code>LibraryConfig</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct LibraryConfig {
  // Account from which the funds are pulled (on the source chain)
  input_addr: LibraryAccountType,
  // Account to which the funds are sent (on the destination chain)
  output_addr: LibraryAccountType,
  // Denom of the token to transfer
  denom: UncheckedDenom,
  // Amount to be transferred, either a fixed amount or the whole available balance.
  amount: IbcTransferAmount,
  // Memo to be passed in the IBC transfer message.
  memo: String,
  // Information about the destination chain.
  remote_chain_info: RemoteChainInfo,
  // Denom map for the Packet-Forwarding Middleware, to perform a multi-hop transfer.
  denom_to_pfm_map: BTreeMap&lt;String, PacketForwardMiddlewareConfig&gt;,
  // Configuration used for IBC Eureka transfers
  eureka_config: Option&lt;EurekaConfig&gt;,
}

// Defines the amount to be transferred, either a fixed amount or the whole available balance.
enum IbcTransferAmount {
  // Transfer the full available balance of the input account.
  FullAmount,
  // Transfer the specified amount of tokens.
  FixedAmount(Uint128),
}

pub struct RemoteChainInfo {
  // Channel of the IBC connection to be used.
  channel_id: String,
  // Port of  the IBC connection to be used.
  port_id: Option&lt;String&gt;,
  // Timeout for the IBC transfer.
  ibc_transfer_timeout: Option&lt;Uint64&gt;,
}

// Configuration for a multi-hop transfer using the Packet Forwarding Middleware
struct PacketForwardMiddlewareConfig {
  // Channel ID from the source chain to the intermediate chain
  local_to_hop_chain_channel_id: String,
  // Channel ID from the intermediate to the destination chain
  hop_to_destination_chain_channel_id: String,
  // Temporary receiver address on the intermediate chain. Typically this is set to an invalid address so the entire transaction will revert if the forwarding fails. If not
  // provided it's set to "pfm"
  hop_chain_receiver_address: Option&lt;String&gt;,
}

// Configuration for IBC Eureka transfers
pub struct EurekaConfig {
    /// The address of the contract on intermediate chain that will receive the callback.
    pub callback_contract: String,
    /// The address of the contract on intermediate chain that will trigger the actions, in this case the Eureka transfer.
    pub action_contract: String,
    /// Recover address on intermediate chain in case the transfer fails
    pub recover_address: String,
    /// Source channel on the intermediate chain (e.g. "08-wasm-1369")
    pub source_channel: String,
    /// Optional memo for the Eureka transfer triggered by the contract. Not used right now but could eventually be used.
    pub memo: Option&lt;String&gt;,
    /// Timeout in seconds to be used for the Eureka transfer. For reference, Skip Go uses 12 hours (43200). If not passed we will use that default value
    pub timeout: Option&lt;u64&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="packet-forward-middleware-1"><a class="header" href="#packet-forward-middleware-1">Packet-Forward Middleware</a></h3>
<p>The library supports multi-hop IBC transfers using the Packet Forward Middleware (PFM).
This allows tokens to be transferred through an intermediate chain to reach their final
destination. More information about the PFM functionality can be found in the <a href="https://github.com/cosmos/ibc-apps/tree/main/middleware/packet-forward-middleware">official
documentation</a>.</p>
<p>Neutron IBC Transfer library can be configured to make use of PFM as follows:</p>
<ul>
<li>
<p><code>output_addr</code> is set to the final receiver address on the final destination chain</p>
</li>
<li>
<p><code>remote_chain_info</code> is configured between the origin and intermediate chain</p>
</li>
<li>
<p><code>denom_to_pfm_map</code> is configured to map the origin denom to its respective
<code>PacketForwardMiddlewareConfig</code> which should contain:</p>
<ul>
<li><code>local_to_hop_chain_channel_id</code> - origin to intermediate chain channel id</li>
<li><code>hop_to_destination_chain_channel_id</code> - intermediate to destination chain channel id</li>
<li><code>hop_chain_receiver_address</code> - address where funds should settle on the intermediate
chain in case of a failure</li>
</ul>
</li>
</ul>
<blockquote>
<p>Official packet-forward-middleware recommends to configure intermediate chain settlement
addresses (<code>hop_chain_receiver_address</code>) with an invalid bech32 string such as <code>"pfm"</code>.
More information about this can be found in the <a href="https://github.com/cosmos/ibc-apps/tree/main/middleware/packet-forward-middleware#full-example---chain-forward-a-b-c-d-with-retry-on-timeout">official documentation</a>.</p>
</blockquote>
<p>Consider an example configuration transferring tokens from Neutron to Gaia via Juno.
Library config may look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let cfg = LibraryConfig {
    input_addr: input_acc,
    output_addr: output_acc,
    denom: UncheckedDenom::Native(target_denom),
    amount: IbcTransferAmount::FixedAmount(transfer_amount),
    memo: "".to_string(),
    remote_chain_info: RemoteChainInfo {
        channel_id: neutron_to_juno_channel_id,
        ibc_transfer_timeout: Some(500u64.into()),
    },
    denom_to_pfm_map: BTreeMap::from([(
        denom,
        PacketForwardMiddlewareConfig {
            local_to_hop_chain_channel_id: neutron_to_juno_channel_id,
            hop_to_destination_chain_channel_id: juno_to_gaia_channel_id,
            hop_chain_receiver_address: None, // if not passed, "pfm" is used
        },
    )]),
    eureka_config: None,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="ibc-eureka-1"><a class="header" href="#ibc-eureka-1">IBC Eureka</a></h3>
<p>This library supports IBC Eureka transfers using an intermediate chain. This allows tokens to be transferred from the origin chain to EVM chains connected with IBC Eureka using standard IBC transfers together with Skip Go capabilities. For more information on how IBC Eureka works with Skip Go, please refer to this <a href="https://docs.skip.build/go/eureka/eureka-overview">Eureka overview</a>.</p>
<p>This works in the same way as the <strong>Generic IBC Transfer Library</strong>. For more details on how IBC Eureka works, check the <a href="libraries/cosmwasm/./generic_ibc_transfer.html#ibc-eureka">Generic IBC Transfer Library IBC Eureka</a> documentation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="osmosis-cl-lper-library"><a class="header" href="#osmosis-cl-lper-library">Osmosis CL LPer library</a></h1>
<p>The <strong>Valence Osmosis CL LPer library</strong> library allows to <strong>create concentrated liquidity
positions</strong> on <strong>Osmosis</strong> from an <strong>input account</strong>, and deposit the <strong>LP tokens</strong> into an <strong>output account</strong>.</p>
<h2 id="high-level-flow-6"><a class="header" href="#high-level-flow-6">High-level flow</a></h2>
<pre class="mermaid">---
title: Osmosis CL Liquidity Provider
---
graph LR
  IA((Input
      Account))
  OA((Output
		  Account))
  P[Processor]
  S[Osmosis CL
      Liquidity
      Provider]
  AP[Osmosis CL
     Pool]
  P -- 1/Provide Liquidity --&gt; S
  S -- 2/Query balances --&gt; IA
  S -- 3/Configure target
    range --&gt; S
  S -- 4/Do Provide Liquidity --&gt; IA
  IA -- 5/Provide Liquidity
				  [Tokens] --&gt; AP
  AP -- 5'/Transfer LP Tokens --&gt; OA

</pre>
<h2 id="concentrated-liquidity-position-creation"><a class="header" href="#concentrated-liquidity-position-creation">Concentrated Liquidity Position creation</a></h2>
<p>Because of the way CL positions are created, there are two ways to achieve it:</p>
<h3 id="default"><a class="header" href="#default">Default</a></h3>
<p>Default position creation centers around the idea of creating a position
with respect to the currently active tick of the pool.</p>
<p>This method expects a single parameter, <code>bucket_amount</code>, which describes
how many <em>buckets</em> of the pool should be taken into account to both sides
of the price curve.</p>
<p>Consider a situation where the current tick is 125, and the configured
tick spacing is 10.</p>
<p>If this method is called with <code>bucket_amount</code> set to 5, the following logic
will be performed:</p>
<ul>
<li>find the current bucket range, which is 120 to 130</li>
<li>extend the current bucket ranges by 5 buckets to both sides, meaning
that the range "to the left" will be extended by 5 * 10 = 50, and the
range "to the right" will be extended by 5 * 10 = 50, resulting in the covered
range from 120 - 50 = 70 to 130 + 50 = 180, giving the position tick range of (70, 180).</li>
</ul>
<h3 id="custom"><a class="header" href="#custom">Custom</a></h3>
<p>Custom position creation allows for more fine-grained control over the
way the position is created.</p>
<p>This approach expects users to specify the following parameters:</p>
<ul>
<li><code>tick_range</code>, which describes the price range to be covered</li>
<li><code>token_min_amount_0</code> and <code>token_min_amount_1</code> which are optional
parameters that describe the minimum amount of tokens that should be
provided to the pool.</li>
</ul>
<p>With this flexibility a wide variety of positions can be created, such as
those that are entirely single-sided.</p>
<h2 id="functions-6"><a class="header" href="#functions-6">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>ProvideLiquidityDefault</strong></td><td><code>bucket_amount: Uint64</code></td><td>Create a position on the pre-configured <strong>Osmosis Pool</strong> from the <strong>input account</strong>, following the <a href="libraries/cosmwasm/osmosis_cl_lper.html#default">Default approach</a> described above, and deposit the <strong>LP tokens</strong> into the <strong>output account</strong>.</td></tr>
<tr><td><strong>ProvideLiquidityCustom</strong></td><td><code>tick_range: TickRange</code><br><code>token_min_amount_0: Option&lt;Uint128&gt;</code><br><code>token_min_amount_1: Option&lt;Uint128&gt;</code></td><td>Create a position on the pre-configured <strong>Osmosis Pool</strong> from the <strong>input account</strong>, following the <a href="libraries/cosmwasm/osmosis_cl_lper.html#custom">Custom approach</a> described above, and deposit the <strong>LP tokens</strong> into the <strong>output account</strong>.</td></tr>
</tbody></table>
</div>
<h2 id="configuration-6"><a class="header" href="#configuration-6">Configuration</a></h2>
<p>The library is configured on instantiation via the <code>LibraryConfig</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LibraryConfig {
    // Account from which the funds are LPed
    pub input_addr: LibraryAccountType,
    // Account to which the LP position is forwarded
    pub output_addr: LibraryAccountType,
    // LP configuration
    pub lp_config: LiquidityProviderConfig,
}

pub struct LiquidityProviderConfig {
    // ID of the Osmosis CL pool
    pub pool_id: Uint64,
    // Pool asset 1 
    pub pool_asset_1: String,
    // Pool asset 2
    pub pool_asset_2: String,
    // Pool global price range
    pub global_tick_range: TickRange,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="osmosis-cl-liquidity-withdrawer-library"><a class="header" href="#osmosis-cl-liquidity-withdrawer-library">Osmosis CL liquidity withdrawer library</a></h1>
<p>The <strong>Valence Osmosis CL Withdrawer library</strong> library allows to <strong>withdraw a concentrated liquidity
position</strong> off an <strong>Osmosis</strong> pool from an <strong>input account</strong>, and transfer the resulting tokens to an <strong>output account</strong>.</p>
<h2 id="high-level-flow-7"><a class="header" href="#high-level-flow-7">High-level flow</a></h2>
<pre class="mermaid">---
title: Osmosis CL Liquidity Withdrawal
---
graph LR
  IA((Input
      Account))
  OA((Output
		  Account))
  P[Processor]
  S[Osmosis CL
      Liquidity
      Withdrawal]
  AP[Osmosis CL
     Pool]
  P -- 1/Withdraw Liquidity --&gt; S
  S -- 2/Query balances --&gt; IA
  S -- 3/Compute amounts --&gt; S
  S -- 4/Do Withdraw Liquidity --&gt; IA
  IA -- 5/Withdraw Liquidity
				  [LP Position] --&gt; AP
  AP -- 5'/Transfer assets --&gt; OA
</pre>
<h2 id="functions-7"><a class="header" href="#functions-7">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>WithdrawLiquidity</strong></td><td><code>position_id: Uint64</code><br><code>liquidity_amount: String</code></td><td>Withdraw liquidity from the configured <strong>Osmosis Pool</strong> from the <strong>input account</strong>, according to the given parameters, and transfer the withdrawned tokens to the configured <strong>output account</strong></td></tr>
</tbody></table>
</div>
<h2 id="configuration-7"><a class="header" href="#configuration-7">Configuration</a></h2>
<p>The library is configured on instantiation via the <code>LibraryConfig</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LibraryConfig {
    // Account holding the LP position
    pub input_addr: LibraryAccountType,
    // Account to which the withdrawn assets are forwarded
    pub output_addr: LibraryAccountType,
    // ID of the pool
    pub pool_id: Uint64,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="osmosis-gamm-lper-library"><a class="header" href="#osmosis-gamm-lper-library">Osmosis GAMM LPer library</a></h1>
<p>The <strong>Valence Osmosis GAMM LPer library</strong> library allows to <strong>join a pool</strong> on <strong>Osmosis</strong>, using the <strong>GAMM module</strong> (Generalized Automated Market Maker), from an <strong>input account</strong>, and deposit the <strong>LP tokens</strong> into an <strong>output account</strong>.</p>
<h2 id="high-level-flow-8"><a class="header" href="#high-level-flow-8">High-level flow</a></h2>
<pre class="mermaid">---
title: Osmosis GAMM Liquidity Provider
---
graph LR
  IA((Input
      Account))
  OA((Output
          Account))
  P[Processor]
  S[Osmosis GAMM
      Liquidity
      Provider]
  AP[Osmosis
     Pool]
  P -- 1/Join Pool --&gt; S
  S -- 2/Query balances --&gt; IA
  S -- 3/Compute amounts --&gt; S
  S -- 4/Do Join Pool --&gt; IA
  IA -- 5/Join Pool
                  [Tokens] --&gt; AP
  AP -- 5'/Transfer LP tokens --&gt; OA

</pre>
<h2 id="functions-8"><a class="header" href="#functions-8">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>ProvideDoubleSidedLiquidity</strong></td><td><code>expected_spot_price: Option&lt;DecimalRange&gt;</code></td><td>Provide double-sided liquidity to the pre-configured <strong>Osmosis Pool</strong> from the <strong>input account</strong>, and deposit the <strong>LP tokens</strong> into the <strong>output account</strong>. Abort it the spot price is not within the <code>expected_spot_price</code> range (if specified).</td></tr>
<tr><td><strong>ProvideSingleSidedLiquidity</strong></td><td><code>asset: String</code><br><code>limit: Option&lt;Uint128&gt;</code><br><code>expected_spot_price: Option&lt;DecimalRange&gt;</code></td><td>Provide single-sided liquidity for the specified <code>asset</code> to the pre-configured <strong>Osmosis Pool</strong> from the <strong>input account</strong>, and deposit the <strong>LP tokens</strong> into the <strong>output account</strong>. Abort it the spot price is not within the <code>expected_spot_price</code> range (if specified).</td></tr>
</tbody></table>
</div>
<h2 id="configuration-8"><a class="header" href="#configuration-8">Configuration</a></h2>
<p>The library is configured on instantiation via the <code>LibraryConfig</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LibraryConfig {
    // Account from which the funds are LPed
    pub input_addr: LibraryAccountType,
    // Account to which the LP position is forwarded
    pub output_addr: LibraryAccountType,
    // LP configuration
    pub lp_config: LiquidityProviderConfig,
}

pub struct LiquidityProviderConfig {
    // ID of the Osmosis pool
    pub pool_id: Uint64,
    // Pool asset 1 
    pub pool_asset_1: String,
    // Pool asset 2
    pub pool_asset_2: String,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="osmosis-gamm-liquidity-withdrawer-library"><a class="header" href="#osmosis-gamm-liquidity-withdrawer-library">Osmosis GAMM liquidity withdrawer library</a></h1>
<p>The <strong>Valence Osmosis GAMM Withdrawer library</strong> library allows to <strong>exit a pool</strong> on <strong>Osmosis</strong>, using the <strong>GAMM module</strong> (Generalized Automated Market Maker), from an <strong>input account</strong>, an deposit the withdrawed tokens into an <strong>output account</strong>.</p>
<h2 id="high-level-flow-9"><a class="header" href="#high-level-flow-9">High-level flow</a></h2>
<pre class="mermaid">---
title: Osmosis GAMM Liquidity Withdrawal
---
graph LR
  IA((Input
      Account))
  OA((Output
		  Account))
  P[Processor]
  S[Osmosis GAMM
      Liquidity
      Withdrawal]
  AP[Osmosis
     Pool]
  P -- 1/Withdraw Liquidity --&gt; S
  S -- 2/Query balances --&gt; IA
  S -- 3/Compute amounts --&gt; S
  S -- 4/Do Withdraw Liquidity --&gt; IA
  IA -- 5/Withdraw Liquidity
				  [LP Tokens] --&gt; AP
  AP -- 5'/Transfer assets --&gt; OA
</pre>
<h2 id="functions-9"><a class="header" href="#functions-9">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>WithdrawLiquidity</strong></td><td>-</td><td>Withdraw liquidity from the configured <strong>Osmosis Pool</strong> from the <strong>input account</strong> and deposit the withdrawed tokens into the configured <strong>output account</strong></td></tr>
</tbody></table>
</div>
<h2 id="configuration-9"><a class="header" href="#configuration-9">Configuration</a></h2>
<p>The library is configured on instantiation via the <code>LibraryConfig</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LibraryConfig {
    // Account from which the funds are LPed
    pub input_addr: LibraryAccountType,
    // Account to which the LP tokens are forwarded
    pub output_addr: LibraryAccountType,
    // Liquidity withdrawer configuration
    pub withdrawer_config: LiquidityWithdrawerConfig,
}

pub struct LiquidityWithdrawerConfig {
    // ID of the pool
    pub pool_id: Uint64,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="valence-reverse-splitter-library"><a class="header" href="#valence-reverse-splitter-library">Valence Reverse Splitter library</a></h1>
<p>The <strong>Reverse Splitter</strong> library allows to <strong>route funds</strong> from <strong>one or more input account(s)</strong> to a <strong>single output account</strong>, for <strong>one or more token denom(s)</strong> according to the configured <strong>ratio(s)</strong>. It is typically used as part of a <strong>Valence Program</strong>. In that context, a <strong>Processor</strong> contract will be the main contract interacting with the Forwarder library.</p>
<h2 id="high-level-flow-10"><a class="header" href="#high-level-flow-10">High-level flow</a></h2>
<pre class="mermaid">---
title: Reverse Splitter Library
---
graph LR
  IA1((Input
      Account1))
  IA2((Input
       Account2))
  OA((Output
		  Account))
  P[Processor]
  S[Reverse Splitter
    Library]
  C[Contract]
  P -- 1/Split --&gt; S
  S -- 2/Query balances --&gt; IA1
  S -- 2'/Query balances --&gt; IA2
  S -. 3/Query split ratio .-&gt; C
  S -- 4/Do Send funds --&gt; IA1
  S -- 4'/Do Send funds --&gt; IA2
  IA1 -- 5/Send funds --&gt; OA
  IA2 -- 5'/Send funds --&gt; OA
</pre>
<h2 id="functions-10"><a class="header" href="#functions-10">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>Split</strong></td><td>-</td><td>Split and route funds from the configured <strong>input account(s)</strong> to the <strong>output account</strong>, according to the configured <strong>token denom(s)</strong> and <strong>ratio(s)</strong>.</td></tr>
</tbody></table>
</div>
<h2 id="configuration-10"><a class="header" href="#configuration-10">Configuration</a></h2>
<p>The library is configured on instantiation via the <code>LibraryConfig</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct LibraryConfig {
    output_addr: LibraryAccountType,   // Account to which the funds are sent.
    splits: Vec&lt;UncheckedSplitConfig&gt;, // Split configuration per denom.
    base_denom: UncheckedDenom         // Base denom, used with ratios.
}

// Split config for specified account
struct UncheckedSplitConfig {
  denom: UncheckedDenom,                // Denom for this split configuration (either native or CW20).
  account: LibraryAccountType,          // Address of the input account for this split config.
  amount: UncheckedSplitAmount,         // Fixed amount of tokens or an amount defined based on a ratio.
  factor: Option&lt;u64&gt;                   // Multiplier relative to other denoms (only used if a ratio is specified).
}

// Ratio configuration, either fixed &amp; dynamically calculated
enum UncheckedRatioConfig {
  FixedAmount(Uint128), // Fixed amount of tokens
  FixedRatio(Decimal),  // Fixed ratio e.g. 0.0262 for NTRN/STARS (or could be another arbitrary ratio)
  DynamicRatio {        // Dynamic ratio calculation (delegated to external contract)
	contract_addr: "&lt;TWAP Oracle wrapper contract address&gt;",
    params: "base64-encoded arbitrary payload to send in addition to the denoms"
  }
}

// Standard query &amp; response for contract computing a dynamic ratio
// for the Splitter &amp; Reverse Splitter libraries.
#[cw_serde]
#[derive(QueryResponses)]
pub enum DynamicRatioQueryMsg {
    #[returns(DynamicRatioResponse)]
    DynamicRatio {
        denoms: Vec&lt;String&gt;,
        params: String,
    }
}

#[cw_serde]
// Response returned by the external contract for a dynamic ratio
struct DynamicRatioResponse {
    pub denom_ratios: HashMap&lt;String, Decimal&gt;,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="valence-splitter-library"><a class="header" href="#valence-splitter-library">Valence Splitter library</a></h1>
<p>The <strong>Valence Splitter</strong> library allows to <strong>split funds</strong> from <strong>one input account</strong> to <strong>one or more output account(s)</strong>, for <strong>one or more token denom(s)</strong> according to the configured <strong>ratio(s)</strong>. It is typically used as part of a <strong>Valence Program</strong>. In that context, a <strong>Processor</strong> contract will be the main contract interacting with the Forwarder library.</p>
<h2 id="high-level-flow-11"><a class="header" href="#high-level-flow-11">High-level flow</a></h2>
<pre class="mermaid">---
title: Splitter Library
---
graph LR
  IA((Input
      Account))
  OA1((Output
		  Account 1))
	OA2((Output
		  Account 2))
  P[Processor]
  S[Splitter
    Library]
  C[Contract]
  P -- 1/Split --&gt; S
  S -- 2/Query balances --&gt; IA
  S -. 3/Query split ratio .-&gt; C
  S -- 4/Do Send funds --&gt; IA
  IA -- 5/Send funds --&gt; OA1
  IA -- 5'/Send funds --&gt; OA2
</pre>
<h2 id="functions-11"><a class="header" href="#functions-11">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>Split</strong></td><td>-</td><td>Split funds from the configured <strong>input account</strong> to the <strong>output account(s)</strong>, according to the configured <strong>token denom(s)</strong> and <strong>ratio(s)</strong>.</td></tr>
</tbody></table>
</div>
<h2 id="configuration-11"><a class="header" href="#configuration-11">Configuration</a></h2>
<p>The library is configured on instantiation via the <code>LibraryConfig</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct LibraryConfig {
    input_addr: LibraryAccountType,    // Address of the input account
    splits: Vec&lt;UncheckedSplitConfig&gt;, // Split configuration per denom
}

// Split config for specified account
struct UncheckedSplitConfig {
  denom: UncheckedDenom,          // Denom for this split configuration (either native or CW20)
  account: LibraryAccountType,    // Address of the output account for this split config
  amount: UncheckedSplitAmount,   // Fixed amount of tokens or an amount defined based on a ratio
}

// Split amount configuration, either a fixed amount of tokens or an amount defined based on a ratio
enum UncheckedSplitAmount {
  FixedAmount(Uint128),       // Fixed amount of tokens
  FixedRatio(Decimal),        // Fixed ratio e.g. 0.0262 for NTRN/STARS (or could be another arbitrary ratio)
  DynamicRatio {              // Dynamic ratio calculation (delegated to external contract)
    contract_addr: "&lt;TWAP Oracle wrapper contract address&gt;",
    params: "base64-encoded arbitrary payload to send in addition to the denoms"
  }
}

// Standard query &amp; response for contract computing a dynamic ratio
// for the Splitter &amp; Reverse Splitter libraries.
#[cw_serde]
#[derive(QueryResponses)]
pub enum DynamicRatioQueryMsg {
    #[returns(DynamicRatioResponse)]
    DynamicRatio {
        denoms: Vec&lt;String&gt;,
        params: String,
    }
}

#[cw_serde]
// Response returned by the external contract for a dynamic ratio
struct DynamicRatioResponse {
    pub denom_ratios: HashMap&lt;String, Decimal&gt;,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="supervaults-liquidity-provider-library"><a class="header" href="#supervaults-liquidity-provider-library">Supervaults Liquidity Provider library</a></h1>
<p>The <strong>Valence Supervaults LPer library</strong> library allows to <strong>provide liquidity</strong> into <strong>Neutron Supervaults</strong> from an <strong>input account</strong> and deposit the <strong>LP tokens</strong> into an <strong>output account</strong>.</p>
<h2 id="high-level-flow-12"><a class="header" href="#high-level-flow-12">High-level flow</a></h2>
<pre class="mermaid">---
title: Supervaults Liquidity Provider
---
graph LR
  IA((Input Account))
  OA((Output Account))
  P[Processor]
  S[Supervaults&lt;br&gt;Liquidity&lt;br&gt;Provider]
  SV[Supervault]
  P -- 1/Provide Liquidity --&gt; S
  S -- 2/Query balances --&gt; IA
  S -- 3/Try Provide Liquidity --&gt; IA
  IA -- 4/Provide Liquidity [Tokens] --&gt; SV
  IA -- 4'/Transfer LP Tokens --&gt; OA
</pre>
<h2 id="functions-12"><a class="header" href="#functions-12">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>ProvideLiquidity</strong></td><td><code>expected_vault_ratio_range: Option&lt;PrecDecimalRange&gt;</code></td><td>Provide liquidity to the pre-configured <strong>Supervault</strong> from the <strong>input account</strong>, using available balances of both assets, and deposit the <strong>LP tokens</strong> into the <strong>output account</strong>. Abort if the vault price ratio is not within the <code>expected_vault_ratio_range</code> (if specified). <em>Note</em>: <code>PrecDec</code> is a 27 decimal precision value.</td></tr>
</tbody></table>
</div>
<h2 id="configuration-12"><a class="header" href="#configuration-12">Configuration</a></h2>
<p>The library is configured on instantiation via the <code>LibraryConfig</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LibraryConfig {
    // Account from which the funds are LPed
    pub input_addr: LibraryAccountType,
    // Account to which the LP tokens are forwarded
    pub output_addr: LibraryAccountType,
    // Supervault address
    pub vault_addr: String,
    // LP configuration
    pub lp_config: LiquidityProviderConfig,
}

pub struct LiquidityProviderConfig {
    // Denoms of both native assets we are going to provide liquidity for
    pub asset_data: AssetData,
    // LP token denom for the supervault
    pub lp_denom: String,
}

pub struct PrecDecimalRange {
    pub min: PrecDec,
    pub max: PrecDec,
}

pub struct AssetData {
    pub asset1: String,
    pub asset2: String,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="supervaults-liquidity-withdrawer-library"><a class="header" href="#supervaults-liquidity-withdrawer-library">Supervaults Liquidity Withdrawer library</a></h1>
<p>The <strong>Valence Supervaults Withdrawer library</strong> library allows to <strong>liquidate Supervault LP shares</strong> via <strong>Neutron Supervaults</strong> from an <strong>input account</strong> and deposit the <strong>resulting underlying assets</strong> into an <strong>output account</strong>.</p>
<h2 id="high-level-flow-13"><a class="header" href="#high-level-flow-13">High-level flow</a></h2>
<pre class="mermaid">---
title: Supervaults Liquidity Withdrawer
---
graph LR
  IA((Input Account))
  OA((Output Account))
  P[Processor]
  S[Supervaults&lt;br&gt;Liquidity&lt;br&gt;Withdrawer]
  SV[Supervault]
  P -- 1/Withdraw Liquidity --&gt; S
  S -- 2/Query LP balance --&gt; IA
  S -- 3/Try Withdraw Liquidity --&gt; IA
  IA -- 4/Withdraw Liquidity&lt;br&gt;[LP shares] --&gt; SV
  IA -- 4'/Transfer underlying tokens --&gt; OA
</pre>
<h2 id="functions-13"><a class="header" href="#functions-13">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>WithdrawLiquidity</strong></td><td><code>expected_vault_ratio_range: Option&lt;PrecDecimalRange&gt;</code></td><td>Withdraw liquidity from the pre-configured <strong>Supervault</strong> from the <strong>input account</strong>, using available LP shares, and deposit the resulting <strong>underlying assets</strong> into the <strong>output account</strong>. Abort if the vault price ratio is not within the <code>expected_vault_ratio_range</code> (if specified). <em>Note</em>: <code>PrecDec</code> is a 27 decimal precision value.</td></tr>
</tbody></table>
</div>
<h2 id="configuration-13"><a class="header" href="#configuration-13">Configuration</a></h2>
<p>The library is configured on instantiation via the <code>LibraryConfig</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LibraryConfig {
    // Account from which the LP shares are liquidated
    pub input_addr: LibraryAccountType,
    // Account to which the resulting underlying tokens are forwarded
    pub output_addr: LibraryAccountType,
    // Supervault address
    pub vault_addr: String,
    // Liquidity withdrawal configuration
    pub lw_config: LiquidityWithdrawerConfig,
}

pub struct LiquidityWithdrawerConfig {
    // Denoms of both underlying native assets we are
    // expecting to receive upon withdrawal
    pub asset_data: AssetData,
    // LP token denom for the supervault
    pub lp_denom: String,
}

pub struct PrecDecimalRange {
    pub min: PrecDec,
    pub max: PrecDec,
}

pub struct AssetData {
    pub asset1: String,
    pub asset2: String,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="neutron-interchain-querier"><a class="header" href="#neutron-interchain-querier">Neutron Interchain Querier</a></h1>
<p><strong>Neutron Interchain Querier library</strong> enables Valence Programs to configure and carry out
KV-based queries enabled by the <code>interchainqueries</code> module on Neutron.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<h3 id="active-neutron-icq-relayer"><a class="header" href="#active-neutron-icq-relayer">Active Neutron ICQ relayer</a></h3>
<p>This library requires active <a href="https://github.com/neutron-org/neutron-query-relayer">Neutron ICQ Relayers</a> operating on the specified target route.</p>
<h3 id="valence-middleware-broker"><a class="header" href="#valence-middleware-broker">Valence Middleware broker</a></h3>
<p>Each KV-based query requires a correctly encoded key in order to be registered.
This library obtains the query keys from <a href="libraries/cosmwasm/./../../middleware/broker.html">Valence Middleware brokers</a>,
which expose particular type registries.</p>
<p>For a given KV-query to be performed, the underlying type registry must implement <code>IcqIntegration</code> trait
which in turn enables the following functionality:</p>
<ol>
<li><code>get_kv_key</code>, enabling the ability to get the correctly encoded <code>KVKey</code> for query registration</li>
<li><code>decode_and_reconstruct</code>, allowing to reconstruct the interchain query result</li>
</ol>
<p>Read more about the given type ICQ integration in the <a href="libraries/cosmwasm/./../../middleware/type_registry.html#neutron-interchain-query-integration">type registry documentation page</a>.</p>
<h3 id="valence-storage-account-1"><a class="header" href="#valence-storage-account-1">Valence Storage account</a></h3>
<p>Results received and meant for further processing by other libraries will be stored in
<a href="libraries/cosmwasm/../../accounts/storage_accounts.html">Storage Accounts</a>. Each instance of Neutron
IC querier will be associated with its own storage account.</p>
<h3 id="query-registration-fee"><a class="header" href="#query-registration-fee">Query registration fee</a></h3>
<p>Neutron <code>interchainqueries</code> module is configured to escrow a fee in order to register a query.
The fee parameter is dynamic and can be queried via the <code>interchainqueries</code> module.
Currently the fee is set to <code>100000untrn</code>, but it may change in the future.
Users must ensure that the fee is provided along with the query registration function call.</p>
<h3 id="query-deregistration"><a class="header" href="#query-deregistration">Query deregistration</a></h3>
<p>Interchain Query escrow payments can be reclaimed by submitting the <code>RemoveInterchainQuery</code> message.
Only the query owner (this contract) is able to submit this message.</p>
<p>Interchain Queries should be removed after they are no longer needed, however, that moment may be different for each Valence Program depending on its configuration.</p>
<h3 id="background-on-the-interchainqueries-module"><a class="header" href="#background-on-the-interchainqueries-module">Background on the <code>interchainqueries</code> module</a></h3>
<h4 id="query-registration-message-types"><a class="header" href="#query-registration-message-types">Query Registration Message types</a></h4>
<p>Interchain queries can be registered and unregistered by submitting the following <code>neutron-sdk</code> messages:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum NeutronMsg {
	// other variants
	RegisterInterchainQuery {
		/// **query_type** is a query type identifier ('tx' or 'kv' for now).
		query_type: String,

		/// **keys** is the KV-storage keys for which we want to get values from remote chain.
		keys: Vec&lt;KVKey&gt;,

		/// **transactions_filter** is the filter for transaction search ICQ.
		transactions_filter: String,

		/// **connection_id** is an IBC connection identifier between Neutron and remote chain.
		connection_id: String,

		/// **update_period** is used to say how often the query must be updated.
		update_period: u64,
	},
	RemoveInterchainQuery {
    query_id: u64,
	},
}
<span class="boring">}</span></code></pre></pre>
<p>where the <code>KVKey</code> is defined as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct KVKey {
    /// **path** is a path to the storage (storage prefix) where you want to read value by key (usually name of cosmos-packages module: 'staking', 'bank', etc.)
    pub path: String,

    /// **key** is a key you want to read from the storage
    pub key: Binary,
}
<span class="boring">}</span></code></pre></pre>
<p><code>RegisterInterchainQuery</code> variant can be applied for both <em>TX</em>- and <em>KV</em>-based queries.
Given that this library is meant for dealing with <em>KV</em>-based queries exclusively,
<code>transactions_filter</code> field is irrelevant.</p>
<p>This library constructs the query registration message as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // helper
    let kv_registration_msg = NeutronMsg::register_interchain_query(
        QueryPayload::KV(vec![query_kv_key]),
        "connection-3".to_string(),
        5,
    );
    // which translates to:
    let kv_registration_msg = NeutronMsg::RegisterInterchainQuery {
        query_type: QueryType::KV.into(),
        keys: vec![query_kv_key],
        transactions_filter: String::new(),
        connection_id: "connection-3".to_string(),
        update_period: 5,
    }
<span class="boring">}</span></code></pre></pre>
<p><code>query_kv_key</code> here is obtained by querying the associated Middleware Broker for a given type and query parameters.</p>
<h4 id="query-result-message-types"><a class="header" href="#query-result-message-types">Query Result Message types</a></h4>
<p>After a query is registered and fetched back to Neutron, its results can be queried with the following Neutron query:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum NeutronQuery {
    /// Query a result of registered interchain query on remote chain
    InterchainQueryResult {
        /// **query_id** is an ID registered interchain query
        query_id: u64,
    },
	// other types
}
<span class="boring">}</span></code></pre></pre>
<p>which will return the interchain query result:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct InterchainQueryResult {
    /// **kv_results** is a raw key-value pairs of query result
    pub kv_results: Vec&lt;StorageValue&gt;,

    /// **height** is a height of remote chain
    pub height: u64,

    #[serde(default)]
    /// **revision** is a revision of remote chain
    pub revision: u64,
}
<span class="boring">}</span></code></pre></pre>
<p>where <code>StorageValue</code> is defined as:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Describes value in the Cosmos-SDK KV-storage on remote chain
pub struct StorageValue {
    /// **storage_prefix** is a path to the storage (storage prefix) where you want to read
    /// value by key (usually name of cosmos-packages module: 'staking', 'bank', etc.)
    pub storage_prefix: String,

    /// **key** is a key under which the **value** is stored in the storage on remote chain
    pub key: Binary,

    /// **value** is a value which is stored under the **key** in the storage on remote chain
    pub value: Binary,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="interchain-query-lifecycle"><a class="header" href="#interchain-query-lifecycle">Interchain Query lifecycle</a></h2>
<p>After <code>RegisterInterchainQuery</code> message is submitted, <code>interchainqueries</code> module will deduct
the query registration fee from the caller.</p>
<p>At that point the query is assigned its unique <code>query_id</code> identifier, which is not known in advance.
This identifier is returned to the caller in the reply.</p>
<p>Once the query is registered, the interchain query relayers perform the following steps:</p>
<ol>
<li>fetch the specified value from the target domain</li>
<li>post the query result to <code>interchainqueries</code> module</li>
<li>trigger <code>SudoMsg::KVQueryResult</code> endpoint on the contract that registered the query</li>
</ol>
<p><code>SudoMsg::KVQueryResult</code> does not carry back the actual query result. Instead, it posts back
a <code>query_id</code> of the query which had been performed, announcing that its result is available.</p>
<p>Obtained <code>query_id</code> can then be used to query the <code>interchainqueries</code> module for the <strong>raw</strong>
interchainquery result. One thing to note here is that these raw results are not meant to be
(natively) interpreted by foreign VMs; instead, they will adhere to the encoding schemes of
the origin domain.</p>
<h2 id="library-high-level-flow"><a class="header" href="#library-high-level-flow">Library high-level flow</a></h2>
<p>At its core, this library should enable three key functions:</p>
<ol>
<li>initiating the interchain queries</li>
<li>receiving &amp; postprocessing the query results</li>
<li>reclaiming the escrowed fees by unregistering the queries</li>
</ol>
<p>Considering that Valence Programs operate across different VMs and adhere to their rules,
these functions can be divided into two categories:</p>
<ol>
<li>external operations (Valence &lt;&gt; host VM)</li>
<li>internal operations (Valence &lt;&gt; Valence)</li>
</ol>
<p>From this perspective, query initiation, receival, and termination can be seen as external
operations that adhere to the functionality provided by the <code>interchainqueries</code> module on Neutron.</p>
<p>On the other hand, query result postprocessing involves internal Valence Program operations.
KV-Query query results fetched from remote domains are not readily useful within the Valence
scope because of their encoding formats. Result postprocessing is therefore about adapting
remote domain data types into <a href="libraries/cosmwasm/./../../middleware/valence_types.html">canonical Valence Protocol data types</a>
that can be reasoned about.</p>
<blockquote>
<p>For most Cosmos SDK based chains, KV-storage values are encoded in protobuf. Interpreting
protobuf from within CosmWasm context is not straightforward and requires explicit conversion
steps. Other domains may store their state in other encoding formats. This library does not
make any assumptions about the different encoding schemes that remote domains may be subject
to - instead, that responsibility is handed over to <a href="libraries/cosmwasm/./../../middleware/_overview.html">Valence Middleware</a>.</p>
</blockquote>
<p>Final step in result postprocessing is about persisting the canonicalized query results.
Resulting Valence Types are written into a <a href="libraries/cosmwasm/../../accounts/storage_accounts.html">Storage Account</a>,
making it available for further processing, interpretation, or other types of processing.</p>
<h2 id="library-lifecycle"><a class="header" href="#library-lifecycle">Library Lifecycle</a></h2>
<p>With the baseline functionality in mind, there are a few design decisions
that shape the overall lifecycle of this library.</p>
<h3 id="instantiation-flow"><a class="header" href="#instantiation-flow">Instantiation flow</a></h3>
<p>Neutron Interchain Querier is instantiated with the full configuration needed
to initiate and process the queries that it will be capable of executing.
After instantiation, the library has the full context needed to carry out its
functions.</p>
<p>Library is configured with the following <code>LibraryConfig</code>. Further sections
will focus on each of its fields.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LibraryConfig {
    pub storage_account: LibraryAccountType,
    pub querier_config: QuerierConfig,
    pub query_definitions: BTreeMap&lt;String, QueryDefinition&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h4 id="storage-account-association"><a class="header" href="#storage-account-association">Storage Account association</a></h4>
<p>Like other libraries, Neutron IC querier has a notion of its associated account.</p>
<p>Associated Storage account will authorize libraries like Neutron IC Querier
to persist canonical Valence types under its storage.</p>
<p>Unlike most other libraries, IC querier does not differentiate between input and
output accounts. There is just an account, and it is the only account that this
library will be authorized to post its results into.</p>
<p>Storage account association follows the same logic of approving/revoking
libraries. Its configuration is done via <code>LibraryAccountType</code>, following
the same account pattern as other libraries.</p>
<h4 id="global-configurations-that-apply-to-all-queries"><a class="header" href="#global-configurations-that-apply-to-all-queries">Global configurations that apply to all queries</a></h4>
<p>While this library is capable of carrying out an arbitrary number of distinct
interchain queries, their scope is bound by <code>QuerierConfig</code></p>
<p><code>QuerierConfig</code> describes ICQ parameters that will apply to every query to be
managed by this library. It can be seen as the global configuration parameters,
of which there are two:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct QuerierConfig {
    pub broker_addr: String,
    pub connection_id: String,
}
<span class="boring">}</span></code></pre></pre>
<p><code>connection_id</code> here describes the IBC connection between Neutron and the
target domain. This effectively limits each instance of Neutron IC Querier to
be responsible for querying one particular domain.</p>
<p><code>broker_addr</code> describes the address of the associated middleware broker.
Just as all queries are going to be bound by a particular connection id,
they will also be postprocessed using a single broker instance.</p>
<h4 id="query-configurations"><a class="header" href="#query-configurations">Query configurations</a></h4>
<p>Queries to be carried out by this library are configured with the following
type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct QueryDefinition {
    pub registry_version: Option&lt;String&gt;,
    pub type_url: String,
    pub update_period: Uint64,
    pub params: BTreeMap&lt;String, Binary&gt;,
    pub query_id: Option&lt;u64&gt;,
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>registry_version: Option&lt;String&gt;</code> specifies which version of the type registry
the middleware broker should use. When set to <code>None</code>, the broker uses its latest
available type registry version. Set this field when a specific type registry
version is needed instead of the latest one.</li>
<li><code>type_url: String</code> identifies the query type within the type registry (via broker).
An important thing to note here is that this url may differ from the one used to
identify the target type on its origin domain. This decoupling is done intentionally
in order to allow for flexible type mapping between domains when necessary.</li>
<li><code>update_period: Uint64</code> specifies how often the given query should be performed/updated</li>
<li><code>params: BTreeMap&lt;String, Binary&gt;</code> provides the type registry with the base64
encoded query parameters that are going to be used for <code>KVKey</code> construction</li>
<li><code>query_id: Option&lt;u64&gt;</code> is an internal parameter that gets modified during runtime.
It must be set to <code>None</code> when configuring the library.</li>
</ul>
<p>Every query definition must be associated with a unique string-based identifier (key).
Query definitions are passed to the library config via <code>BTreeMap&lt;String, QueryDefinition&gt;</code>,
which ensures that there is only one <code>QueryDefinition</code> for every key. While these
keys can be anything, they should clearly identify a particular query. Every function
call exposed by this library expects these keys (and only these keys) as their arguments.</p>
<h3 id="execution-flow"><a class="header" href="#execution-flow">Execution flow</a></h3>
<p>With Neutron IC Querier instantiated, the library is ready to start carrying
out the queries.</p>
<h4 id="query-registration"><a class="header" href="#query-registration">Query registration</a></h4>
<p>Configured queries can be registered with the following function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>RegisterKvQuery { target_query: String }
<span class="boring">}</span></code></pre></pre>
<p>Query registration flow consists of the following steps:</p>
<ol>
<li>querying the <code>interchainqueries</code> module for the currently set query
registration fee and asserting that the function caller covered all
expected fees</li>
<li>querying the middleware broker to obtain the <code>KVKey</code> value to be used
in ICQ registration</li>
<li>constructing and firing the ICQ registration message</li>
</ol>
<p>Each configured query can be started with this function call.</p>
<h4 id="query-result-processing"><a class="header" href="#query-result-processing">Query result processing</a></h4>
<p>Interchain Query results are delivered to the <code>interchainqueries</code> module
in an asynchronous manner. To ensure that query results are available to
Valence Programs as fresh as possible, this library leverages <code>sudo</code> callbacks
that are triggered after ICQ relayers post back the results for a query
registered by this library.</p>
<p>This entry point is configured as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn sudo(deps: ExecuteDeps, _env: Env, msg: SudoMsg) -&gt; StdResult&lt;Response&lt;NeutronMsg&gt;&gt; {
    match msg {
        // this is triggered by the ICQ relayer delivering the query result
        SudoMsg::KVQueryResult { query_id } =&gt; handle_sudo_kv_query_result(deps, query_id),
        _ =&gt; Ok(Response::default()),
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This function call triggers a set of actions that will process the raw query
result into a canonical Valence Type before storing it into the associated
Storage account:</p>
<ol>
<li>query the <code>interchainqueries</code> module to obtain the raw query result
associated with the given <code>query_id</code></li>
<li>query the broker to deserialize the proto-encoded result into a Rust type</li>
<li>query the broker to canonicalize the native rust type into <code>ValenceType</code></li>
<li>post the resulting canonical type to the associated storage account</li>
</ol>
<p>After these actions, the associated storage account will hold the adapted query
result in its storage on the same block as the result was brought into Neutron.</p>
<h4 id="query-deregistration-1"><a class="header" href="#query-deregistration-1">Query deregistration</a></h4>
<p>Actively registered queries can be removed from the active query set with the
following function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>DeregisterKvQuery { target_query: String }
<span class="boring">}</span></code></pre></pre>
<p>This function will perform two actions.</p>
<p>First it will query the <code>interchainqueries</code> module on Neutron for the <code>target_query</code>.
This is done in order to find the deposit fee that was escrowed upon query
registration.</p>
<p>Next, the library will submit the query removal request to the <code>interchainqueries</code>
module. If this request is successful, the deposit fee tokens will be transferred
to the sender that initiated this function.</p>
<h2 id="library-in-valence-programs"><a class="header" href="#library-in-valence-programs">Library in Valence Programs</a></h2>
<p>Neutron IC Querier does not behave as a standard library in that it does result in
any fungible outcome. Instead, it produces a data object in the form of Valence Type.</p>
<p>While that result could be posted directly to the state of this library,
instead, it is posted to an associated output account meant for storing data.
Just as some other libraries have a notion of input accounts that grant them
the permission of executing some logic, Neutron IC Querier has a notion of an
associated account which grants the querier a permission to writing some data
into its storage slots.</p>
<p>For example, consider a situation where this library had queried the balance of
some remote account, parsed the response into a Valence Balance type, and wrote
that resulting object into its associated storage account. That same associated
account may be the input account of some other library, which will attempt to
perform its function based on the content written to its input account. This may
involve something along the lines of: <code>if balance &gt; 0, do x; otherwise, do y;</code>.</p>
<p>With that, the IC Querier flow in a Valence Program may look like this:</p>
<pre class="mermaid">---
title: Neutron IC Querier in Valence Programs
---
graph LR
    A[neutron IC querier] --&gt;|post Valence type| B(storage account)
    C[other library] --&gt;|interpret Valence type| B
</pre>
<blockquote>
<p>Valence Middleware is being actively developed. More elaborate examples
of this library will be added here in the future.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="valence-drop-liquid-staker-library"><a class="header" href="#valence-drop-liquid-staker-library">Valence Drop Liquid Staker library</a></h1>
<p>The <strong>Valence Drop Liquid Staker</strong> library allows to <strong>liquid stake</strong> an asset from an <strong>input account</strong> in the <a href="https://docs.drop.money/">Drop protocol</a> and deposit the liquid staking derivate into the <strong>output account</strong>. It is typically used as part of a <strong>Valence Program</strong>. In that context, a <strong>Processor</strong> contract will be the main contract interacting with the Forwarder library.</p>
<h2 id="high-level-flow-14"><a class="header" href="#high-level-flow-14">High-level flow</a></h2>
<pre class="mermaid">---
title: Drop Liquid Staker Library
---
graph LR
  IA((Input
      Account))
  CC((Drop Core
      Contract))
  OA((Output
      Account))
  P[Processor]
  S[Drop Liquid Staker
      Library]
  P -- 1/Liquid Stake --&gt; S
  S -- 2/Query balance --&gt; IA
  S -- 3/Do Liquid 
  Stake funds --&gt; IA
  IA -- 4/Liquid Stake
   funds --&gt; CC
  CC -- 5/Send LS 
  derivative --&gt; OA
</pre>
<h2 id="functions-14"><a class="header" href="#functions-14">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>LiquidStake</strong></td><td>ref (Optional): <a href="https://docs.drop.money/integrations/referral">referral address</a></td><td>Liquid stakes the balance of the <strong>input account</strong> into the <strong>drop core contract</strong> and deposits LS derivative into the <strong>output account</strong>.</td></tr>
</tbody></table>
</div>
<h2 id="configuration-14"><a class="header" href="#configuration-14">Configuration</a></h2>
<p>The library is configured on instantiation via the <code>LibraryConfig</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LibraryConfig {
    pub input_addr: LibraryAccountType,
    pub output_addr: LibraryAccountType,
    // Address of the liquid staker contract (drop core contract)
    pub liquid_staker_addr: String,
    // Denom of the asset we are going to liquid stake
    pub denom: String,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="valence-drop-liquid-unstaker-library"><a class="header" href="#valence-drop-liquid-unstaker-library">Valence Drop Liquid Unstaker library</a></h1>
<p>The <strong>Valence Drop Liquid Unstaker</strong> library allows liquid staked tokens (e.g., dNTRN or dATOM) to be redeemed for underlying assets (e.g., NTRN or ATOM) through the <a href="https://docs.drop.money/">Drop protocol</a>. The liquid staked asset must be available in the <strong>input account</strong>. When the library's function to redeem the staked assets (<code>Unstake</code>) is invoked, the library issues a withdraw request to the Drop protocol generating a tokenized voucher that is held by the input account. This tokenized voucher can be used to claim the underlying assets (represented as an NFT). Note that the underlying assets are not withdrawn immediately, as the Drop protocol unstakes assets asynchronously. At a later time, when the underlying assets are available for withdrawal, the library's claim function can be invoked with the voucher as an argument. This function will withdraw the underlying assets and deposit them into the <strong>output account</strong>.</p>
<h2 id="high-level-flow-15"><a class="header" href="#high-level-flow-15">High-level flow</a></h2>
<pre class="mermaid">---
title: Drop Liquid Unstaker Library - Unstake Flow
---
graph LR
    IA((Input Account))
    CC((Drop Core Contract))
    P2[Processor]
    S2[Drop Liquid
    Unstaker Library]
    P2 -- &quot;1/Unstake&quot; --&gt; S2
    S2 -- &quot;2/Query balance&quot; --&gt; IA
    S2 -- &quot;3/Do Unstake funds&quot; --&gt; IA
    IA -- &quot;4/Unstake funds&quot; --&gt; CC
    CC -- &quot;5/Send NFT voucher&quot; --&gt; IA
</pre>
<pre class="mermaid">---
title: Drop Liquid Unstaker Library - Withdraw Flow
---
graph LR
    IA((Input Account))
    WW((Withdrawal Manager
    Contract))
    P1[Processor]
    S1[Drop Liquid
    Unstaker Library]
    OA((Output Account))
    P1 -- &quot;1/Withdraw (token_id)&quot; --&gt; S1
    S1 -- &quot;2/Check ownership&quot; --&gt; IA
    S1 -- &quot;3/Do Withdraw&quot; --&gt; IA
    IA -- &quot;4/Send NFT voucher with
    ReceiveMsg&quot; --&gt; WW
    WW -- &quot;5/Send unstaked funds&quot; --&gt; OA
</pre>
<h2 id="functions-15"><a class="header" href="#functions-15">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>Unstake</strong></td><td></td><td>Unstakes the balance of the <strong>input account</strong> from the <strong>drop core contract</strong> and deposits the <strong>voucher</strong> into the <strong>input account</strong>.</td></tr>
<tr><td><strong>Withdraw</strong></td><td>token_id</td><td>Withdraws the voucher with <strong>token_id</strong> identifier from the <strong>input account</strong> and deposits the unstaked assets into the <strong>output account</strong>.</td></tr>
</tbody></table>
</div>
<h2 id="configuration-15"><a class="header" href="#configuration-15">Configuration</a></h2>
<p>The library is configured on instantiation via the <code>LibraryConfig</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LibraryConfig {
    pub input_addr: LibraryAccountType,
    pub output_addr: LibraryAccountType,
    // Address of the liquid unstaker contract (drop core contract)
    pub liquid_unstaker_addr: String,
    // Address of the withdrawal_manager_addr (drop withdrawal manager)
    pub withdrawal_manager_addr: String,
    // Address of the voucher NFT contract that we get after unstaking and we use for the withdraw
    pub voucher_addr: String,
    // Denom of the asset we are going to unstake
    pub denom: String,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="valence-ica-cctp-transfer-library"><a class="header" href="#valence-ica-cctp-transfer-library">Valence ICA CCTP Transfer Library</a></h1>
<p>The <strong>Valence ICA CCTP Transfer Library</strong> library allows remotely executing a <strong>CCTP transfer</strong> using a <strong>Valence interchain account</strong> on <a href="https://www.noble.xyz/">Noble Chain</a>. It does that by remotely sending a <strong>MsgDepositForBurn</strong> to the ICS-27 ICA created by the <strong>Valence interchain account</strong> on Noble. It is typically used as part of a <strong>Valence Program</strong>. In that context, a <strong>Processor</strong> contract will be the main contract interacting with the <strong>Valence ICA CCTP Transfer Library</strong>.</p>
<h2 id="high-level-flow-16"><a class="header" href="#high-level-flow-16">High-level flow</a></h2>
<pre class="mermaid">---
title: ICA CCTP Transfer Library
---
graph LR
    subgraph Neutron
      P[Processor]
      L[ICA CCTP
      Transfer Library]
      I[Input Account]
      P -- 1)Transfer --&gt; L
      L -- 2)Query ICA address --&gt; I
      L -- 3)Do ICA MsgDepositForBurn --&gt; I
    end

    subgraph Noble
      ICA[Interchain Account]
      I -- 4)Execute MsgDepositForBurn--&gt; ICA
    end
</pre>
<h2 id="functions-16"><a class="header" href="#functions-16">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>Transfer</strong></td><td>-</td><td>Transfer funds with CCTP on Noble from the ICA created by the <strong>input_acount</strong> to a <strong>mint_recipient</strong> on a <strong>destination_domain_id</strong></td></tr>
</tbody></table>
</div>
<h2 id="configuration-16"><a class="header" href="#configuration-16">Configuration</a></h2>
<p>The library is configured on instantiation via the <code>LibraryConfig</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LibraryConfig {
    // Address of the input account (Valence interchain account)
    pub input_addr: LibraryAccountType,
    // Amount that is going to be transferred
    pub amount: Uint128,
    // Denom that is going to be transferred
    pub denom: String,
    // Destination domain id
    pub destination_domain_id: u32,
    // This address is the bytes representation of the address (with 32 length and padded zeroes)
    // For more information, check https://docs.noble.xyz/cctp/mint#example
    pub mint_recipient: Binary,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="valence-ica-ibc-transfer-library"><a class="header" href="#valence-ica-ibc-transfer-library">Valence ICA IBC Transfer Library</a></h1>
<p>The <strong>Valence ICA IBC Transfer Library</strong> library allows remotely executing an <strong>IBC transfer</strong> using a <strong>Valence interchain account</strong> on a remote IBC connected domain. It does that by remotely sending a <strong>MsgTransfer</strong> to the ICA created by the <strong>Valence interchain account</strong> on the remote domain. It is typically used as part of a <strong>Valence Program</strong>. In that context, a <strong>Processor</strong> contract will be the main contract interacting with the <strong>Valence ICA IBC Transfer Library</strong>.</p>
<h2 id="high-level-flow-17"><a class="header" href="#high-level-flow-17">High-level flow</a></h2>
<pre class="mermaid">---
title: ICA IBC Transfer Library
---
graph LR
    subgraph Neutron
      P[Processor]
      L[ICA IBC
      Transfer Library]
      I[Input Account]
      P -- 1)Transfer --&gt; L
      L -- 2)Query ICA address --&gt; I
      L -- 3)Do ICA MsgTransfer --&gt; I
    end

    subgraph Remote domain
      ICA[Interchain Account]
      I -- 4)Execute MsgTransfer --&gt; ICA
    end
</pre>
<h2 id="functions-17"><a class="header" href="#functions-17">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>Transfer</strong></td><td>-</td><td>Transfer funds using IBC from the ICA created by the <strong>input_acount</strong> to a <strong>receiver</strong> on a remote domain using the IBC <strong>channel_id</strong></td></tr>
<tr><td><strong>EurekaTransfer</strong></td><td>eureka_fee</td><td>Transfer funds over IBC from an <strong>input account</strong> on a source chain to an <strong>output account</strong> on a destination EVM chain using IBC Eureka. The eureka_fee parameter will contain the amount to be paid to a relayer address on the intermediate chain along with the timeout of this fee. All this information can be obtained from a Skip Go query explained in the IBC Eureka section below. <strong>Important</strong>: the fee timeout is passed in nanoseconds</td></tr>
</tbody></table>
</div>
<h2 id="configuration-17"><a class="header" href="#configuration-17">Configuration</a></h2>
<p>The library is configured on instantiation via the <code>LibraryConfig</code> type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LibraryConfig {
    // Address of the input account (Valence interchain account)
    pub input_addr: LibraryAccountType,
    // Amount that is going to be transferred
    pub amount: Uint128,
    // Denom that is going to be transferred
    pub denom: String,
    // Receiver on the other chain
    pub receiver: String,
    // Memo to be passed in the IBC transfer message.
    pub memo: String,
    // Remote chain info
    pub remote_chain_info: RemoteChainInfo,
    // Denom map for the Packet-Forwarding Middleware, to perform a multi-hop transfer.
    pub denom_to_pfm_map: BTreeMap&lt;String, PacketForwardMiddlewareConfig&gt;,
    // Configuration used for IBC Eureka transfers
    pub eureka_config: Option&lt;EurekaConfig&gt;,
}

pub struct RemoteChainInfo {
    // Channel ID to be used
    pub channel_id: String,
    // Timeout for the IBC transfer in seconds. If not specified, a default 600 seconds will be used will be used
    pub ibc_transfer_timeout: Option&lt;u64&gt;,
}

// Configuration for a multi-hop transfer using the Packet Forwarding Middleware
struct PacketForwardMiddlewareConfig {
  // Channel ID from the source chain to the intermediate chain
  local_to_hop_chain_channel_id: String,
  // Channel ID from the intermediate to the destination chain
  hop_to_destination_chain_channel_id: String,
  // Temporary receiver address on the intermediate chain. Typically this is set to an invalid address so the entire transaction will revert if the forwarding fails. If not
  // provided it's set to "pfm"
  hop_chain_receiver_address: Option&lt;String&gt;,
}

// Configuration for IBC Eureka transfers
pub struct EurekaConfig {
    /// The address of the contract on intermediate chain that will receive the callback.
    pub callback_contract: String,
    /// The address of the contract on intermediate chain that will trigger the actions, in this case the Eureka transfer.
    pub action_contract: String,
    /// Recover address on intermediate chain in case the transfer fails
    pub recover_address: String,
    /// Source channel on the intermediate chain (e.g. "08-wasm-1369")
    pub source_channel: String,
    /// Optional memo for the Eureka transfer triggered by the contract. Not used right now but could eventually be used.
    pub memo: Option&lt;String&gt;,
    /// Timeout in seconds to be used for the Eureka transfer. For reference, Skip Go uses 12 hours (43200). If not passed we will use that default value
    pub timeout: Option&lt;u64&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="packet-forward-middleware-2"><a class="header" href="#packet-forward-middleware-2">Packet-Forward Middleware</a></h3>
<p>The library supports multi-hop IBC transfers using the Packet Forward Middleware (PFM).
This allows tokens to be transferred through an intermediate chain to reach their final
destination. More information about the PFM functionality can be found in the <a href="https://github.com/cosmos/ibc-apps/tree/main/middleware/packet-forward-middleware">official
documentation</a>.</p>
<p>This works in the same way as the <strong>Generic IBC Transfer Library</strong>. The only difference is that the <strong>input account</strong> is a <strong>Valence interchain account</strong> and the <strong>receiver</strong> is a remote address on the remote domain. For more details on how PFM works, check the <a href="libraries/cosmwasm/./generic_ibc_transfer.html#packet-forward-middleware">Generic IBC Transfer Library PFM</a> documentation.</p>
<h3 id="ibc-eureka-2"><a class="header" href="#ibc-eureka-2">IBC Eureka</a></h3>
<p>This library supports IBC Eureka transfers using an intermediate chain. This allows tokens to be transferred from the origin chain to EVM chains connected with IBC Eureka using standard IBC transfers together with Skip Go capabilities. For more information on how IBC Eureka works with Skip Go, please refer to this <a href="https://docs.skip.build/go/eureka/eureka-overview">Eureka overview</a>.</p>
<p>This works in the same way as the <strong>Generic IBC Transfer Library</strong>. The only difference is that the <strong>input account</strong> is a <strong>Valence interchain account</strong> and the <strong>receiver</strong> is a remote address on the remote EVM chain. For more details on how IBC Eureka works, check the <a href="libraries/cosmwasm/./generic_ibc_transfer.html#ibc-eureka">Generic IBC Transfer Library IBC Eureka</a> documentation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="evm-libraries"><a class="header" href="#evm-libraries">EVM Libraries</a></h1>
<p>This section contains a detailed description of all the libraries that can be used in EVM Execution Environments.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="valence-forwarder-library-1"><a class="header" href="#valence-forwarder-library-1">Valence Forwarder Library</a></h1>
<p>The <strong>Valence Forwarder</strong> library allows to <strong>continuously forward funds</strong> from an <strong>input account</strong> to an <strong>output account</strong>, following some time <strong>constraints</strong>. It is typically used as part of a <strong>Valence Program</strong>. In that context, a <strong>Processor</strong> contract will be the main contract interacting with the Forwarder library.</p>
<h2 id="high-level-flow-18"><a class="header" href="#high-level-flow-18">High-level flow</a></h2>
<pre class="mermaid">---
title: Forwarder Library
---
graph LR
  IA((Input
      Account))
  OA((Output
		  Account))
  P[Processor]
  S[Forwarder
    Library]
  P -- 1/Forward --&gt; S
  S -- 2/Query balances --&gt; IA
  S -- 3/Do Send funds --&gt; IA
  IA -- 4/Send funds --&gt; OA
</pre>
<h2 id="functions-18"><a class="header" href="#functions-18">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>Forward</strong></td><td>-</td><td>Forward funds from the configured <strong>input account</strong> to the <strong>output account</strong>, according to the <strong>forwarding configs</strong> &amp; <strong>min interval</strong>.</td></tr>
</tbody></table>
</div>
<h2 id="configuration-18"><a class="header" href="#configuration-18">Configuration</a></h2>
<p>The library is configured on deployment using the <code>ForwarderConfig</code> type.</p>
<pre><code class="language-solidity">    /**
     * @dev Configuration for a single token forwarding rule
     * @param tokenAddress Address of token to forward (0x0 for native coin)
     * @param maxAmount Maximum amount to forward per execution
     */
    struct ForwardingConfig {
        address tokenAddress;
        uint256 maxAmount;
    }

    /**
     * @dev Interval type for forwarding: time-based or block-based
     */
    enum IntervalType {
        TIME,
        BLOCKS
    }

    /**
     * @dev Main configuration struct
     * @param inputAccount Source account
     * @param outputAccount Destination account
     * @param forwardingConfigs Array of token forwarding rules
     * @param intervalType Whether to use time or block intervals
     * @param minInterval Minimum interval between forwards
     */
    struct ForwarderConfig {
        Account inputAccount;
        Account outputAccount;
        ForwardingConfig[] forwardingConfigs;
        IntervalType intervalType;
        uint64 minInterval;
    }

    /**
     * @dev Tracks last execution time/block
     */
    struct LastExecution {
        uint64 blockHeight;
        uint64 timestamp;
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="valence-cctp-transfer-library"><a class="header" href="#valence-cctp-transfer-library">Valence CCTP Transfer library</a></h1>
<p>The <strong>Valence CCTP Transfer</strong> library allows to <strong>transfer funds</strong> from an <strong>input account</strong> to a <strong>mint recipient</strong> using the <a href="https://developers.circle.com/stablecoins/cctp-getting-started">Cross-Chain Transfer Protocol (CCTP) v1</a>. It is typically used as part of a <strong>Valence Program</strong>. In that context, a <strong>Processor</strong> contract will be the main contract interacting with the CCTP Transfer library.</p>
<h2 id="high-level-flow-19"><a class="header" href="#high-level-flow-19">High-level flow</a></h2>
<pre class="mermaid">---
title: CCTP Transfer Library
---
graph LR
  IA((Input Account))
  CCTPR((CCTP Relayer))
  MR((Mint Recipient))
  TM((CCTP Token Messenger))
  P[Processor]
  S[CCTP Transfer Library]

  subgraph DEST[ Destination Domain ]
    CCTPR -- 7/Mint tokens --&gt; MR
  end

  subgraph EVM[ EVM Domain ]
    P -- 1/Transfer --&gt; S
    S -- 2/Query balances --&gt; IA
    S -- 3/Do approve and call depositForBurn --&gt; IA
    IA -- 4/ERC-20 approve --&gt; TM
    IA -- 5/Call depositForBurn --&gt; TM
    TM -- 6/Burn tokens and emit event --&gt; TM
  end

  EVM --- DEST
</pre>
<h2 id="functions-19"><a class="header" href="#functions-19">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>Transfer</strong></td><td>-</td><td>Transfer funds from the configured <strong>input account</strong> to the <strong>mint recipient</strong> on the <strong>destination domain</strong>.</td></tr>
</tbody></table>
</div>
<h2 id="configuration-19"><a class="header" href="#configuration-19">Configuration</a></h2>
<p>The library is configured on deployment using the <code>CCTPTransferConfig</code> type. A list of the supported CCTP destination domains that can be used in the <code>destinationDomain</code> field can be found <a href="https://developers.circle.com/stablecoins/supported-domains">here</a>.</p>
<pre><code class="language-solidity">    /**
     * @dev Configuration struct for token transfer parameters.
     * @param amount The number of tokens to transfer. If set to 0, the entire balance is transferred.
     * @param mintRecipient The recipient address (in bytes32 format) on the destination chain where tokens will be minted.
     * @param inputAccount The account from which tokens will be debited.
     * @param destinationDomain The domain identifier for the destination chain.
     * @param cctpTokenMessenger The CCTP Token Messenger contract.
     * @param transferToken The ERC20 token address that will be transferred.
     */
    struct CCTPTransferConfig {
        uint256 amount; // If we want to transfer all tokens, we can set this to 0.
        bytes32 mintRecipient;
        Account inputAccount;
        uint32 destinationDomain;
        ITokenMessenger cctpTokenMessenger;
        address transferToken;
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="valence-stargate-transfer-library"><a class="header" href="#valence-stargate-transfer-library">Valence Stargate Transfer library</a></h1>
<p>The <strong>Valence Stargate Transfer</strong> library allows to <strong>transfer funds</strong> from an <strong>input account</strong> to a <strong>recipient</strong> using the <a href="https://stargateprotocol.gitbook.io/stargate/v2-developer-docs">Stargate Protocol v2</a> built on top of LayerZero v2. It is typically used as part of a <strong>Valence Program</strong>. In that context, a <strong>Processor</strong> contract will be the main contract interacting with the Stargate Transfer library.</p>
<h2 id="high-level-flow-20"><a class="header" href="#high-level-flow-20">High-level flow</a></h2>
<pre class="mermaid">---
title: Stargate Transfer Library
---
graph LR
  IA((Input Account))
  SE((Stargate Executor))
  R((Recipient))
  SP((Stargate Pool))
  SEP((Stargate Endpoint))
  P[Processor]
  S[Stargate Transfer Library]

  subgraph DEST[ Destination Domain ]
    SE -- 8/Mint tokens --&gt; R
  end

  subgraph EVM[ EVM Domain ]
    P -- 1/Transfer --&gt; S
    S -- 2/Query native or ERC20 balance --&gt; IA
    S -- 3/Send native balance or Approve ERC20 and call sendToken --&gt; IA
    IA -- 4/Approve ERC20 (if applies) --&gt; SP
    IA -- 5/Call sendToken and send native token (if applies) --&gt; SP
    SP -- 6/Lock/burn token --&gt; SP
    SP -- 7/Send Fees --&gt; SEP
  end

  EVM --- DEST
</pre>
<h2 id="functions-20"><a class="header" href="#functions-20">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>Transfer</strong></td><td>-</td><td>Transfer funds from the configured <strong>input account</strong> to the <strong>recipient</strong> on the <strong>destination domain</strong>.</td></tr>
</tbody></table>
</div>
<h2 id="configuration-20"><a class="header" href="#configuration-20">Configuration</a></h2>
<p>The library is configured on deployment using the <code>StargateTransferConfig</code> type. A list of supported Stargate destination domains that can be used in the <code>destinationDomain</code> field can be found <a href="https://stargateprotocol.gitbook.io/stargate/v2-developer-docs/technical-reference/mainnet-contracts">here</a>.</p>
<pre><code class="language-solidity">    /**
     * @title StargateTransferConfig
     * @notice Configuration struct for cross-chain token transfers via Stargate Protocol
     * @dev Used to define parameters for LayerZero cross-chain messaging with Stargate
     * @param recipient The recipient address (in bytes32 format) on the destination chain
     * @param inputAccount The account from which tokens will be transferred
     * @param destinationDomain The destination chain endpoint ID. Find all IDs at https://stargateprotocol.gitbook.io/stargate/v2-developer-docs/technical-reference/mainnet-contracts
     * @param stargateAddress Stargate pool address implementing IOFT interface. See https://github.com/stargate-protocol/stargate-v2/blob/main/packages/stg-evm-v2/src/interfaces/IStargate.sol
     * @param transferToken Address of the token to transfer. If transferring native tokens, this will be the zero address (address(0))
     * @param amount Amount of tokens to transfer. If set to 0, all available tokens will be transferred
     * @param minAmountToReceive Minimum amount to receive on destination after fees. If set to 0, fees will be automatically calculated
     * @param refundAddress Address to refund tokens in case of failed transfer. If set to address(0), tokens will be refunded to the input account
     * @param extraOptions Additional options for the LayerZero message. Optional. See https://docs.layerzero.network/v2/developers/evm/protocol-gas-settings/options#option-types
     * @param composeMsg Message to execute logic on the destination chain. Optional. See https://docs.layerzero.network/v2/developers/evm/composer/overview#composing-an-oft--onft
     * @param oftCmd Indicates the transportation mode in Stargate. Empty bytes for "Taxi" mode, bytes(1) for "Bus" mode. See https://stargateprotocol.gitbook.io/stargate/v2-developer-docs/integrate-with-stargate/how-to-swap#sendparam.oftcmd
     */
    struct StargateTransferConfig {
        bytes32 recipient;
        Account inputAccount;
        uint32 destinationDomain;
        IStargate stargateAddress;
        address transferToken;
        uint256 amount;
        uint256 minAmountToReceive;
        address refundAddress;
        bytes extraOptions;
        bytes composeMsg;
        bytes oftCmd;
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standard-bridge-transfer-library"><a class="header" href="#standard-bridge-transfer-library">Standard Bridge Transfer library</a></h1>
<p>The Standard Bridge Transfer library enables transferring funds from an <strong>input account</strong> to a <strong>recipient</strong> using a <a href="https://docs.optimism.io/app-developers/bridging/standard-bridge">StandardBridge contract</a>. This library works with both the L1StandardBridge and L2StandardBridge implementations, allowing token transfers between Ethereum (Layer 1) and its scaling solutions like Optimism or Base (Layer 2). The library facilitates seamless bridging of assets in both directions - from L1 to L2 and from L2 to L1. It is typically used as part of a <strong>Valence Program</strong>. In that context, a <strong>Processor</strong> contract will be the main contract interacting with the Stargate Transfer library.</p>
<h2 id="high-level-flow-21"><a class="header" href="#high-level-flow-21">High-level flow</a></h2>
<pre class="mermaid">---
title: Standard Bridge Transfer Library
---
graph LR
  IA((Input Account))
  R((Recipient))
  SBO((Standard Bridge))
  SBD((Standard Bridge))
  P[Processor]
  S[StandardBridgeTransfer
   Library]

  subgraph DEST[ Destination Chain ]
    SBD -- 5/WithdrawTo --&gt; R
  end

  subgraph SRC[ Source Chain ]
    P -- 1/Transfer --&gt; S
    S -- 2/Query native or ERC20 balance --&gt; IA
    IA -- 3/Approve ERC20 (if applies) --&gt; SBO
    IA -- 4/Call bridgeETHTo or bridgeERC20To --&gt; SBO
  end

  SRC --- DEST
</pre>
<h2 id="functions-21"><a class="header" href="#functions-21">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>Transfer</strong></td><td>-</td><td>Transfer funds from the configured <strong>input account</strong> to the <strong>recipient</strong> on the destination chain.</td></tr>
</tbody></table>
</div>
<h2 id="configuration-21"><a class="header" href="#configuration-21">Configuration</a></h2>
<p>The library is configured on deployment using the <code>StandardBridgeTransferConfig</code> type. More information on the config parameters can be found <a href="https://docs.optimism.io/app-developers/bridging/standard-bridge">here</a>.</p>
<pre><code class="language-solidity">    /**
     * @dev Configuration struct for StandardBridge transfer parameters.
     * @param amount The number of tokens to transfer. If set to 0, the entire balance is transferred.
     * @param inputAccount The account from which tokens will be transferred from.
     * @param recipient The recipient address on the destination chain.
     * @param standardBridge The StandardBridge contract address (L1 or L2 version).
     * @param token The ERC20 token address to transfer (or address(0) for ETH).
     * @param remoteToken Address of the corresponding token on the destination chain (only used for ERC20 transfers). Must be zero address for ETH transfers.
     * @param minGasLimit Gas to use to complete the transfer on the receiving side. Used for sequencers/relayers.
     * @param extraData Additional data to be forwarded with the transaction.
     */
    struct StandardBridgeTransferConfig {
        uint256 amount;
        BaseAccount inputAccount;
        address recipient;
        IStandardBridge standardBridge;
        address token;
        address remoteToken;
        uint32 minGasLimit;
        bytes extraData;
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ibc-eureka-transfer-library"><a class="header" href="#ibc-eureka-transfer-library">IBC Eureka Transfer Library</a></h1>
<p>The IBC Eureka Transfer library enables transferring ERC20 tokens from an <strong>input account</strong> on an EVM chain to a <strong>recipient</strong> on an IBC Eureka connected chain using the IBC protocol via <a href="https://docs.skip.build/go/eureka/eureka-overview">IBC Eureka's Solidity implementation</a>. This library also takes advantage of <a href="https://docs.skip.build/go/general/getting-started">Skip Go API</a> that provides an <code>EurekaHandler</code> wrapper and the relaying service for the underlying protocol. It is typically used as part of a <strong>Valence Program</strong>. In that context, a <strong>Processor</strong> contract will be the main contract interacting with the IBC Eureka Transfer library.</p>
<h2 id="high-level-flow-22"><a class="header" href="#high-level-flow-22">High-level flow</a></h2>
<pre class="mermaid">---
title: IBC Eureka Transfer Library
---
graph LR
    IA((Input Account))
    R((Recipient))
    EH((Eureka Handler))
    ICS((ICS20Transfer))
    P[Processor]
    I[IBCEurekaTransfer
    Library]

    subgraph DEST[ Destination Chain ]
    R
    end

    subgraph SRC[ Source Chain ]
    P -- 1/Transfer(fees &amp; memo) --&gt; I
    I -- 2/Query ERC20 balance --&gt; IA
    IA -- 3/Approve ERC20 --&gt; EH
    IA -- 4/Call transfer --&gt; EH
    EH -- 5/Forward to ICS20 --&gt; ICS
    end

    ICS -.6/IBC Packet.-&gt; R
    SRC --- DEST
</pre>
<h2 id="functions-22"><a class="header" href="#functions-22">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>Transfer</strong></td><td><code>fees</code>: Relay fee structure<br><code>memo</code>: Additional information</td><td>Transfer tokens from the configured <strong>input account</strong> to the <strong>recipient</strong> on the destination IBC chain. The <code>fees</code> parameter specifies relay fees, fee recipient, and quote expiry. The <code>memo</code> parameter can contain additional information that might execute logic on the destination chain.</td></tr>
</tbody></table>
</div>
<h2 id="configuration-22"><a class="header" href="#configuration-22">Configuration</a></h2>
<p>The library is configured on deployment using the <code>IBCEurekaTransferConfig</code> type.</p>
<pre><code class="language-solidity">/**
 * @dev Configuration struct for token transfer parameters.
 * @param amount The number of tokens to transfer. If set to 0, the entire balance is transferred.
 * @param transferToken The ERC20 token address that will be transferred.
 * @param inputAccount The account from which tokens will be debited.
 * @param recipient The recipient address on the destination IBC chain (in bech32 format).
 * @param sourceClient The source client identifier (e.g. cosmoshub-0).
 * @param timeout The timeout for the IBC transfer in seconds. Skip Go uses 12 hours (43200 seconds) as the default timeout.
 * @param eurekaHandler The EurekaHandler contract which is a wrapper around the ICS20Transfer contract.
 */
struct IBCEurekaTransferConfig {
    uint256 amount;
    address transferToken;
    BaseAccount inputAccount;
    string recipient;
    string sourceClient;
    uint64 timeout;
    IEurekaHandler eurekaHandler;
}
</code></pre>
<h2 id="special-considerations"><a class="header" href="#special-considerations">Special Considerations</a></h2>
<ul>
<li>The EurekaHandler contract on Ethereum that is used to transfer from Ethereum to CosmosHub is at <code>0xfc2d0487a0ae42ae7329a80dc269916a9184cf7c</code>.</li>
<li>The recipient address is not in Bytes32 format but in the format used by the IBC chain (e.g., bech32: <code>cosmos1...</code>).</li>
<li>To build the <code>Fees</code> structure for the transfer, we query the Skip Go API to obtain all the necessary information. Here is an example of a query:</li>
</ul>
<pre><code class="language-bash">curl -X POST "https://go.skip.build/api/skip/v2/fungible/route" \
  -H "Content-Type: application/json" \
  -d '{
    "source_asset_denom": "0xbf6Bc6782f7EB580312CC09B976e9329f3e027B3",
    "source_asset_chain_id": "1",
    "dest_asset_denom": "uatom",
    "dest_asset_chain_id": "cosmoshub-4",
    "amount_in": "20000000",
    "allow_multi_tx": true,
    "allow_unsafe": true,
    "go_fast": true,
    "smart_relay": true,
    "experimental_features": ["eureka"],
    "smart_swap_options": {
      "split_routes": true,
      "evm_swaps": true
    }
  }
</code></pre>
<p>This is a query to obtain the fee information for transferring 20 ATOM from Ethereum (chain ID <code>1</code>) to the Cosmos Hub (chain ID <code>cosmoshub-4</code>). This will return us a response from which we can extract the <code>smart_relay_fee_quote</code> information that contains all the information to build the <code>Fees</code> structure. Important: The <code>quoteExpiry</code> timestamp of the <code>Fees</code> is passed in seconds.</p>
<ul>
<li>The memo can be used to execute logic on the destination chain. For example, if we want to execute a hop on the destination chain, we can use the memo to specify the hop parameters. Here is an example of a memo:</li>
</ul>
<p><code>{"dest_callback":{"address":"cosmos198plfkpwzpxxrlpvprhfmdkcf3frpa7kvduq9cw8lh02mm327tgqhh3s55"},"wasm":{"contract":"cosmos1zvesudsdfxusz06jztpph4d3h5x6veglqsspxns2v2jqml9nhywshhfp5j","msg":{"action":{"action":{"ibc_transfer":{"ibc_info":{"memo":"","receiver":"elys1....","recover_address":"cosmos1...","source_channel":"channel-1266"}}},"exact_out":false,"timeout_timestamp":1744774447117660400}}}}</code></p>
<p>For more details on how this memo works, please refer to the <a href="https://github.com/cosmos/ibc-go/blob/16f51eb5635bc16c6361c44f2a963f4736d1cf8b/docs/docs/04-middleware/01-callbacks/05-end-users.md">IBC callback middleware</a> documentation.</p>
<p>The <code>dest_callback</code> field specifies the address of the contract that will be called on the destination chain. In this case, <code>cosmos198plfkpwzpxxrlpvprhfmdkcf3frpa7kvduq9cw8lh02mm327tgqhh3s55</code> is a contract deployed on the Cosmos Hub that can handle these callbacks. The contract <code>cosmos1zvesudsdfxusz06jztpph4d3h5x6veglqsspxns2v2jqml9nhywshhfp5j</code> is the contract deployed to trigger these additional actions. These 2 contracts can be reused for all memos.
In this particular case, the memo is used to trigger an additional IBC transfer on the destination chain, in this case from the Cosmos Hub to Elys. The receiver is the address specified in the <code>receiver</code> field and the <code>recover_address</code> is the address that will receive the tokens in case of a failure.</p>
<ul>
<li>The function will automatically deduct relay fees from the total amount being transferred.</li>
<li>IBC transfers require specifying a timeout period, after which the transfer is considered failed if not completed.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="valence-aave-position-manager-library"><a class="header" href="#valence-aave-position-manager-library">Valence AAVE Position Manager library</a></h1>
<p>The <strong>Valence AAVE Position Manager</strong> library allows <strong>management of lending positions</strong> using an <strong>input account</strong> and an <strong>output account</strong> using the <a href="https://aave.com/docs/developers/aave-v3">AAVE v3 Protocol</a>. It is typically used as part of a <strong>Valence Program</strong>. In that context, a <strong>Processor</strong> contract will be the main contract interacting with the AAVE Position Manager library.</p>
<h2 id="high-level-flows"><a class="header" href="#high-level-flows">High-level flows</a></h2>
<pre class="mermaid">---
title: AAVE Position Manager Supply Flow
---
flowchart LR
    P[Processor]
    A[AAVE Position
    Manager Library]
    IA((Input Account))
    AP((AAVE Pool))

    P -- 1/Supply(amount) --&gt; A
    A -- 2/Query balance --&gt; IA
    A -- 3/Approve ERC20(amount) and call supply --&gt; IA
    IA -- 4/Supply --&gt; AP
    AP -- 5/Mint aTokens --&gt; IA
</pre>
<pre class="mermaid">---
title: AAVE Position Manager Borrow Flow
---
flowchart LR
 P[Processor]
 A[AAVE Position
 Manager Library]
 IA((Input Account))
 AP((AAVE Pool))
 P -- 1/Borrow(amount) --&gt; A
 A -- 2/Call borrow --&gt; IA
 IA -- 4/Borrow --&gt; AP
 AP -- 5/Send borrowed tokens --&gt; IA
</pre>
<pre class="mermaid">---
title: AAVE Position Manager Withdraw Flow
---
flowchart LR
 P[Processor]
 A[AAVE Position
 Manager Library]
 IA((Input Account))
 AP((AAVE Pool))
 OA((Output Account))
 P -- 1/Withdraw(amount) --&gt; A
 A -- 2/Call withdraw --&gt; IA
 IA -- 3/Withdraw --&gt; AP
 AP -- 4/Send withdrawn tokens --&gt; OA
</pre>
<pre class="mermaid">---
title: AAVE Position Manager Repay Flow
---
flowchart LR
    P[Processor]
    A[AAVE Position
    Manager Library]
    IA((Input Account))
    AP((AAVE Pool))

    P -- 1/Repay(amount) --&gt; A
    A -- 2/Query balance --&gt; IA
    A -- 3/Approve ERC20(amount) and call repay --&gt; IA
    IA -- 4/Repay --&gt; AP
    AP -- 5/Burn debt tokens  --&gt; IA
</pre>
<pre class="mermaid">---
title: AAVE Position Manager RepayWithShares Flow
---
flowchart LR
    P[Processor]
    A[AAVE Position
    Manager Library]
    IA((Input Account))
    AP((AAVE Pool))

    P -- 1/RepayWithShares(amount) --&gt; A
    A -- 2/Call repayWithATokens --&gt; IA
    IA -- 3/Repay --&gt; AP
    AP -- 4/Burn aTokens --&gt; IA
    AP -- 5/Burn debt tokens --&gt; IA
</pre>
<h2 id="functions-23"><a class="header" href="#functions-23">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>supply</strong></td><td>amount</td><td>Supplies tokens from the <strong>input account</strong> to the AAVE protocol. The <strong>input account</strong> will receive these corresponding aTokens. If amount is 0 the entire balance will be used.</td></tr>
<tr><td><strong>borrow</strong></td><td>amount</td><td>Borrows tokens from the AAVE protocol using the collateral previously supplied. The <strong>input account</strong> will receive the borrowed tokens and the debt tokens.</td></tr>
<tr><td><strong>withdraw</strong></td><td>amount</td><td>Withdraws previously supplied tokens from AAVE and sends them to the <strong>output account</strong>. Passing 0 will withdraw the entire balance.</td></tr>
<tr><td><strong>repay</strong></td><td>amount</td><td>Repays borrowed tokens to the AAVE protocol from the <strong>input account</strong>. Passing 0 repays the entire balance.</td></tr>
<tr><td><strong>repayWithShares</strong></td><td>amount</td><td>Repays borrowed tokens using aTokens directly, which can be more gas-efficient. Passing 0 will repay as much as possible.</td></tr>
</tbody></table>
</div>
<p>More details on how the interaction with the AAVE v3 protocol works can be found in the <a href="https://aave.com/docs/developers/smart-contracts/pool">AAVE V3 Pool documentation</a>.</p>
<h2 id="configuration-23"><a class="header" href="#configuration-23">Configuration</a></h2>
<p>The library is configured on deployment using the <code>AavePositionManagerConfig</code> type.</p>
<pre><code class="language-solidity">    /**
     * @title AavePositionManagerConfig
     * @notice Configuration struct for Aave lending operations
     * @dev Used to define parameters for interacting with Aave V3 protocol
     * @param poolAddress The address of the Aave V3 Pool contract
     * @param inputAccount The Base Account from which transactions will be initiated
     * @param outputAccount The Base Account that will receive withdrawals. Can be the same as inputAccount.
     * @param supplyAsset Address of the token to supply to Aave
     * @param borrowAsset Address of the token to borrow from Aave
     * @param referralCode Referral code for Aave protocol (if applicable - 0 if the action is executed directly by the user, without any middle-men)
     */
    struct AavePositionManagerConfig {
        IPool poolAddress;
        BaseAccount inputAccount;
        BaseAccount outputAccount;
        address supplyAsset;
        address borrowAsset;
        uint16 referralCode;
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="valence-pancakeswap-v3-position-manager-library"><a class="header" href="#valence-pancakeswap-v3-position-manager-library">Valence PancakeSwap V3 Position Manager library</a></h1>
<p>The <strong>Valence PancakeSwap V3 Position Manager</strong> library allows <strong>management of liquidity positions</strong> using an <strong>input account</strong> and an <strong>output account</strong> through the <a href="https://docs.pancakeswap.finance/earn/pancakeswap-pools">PancakeSwap V3 Protocol</a>. It is typically used as part of a <strong>Valence Program</strong>. In that context, a <strong>Processor</strong> contract will be the main contract interacting with the PancakeSwap V3 Position Manager library.</p>
<h2 id="high-level-flows-1"><a class="header" href="#high-level-flows-1">High-level flows</a></h2>
<pre class="mermaid">---
title: PancakeSwap V3 Position Manager Create Position Flow
---
flowchart LR
    P[Processor]
    PM[PancakeSwap V3
    Position Manager Library]
    IA((Input Account))
    NPM((Nonfungible
    Position Manager))
    MC((MasterChef V3))

    P -- 1/createPosition(tickLower, tickUpper, amount0, amount1) --&gt; PM
    PM -- 2/Query balances --&gt; IA
    PM -- 3/Approve tokens and call mint --&gt; IA
    IA -- 4/Mint position --&gt; NPM
    NPM -- 5/Return tokenId &amp; mint NFT --&gt; IA
    PM -- 6/Transfer NFT to MasterChef --&gt; IA
    IA -- 7/Transfer NFT --&gt; MC
</pre>
<pre class="mermaid">---
title: PancakeSwap V3 Position Manager Withdraw Position Flow
---
flowchart LR
    P[Processor]
    PM[PancakeSwap V3
    Position Manager Library]
    IA((Input Account))
    NPM((Nonfungible
    Position Manager))
    MC((MasterChef V3))
    OA((Output Account))

    P -- 1/withdrawPosition(tokenId) --&gt; PM
    PM -- 2/Call collectTo for fees --&gt; IA
    IA -- 3/Collect fees --&gt; MC
    MC -- 4/Send fees --&gt; OA
    PM -- 5/Call harvest for rewards --&gt; IA
    IA -- 6/Harvest rewards --&gt; MC
    MC -- 7/Send CAKE rewards --&gt; OA
    PM -- 8/Withdraw NFT --&gt; IA
    IA -- 9/Request NFT withdrawal --&gt; MC
    MC -- 10/Return NFT --&gt; IA
    PM -- 11/Query position details --&gt; IA
    IA -- 12/Get position details --&gt; NPM
    PM -- 13/Decrease all liquidity --&gt; IA
    IA -- 14/Remove liquidity --&gt; NPM
    PM -- 15/Collect tokens --&gt; IA
    IA -- 16/Collect tokens --&gt; NPM
    NPM -- 17/Send tokens --&gt; OA
    PM -- 18/Burn empty NFT --&gt; IA
    IA -- 19/Burn NFT --&gt; NPM
</pre>
<h2 id="functions-24"><a class="header" href="#functions-24">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>createPosition</strong></td><td>tickLower, tickUpper, amount0, amount1</td><td>Creates a position on PancakeSwap V3 by providing liquidity in a specific price range and stakes it with the <strong>input account</strong> in MasterChef V3. If amount0 or amount1 is 0, the entire balance of that token will be used. Returns the tokenId of the created position.</td></tr>
<tr><td><strong>withdrawPosition</strong></td><td>tokenId</td><td>Performs a complete withdrawal of a position: collects accumulated fees, harvests CAKE rewards, unstakes the NFT from MasterChef, removes all liquidity, and burns the NFT. Returns the amounts of fees collected, liquidity withdrawn, and rewards received and deposits all of them in the <strong>output account</strong>.</td></tr>
</tbody></table>
</div>
<h2 id="configuration-24"><a class="header" href="#configuration-24">Configuration</a></h2>
<p>The library is configured on deployment using the <code>PancakeSwapV3PositionManagerConfig</code> type.</p>
<pre><code class="language-solidity">/**
 * @notice Configuration parameters for the PancakeSwapV3PositionManager
 * @param inputAccount Account used to provide liquidity and manage positions
 * @param outputAccount Account that receives withdrawn funds and rewards
 * @param positionManager Address of PancakeSwap's NonfungiblePositionManager contract
 * @param masterChef Address of PancakeSwap's MasterChefV3 for staking NFT positions and accrue CAKE rewards
 * @param token0 Address of the first token in the pair
 * @param token1 Address of the second token in the pair
 * @param poolFee Fee tier of the liquidity pool in 1/1,000,000 increments (e.g., 500 = 0.05%, 3000 = 0.3%)
 * @param timeout Maximum time for transactions to be valid
 * @param slippageBps Maximum allowed slippage in basis points (1 basis point = 0.01%)
 */
struct PancakeSwapV3PositionManagerConfig {
    BaseAccount inputAccount;
    BaseAccount outputAccount;
    address positionManager;
    address masterChef;
    address token0;
    address token1;
    uint24 poolFee;
    uint16 slippageBps; // Basis points (e.g., 100 = 1%)
    uint256 timeout;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="valence-balancerv2swap-library"><a class="header" href="#valence-balancerv2swap-library">Valence BalancerV2Swap Library</a></h1>
<p>The <strong>Valence BalancerV2Swap</strong> library enables <strong>token swaps</strong> from an <strong>input account</strong> to an <strong>output account</strong> using the <a href="https://docs-v2.balancer.fi/">Balancer V2 protocol</a>. It is typically used as part of a <strong>Valence Program</strong>. In that context, a <strong>Processor</strong> contract will be the main contract interacting with the BalancerV2Swap library.</p>
<h2 id="high-level-flow-23"><a class="header" href="#high-level-flow-23">High-level flow</a></h2>
<pre class="mermaid">---
title: BalancerV2Swap Library
---
graph LR
    IA((Input Account))
    OA((Output Account))
    BV((Balancer Vault))
    P[Processor]
    S[BalancerV2Swap Library]

    subgraph EVM[ EVM Domain ]
        P -- 1/swap or multiSwap --&gt; S
        S -- 2/Query balances --&gt; IA
        S -- 3/Do approve --&gt; IA
        IA -- 4/ERC-20 approve --&gt; BV
        S -- 5/Execute swap --&gt; IA
        IA -- 6/Call swap/batchSwap --&gt; BV
        BV -- 7/Transfer output tokens --&gt; OA
    end
</pre>
<h2 id="functions-25"><a class="header" href="#functions-25">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>swap</strong></td><td>poolId, tokenIn, tokenOut, userData, amountIn, minAmountOut, timeout</td><td>Execute a single token swap through a Balancer V2 pool.</td></tr>
<tr><td><strong>multiSwap</strong></td><td>poolIds, tokens, userDataArray, amountIn, minAmountOut, timeout</td><td>Execute a multi-hop swap through multiple Balancer V2 pools.</td></tr>
</tbody></table>
</div>
<h2 id="single-swap-parameters"><a class="header" href="#single-swap-parameters">Single Swap Parameters</a></h2>
<p>The <code>swap</code> function requires the following parameters:</p>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>poolId</strong></td><td>bytes32</td><td>The ID of the Balancer pool to use for the swap</td></tr>
<tr><td><strong>tokenIn</strong></td><td>address</td><td>Address of the token to swap from</td></tr>
<tr><td><strong>tokenOut</strong></td><td>address</td><td>Address of the token to swap to</td></tr>
<tr><td><strong>userData</strong></td><td>bytes</td><td>Additional data for specialized pools (usually empty bytes)</td></tr>
<tr><td><strong>amountIn</strong></td><td>uint256</td><td>Amount of tokens to swap. If set to 0, all available tokens in the <strong>input_account</strong> will be swapped</td></tr>
<tr><td><strong>minAmountOut</strong></td><td>uint256</td><td>Minimum amount of output tokens to receive (slippage tolerance). If set to 0 it means no slippage protection is applied.</td></tr>
<tr><td><strong>timeout</strong></td><td>uint256</td><td>How long the transaction is valid for (in seconds)</td></tr>
</tbody></table>
</div>
<h2 id="multi-hop-swap-parameters"><a class="header" href="#multi-hop-swap-parameters">Multi-Hop Swap Parameters</a></h2>
<p>The <code>multiSwap</code> function enables complex trading routes through multiple pools:</p>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>poolIds</strong></td><td>bytes32[]</td><td>Array of pool IDs to use for each swap step (in sequence)</td></tr>
<tr><td><strong>tokens</strong></td><td>address[]</td><td>Array of all token addresses involved in the swap path (in sequence), needs to contain exactly 1 more element than the poolIds array</td></tr>
<tr><td><strong>userDataArray</strong></td><td>bytes[]</td><td>Additional data for specialized pools (one entry per pool). This data can be empty for all current Balancer pools but is reserved for possible future pool logic. Must be the same length as the poolIds array</td></tr>
<tr><td><strong>amountIn</strong></td><td>uint256</td><td>Amount of tokens to swap. If set to 0, all available tokens in the <strong>input_account</strong> will be swapped</td></tr>
<tr><td><strong>minAmountOut</strong></td><td>uint256</td><td>Minimum amount of output tokens to receive (slippage tolerance). If set to 0 it means no slippage protection is applied.</td></tr>
<tr><td><strong>timeout</strong></td><td>uint256</td><td>How long the transaction is valid for (in seconds)</td></tr>
</tbody></table>
</div>
<p>For more information on how swaps work on Balancer V2, please refer to the <a href="https://docs-v2.balancer.fi/reference/swaps/single-swap.html">Single Swap</a> and <a href="https://docs-v2.balancer.fi/reference/swaps/batch-swaps.html">Batch Swap</a> documentation.</p>
<h2 id="configuration-25"><a class="header" href="#configuration-25">Configuration</a></h2>
<p>The library is configured on deployment using the <code>BalancerV2SwapConfig</code> type.</p>
<pre><code class="language-solidity">/**
 * @title BalancerV2SwapConfig
 * @notice Configuration for Balancer V2 swaps
 * @param inputAccount The account from which tokens will be taken
 * @param outputAccount The account to which result tokens will be sent
 * @param vaultAddress Address of the Balancer V2 Vault
 */
struct BalancerV2SwapConfig {
    BaseAccount inputAccount;
    BaseAccount outputAccount;
    address vaultAddress;
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="valence-splitter-library-1"><a class="header" href="#valence-splitter-library-1">Valence Splitter Library</a></h1>
<p>The EVM Splitter library allows splitting funds from one input account to one or more output accounts, for one or more tokens according to the configured split configurations. Each token can be split using fixed amounts, fixed ratios, or dynamic ratios calculated by an external oracle contract. This library enables Valence Programs to distribute assets across multiple accounts with precise control over allocation strategies.</p>
<h2 id="high-level-flow-24"><a class="header" href="#high-level-flow-24">High-level Flow</a></h2>
<pre class="mermaid">---
title: Splitter Library
---
graph LR
  IA((Input
      Account))
  OA1((Output
      Account 1))
  OA2((Output
      Account 2))
  P[Processor]
  S[Splitter
    Library]
  O[Dynamic Ratio
    Oracle]
  P -- 1/Split --&gt; S
  S -- 2/Query balances --&gt; IA
  S -. 3/Query dynamic ratio .-&gt; O
  S -- 4/Transfer to OA1 --&gt; IA
  S -- 4'/Transfer to OA2 --&gt; IA
  IA -- 5/Transfer funds --&gt; OA1
  IA -- 5'/Transfer funds --&gt; OA2
</pre>
<h2 id="functions-26"><a class="header" href="#functions-26">Functions</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>split</strong></td><td>-</td><td>Splits funds from the configured input account to the output accounts according to the configured split configurations for each token.</td></tr>
</tbody></table>
</div>
<h2 id="configuration-26"><a class="header" href="#configuration-26">Configuration</a></h2>
<p>The library is configured on deployment using the <code>SplitterConfig</code> type.</p>
<pre><code class="language-solidity">    /**
     * @title SplitterConfig
     * @notice Configuration struct for splitting operations
     * @param inputAccount Address of the input account
     * @param splits Split configuration per token address
     */
    struct SplitterConfig {
        BaseAccount inputAccount;
        SplitConfig[] splits;
    }

    /**
     * @title SplitConfig
     * @notice Split config for specified account
     * @param outputAccount Address of the output account
     * @param token Address of the token account. Use address(0) to send ETH
     * @param splitType type of the split
     * @param splitData encoded configuration based on the type of split
     */
    struct SplitConfig {
        BaseAccount outputAccount;
        address token;
        SplitType splitType;
        bytes splitData;
    }

    /**
     * @title SplitType
     * @notice enum defining allowed variants of split config
     */
    enum SplitType {
        FixedAmount,    // Split a fixed amount of tokens
        FixedRatio,     // Split based on a fixed ratio (percentage)
        DynamicRatio    // Split based on a dynamic ratio from oracle
    }

    /**
     * @title DynamicRatioAmount
     * @notice Params for dynamic ratio split
     * @param contractAddress Address of the dynamic ratio oracle contract
     * @param params Encoded parameters for the oracle
     */
    struct DynamicRatioAmount {
        address contractAddress;
        bytes params;
    }
</code></pre>
<h2 id="split-types"><a class="header" href="#split-types">Split Types</a></h2>
<h3 id="fixed-amount"><a class="header" href="#fixed-amount">Fixed Amount</a></h3>
<p>Splits an exact number of tokens regardless of the total balance. The <code>splitData</code> contains the encoded amount as <code>uint256</code>.</p>
<h3 id="fixed-ratio"><a class="header" href="#fixed-ratio">Fixed Ratio</a></h3>
<p>Splits tokens based on a fixed percentage of the total balance. The <code>splitData</code> contains the encoded ratio as <code>uint256</code> scaled by 10^18.</p>
<h3 id="dynamic-ratio"><a class="header" href="#dynamic-ratio">Dynamic Ratio</a></h3>
<p>Splits tokens based on a ratio calculated by an external oracle contract. The <code>splitData</code> contains an encoded <code>DynamicRatioAmount</code> struct with the oracle contract address and parameters.</p>
<h2 id="implementation-details"><a class="header" href="#implementation-details">Implementation Details</a></h2>
<h3 id="validation-rules"><a class="header" href="#validation-rules">Validation Rules</a></h3>
<p>The library enforces several validation rules during configuration:</p>
<ul>
<li><strong>Input Account</strong>: Must be a valid non-zero address</li>
<li><strong>No Duplicates</strong>: Cannot have duplicate splits for the same token and output account combination</li>
<li><strong>Split Type Consistency</strong>: Cannot mix different split types for the same token</li>
<li><strong>Ratio Sum</strong>: For fixed ratio splits, the sum of all ratios for a token must equal 1.0 (10^18)</li>
<li><strong>Oracle Validation</strong>: Dynamic ratio oracle addresses must be valid smart contracts</li>
</ul>
<h3 id="execution-process"><a class="header" href="#execution-process">Execution Process</a></h3>
<ol>
<li><strong>Balance Query</strong>: Retrieves the current balance for each token from the input account</li>
<li><strong>Amount Calculation</strong>: Calculates split amounts based on the configured split type:
<ul>
<li><strong>Fixed Amount</strong>: Uses the configured amount directly</li>
<li><strong>Fixed Ratio</strong>: Multiplies balance by ratio and divides by 10^18</li>
<li><strong>Dynamic Ratio</strong>: Queries the oracle contract for the current ratio</li>
</ul>
</li>
<li><strong>Transfer Execution</strong>: Executes transfers from the input account to each output account</li>
</ol>
<h3 id="oracle-integration"><a class="header" href="#oracle-integration">Oracle Integration</a></h3>
<p>For dynamic ratio splits, the library integrates with external oracle contracts implementing the <code>IDynamicRatioOracle</code> interface:</p>
<pre><code class="language-solidity">interface IDynamicRatioOracle {
    function queryDynamicRatio(IERC20 token, bytes calldata params) 
        external view returns (uint256 ratio);
}
</code></pre>
<p>The oracle returns a ratio scaled by 10^18, which must not exceed 1.0 (10^18). This enables integration with price oracles, TWAP calculators, or other dynamic pricing mechanisms.</p>
<h3 id="native-asset-support"><a class="header" href="#native-asset-support">Native Asset Support</a></h3>
<p>The library supports both ERC20 tokens and native ETH:</p>
<ul>
<li><strong>ERC20 Tokens</strong>: Use the token contract address</li>
<li><strong>Native ETH</strong>: Use <code>address(0)</code> as the token address</li>
</ul>
<h2 id="acknowledgments"><a class="header" href="#acknowledgments">Acknowledgments</a></h2>
<p>Thanks to Mujtaba, Hareem, and Ayush from <a href="https://www.orbitearn.com/">Orbit</a> for this contribution.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="middleware"><a class="header" href="#middleware">Middleware</a></h1>
<p>This section contains a description of the Valence Protocol middleware design.</p>
<p><strong>Valence Protocol Middleware components</strong>:</p>
<ul>
<li><a href="middleware/./broker.html">Middleware Broker</a></li>
<li><a href="middleware/./type_registry.html">Middleware Type Registry</a></li>
<li><a href="middleware/./valence_types.html">Valence Types</a></li>
<li><a href="middleware/./valence_asserter.html">Asserters</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="middleware-broker"><a class="header" href="#middleware-broker">Middleware Broker</a></h1>
<p>Middleware broker acts as an app-level integration gateway in Valence Programs.
<em>Integration</em> here is used rather ambiguously on purpose - brokers should remain
agnostic to the primitives being integrated into Valence Protocol. These primitives
may involve but not be limited to:</p>
<ul>
<li>data types</li>
<li>functions</li>
<li>encoding schemes</li>
<li>any other distributed system building blocks that may be implemented differently</li>
</ul>
<h3 id="problem-statement"><a class="header" href="#problem-statement">Problem statement</a></h3>
<p>Valence Programs can be configured to span over multiple domains and last for an
indefinite duration of time.</p>
<p>Domains integrated into Valence Protocol are sovereign and evolve on their own.</p>
<p>Middleware brokers provide the means to live with these differences by enabling
various primitive conversions to be as seamless as possible. Seamless here primarily
refers to causing <strong>no downtime</strong> to bring a given primitive up-to-date, and
making the process of doing so as <strong>easy as possible</strong> for the developers.</p>
<p>To visualize a rather complex instance of this problem, consider the following
situation. A Valence Program is initialized to continuously query a particular
type from a remote domain, modify some of its values, and send the altered object
back to the remote domain for further actions.
At some point during the runtime, remote domain performs an upgrade which extends
the given type with additional fields. The Valence Program is unaware of this
upgrade and continues with its order of operations. However, the type in question
from the perspective of the Valence Program had drifted and is no longer
representative of its origin domain.</p>
<p>Among other things, Middleware brokers should enable such programs to gracefully
recover into a synchronized state that can continue operating in a correct manner.</p>
<h2 id="broker-lifecycle"><a class="header" href="#broker-lifecycle">Broker Lifecycle</a></h2>
<p>Brokers are singleton components that are instantiated before the program start
time.</p>
<p>Valence Programs refer to their brokers of choice by their respective addresses.</p>
<p>This means that the same broker instance for a particular domain could be used
across many Valence Programs.</p>
<p>Brokers maintain their set of <a href="middleware/./type_registry.html"><em>type registries</em></a> and index
them by <code>semver</code>. New type registries can be added to the broker during runtime.
While programs have the freedom to select a particular version of a type registry
to be used for a given request, by default, the most up to date type registry is used.</p>
<p>Two aforementioned properties reduce the amount of work needed to upkeep the integrations
across active Valence Programs: updating one broker with the latest version of a
given domain will immediately become available for all Valence Programs using it.</p>
<h2 id="api-2"><a class="header" href="#api-2">API</a></h2>
<p>Broker interface is agnostic to the type registries it indexes. A single query is
exposed:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct QueryMsg {
    pub registry_version: Option&lt;String&gt;,
    pub query: RegistryQueryMsg,
}
<span class="boring">}</span></code></pre></pre>
<p>This query message should only change in situations where it may become limiting.</p>
<p>After receiving the query request, broker will relay the contained <code>RegistryQueryMsg</code>
to the correct type registry, and return the result to the caller.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="middleware-type-registry"><a class="header" href="#middleware-type-registry">Middleware Type Registry</a></h1>
<p>Middleware type registries are static components that define how primitives
external to the Valence Protocol are adapted to be used within Valence programs.</p>
<p>While type registries can be used independently, they are typically meant to be
registered into and used via <a href="middleware/./broker.html"><em>brokers</em></a> to ensure versioning is
kept up to date.</p>
<h2 id="type-registry-lifecycle"><a class="header" href="#type-registry-lifecycle">Type Registry lifecycle</a></h2>
<p>Type Registries are static contracts that define their primitives during compile time.</p>
<p>Once a registry is deployed, it is expected to remain unchanged.
If a type change is needed, a new registry should be compiled, deployed,
and registered into the broker to offer the missing or updated functionality.</p>
<h2 id="api-3"><a class="header" href="#api-3">API</a></h2>
<p>All type registry instances must implement the same interface defined in middleware-utils.</p>
<p>Type registries function in a read-only manner - all of their functionality is exposed
with the <code>RegistryQueryMsg</code>. Currently, the following primitive conversions are enabled:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum RegistryQueryMsg {
    /// serialize a message to binary
    #[returns(NativeTypeWrapper)]
    FromCanonical { obj: ValenceType },
    /// deserialize a message from binary/bytes
    #[returns(Binary)]
    ToCanonical { type_url: String, binary: Binary },

    /// get the kvkey used for registering an interchain query
    #[returns(KVKey)]
    KVKey {
        type_id: String,
        params: BTreeMap&lt;String, Binary&gt;,
    },

    #[returns(NativeTypeWrapper)]
    ReconstructProto {
        type_id: String,
        icq_result: InterchainQueryResult,
    },
}
<span class="boring">}</span></code></pre></pre>
<p><code>RegistryQueryMsg</code> can be seen as the <em>superset</em> of all primitives that Valence Programs
can expect. No particular type being integrated into the system is required to implement
all available functionality, although that is possible.</p>
<p>To maintain a unified interface across all type registries, they have to adhere to the same
API as all other type registries. This means that if a particular type is enabled in a type
registry and only provides the means to perform native &lt;-&gt; canonical conversion, attempting
to call <code>ReconstructProto</code> on that type will return an error stating that reconstructing
protobuf for this type is not enabled.</p>
<h2 id="module-organization"><a class="header" href="#module-organization">Module organization</a></h2>
<p>Primitives defined in type registries should be outlined in a domain-driven manner.
Types, encodings, and any other functionality should be grouped by their domain and
are expected to be self-contained, not leaking into other primitives.</p>
<p>For instance, an osmosis type registry is expected to contain all registry instances related to
the Osmosis domain. Different registry instances should be versioned by <code>semver</code>, following that
of the external domain of which the primitives are being integrated.</p>
<h2 id="enabled-primitives"><a class="header" href="#enabled-primitives">Enabled primitives</a></h2>
<p>Currently, the following type registry primitives are enabled:</p>
<ul>
<li>Neutron Interchain Query types:
<ul>
<li>reconstructing native types from protobuf</li>
<li>obtaining the <code>KVKey</code> used to initiate the query for a given type</li>
</ul>
</li>
<li>Valence Canonical Types:
<ul>
<li>reconstructing native types from Valence Types</li>
<li>mapping native types into Valence Types</li>
</ul>
</li>
</ul>
<h2 id="example-integration"><a class="header" href="#example-integration">Example integration</a></h2>
<p>For an example, consider the integration of the osmosis gamm pool.</p>
<h3 id="neutron-interchain-query-integration"><a class="header" href="#neutron-interchain-query-integration">Neutron Interchain Query integration</a></h3>
<p>Neutron Interchain Query integration for a given type is achieved by implementing
the <code>IcqIntegration</code> trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait IcqIntegration {
    fn get_kv_key(params: BTreeMap&lt;String, Binary&gt;) -&gt; Result&lt;KVKey, MiddlewareError&gt;;
    fn decode_and_reconstruct(
        query_id: String,
        icq_result: InterchainQueryResult,
    ) -&gt; Result&lt;Binary, MiddlewareError&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h4 id="get_kv_key"><a class="header" href="#get_kv_key"><code>get_kv_key</code></a></h4>
<p>Implementing the <code>get_kv_key</code> will provide the means to obtain the <code>KVKey</code> needed
to register the interchain query. For osmosis gamm pool, the implementation may look
like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>impl IcqIntegration for OsmosisXykPool {
    fn get_kv_key(params: BTreeMap&lt;String, Binary&gt;) -&gt; Result&lt;KVKey, MiddlewareError&gt; {
        let pool_prefix_key: u8 = 0x02;

        let id: u64 = try_unpack_domain_specific_value("pool_id", &amp;params)?;

        let mut pool_access_key = vec![pool_prefix_key];
        pool_access_key.extend_from_slice(&amp;id.to_be_bytes());

        Ok(KVKey {
            path: STORAGE_PREFIX.to_string(),
            key: Binary::new(pool_access_key),
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="decode_and_reconstruct"><a class="header" href="#decode_and_reconstruct"><code>decode_and_reconstruct</code></a></h4>
<p>Other part of enabling interchain queries is the implementation of <code>decode_and_reconstruct</code>.
This method will be called upon ICQ relayer posting the query result back to the <code>interchainqueries</code>
module on Neutron. For osmosis gamm pool, the implementation may look
like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl IcqIntegration for OsmosisXykPool {
    fn decode_and_reconstruct(
        _query_id: String,
        icq_result: InterchainQueryResult,
    ) -&gt; Result&lt;Binary, MiddlewareError&gt; {
        let any_msg: Any = Any::decode(icq_result.kv_results[0].value.as_slice())
            .map_err(|e| MiddlewareError::DecodeError(e.to_string()))?;

        let osmo_pool: Pool = any_msg
            .try_into()
            .map_err(|_| StdError::generic_err("failed to parse into pool"))?;

        to_json_binary(&amp;osmo_pool)
            .map_err(StdError::from)
            .map_err(MiddlewareError::Std)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="valence-type-integration"><a class="header" href="#valence-type-integration">Valence Type integration</a></h3>
<p>Valence Type integration for a given type is achieved by implementing
the <code>ValenceTypeAdapter</code> trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait ValenceTypeAdapter {
    type External;

    fn try_to_canonical(&amp;self) -&gt; Result&lt;ValenceType, MiddlewareError&gt;;
    fn try_from_canonical(canonical: ValenceType) -&gt; Result&lt;Self::External, MiddlewareError&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>Ideally, Valence Types should represent the minimal amount of information needed and
avoid any domain-specific logic or identifiers. In practice, this is a hard problem:
native types that are mapped into Valence types may need to be sent back to the remote
domains. For that reason, we cannot afford leaking any domain-specific fields and instead
store them in the Valence Type itself for later reconstruction.</p>
<p>In case of <code>ValenceXykPool</code>, this storage is kept in its <code>domain_specific_fields</code> field.
Any fields that are logically common across all possible integrations into this type
should be kept in their dedicated fields. In the case of constant product pools, such
fields are the assets in the pool, and the shares issued that represent those assets:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cw_serde]
pub struct ValenceXykPool {
    /// assets in the pool
    pub assets: Vec&lt;Coin&gt;,

    /// total amount of shares issued
    pub total_shares: String,

    /// any other fields that are unique to the external pool type
    /// being represented by this struct
    pub domain_specific_fields: BTreeMap&lt;String, Binary&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h4 id="try_to_canonical"><a class="header" href="#try_to_canonical"><code>try_to_canonical</code></a></h4>
<p>Implementing the <code>try_from_canonical</code> will provide the means of mapping a native remote type
into the canonical Valence Type to be used in Valence Protocol.
For osmosis gamm pool, the implementation may look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ValenceTypeAdapter for OsmosisXykPool {
    type External = Pool;

    fn try_to_canonical(&amp;self) -&gt; Result&lt;ValenceType, MiddlewareError&gt; {
        // pack all the domain-specific fields
        let mut domain_specific_fields = BTreeMap::from([
            (ADDRESS_KEY.to_string(), to_json_binary(&amp;self.0.address)?),
            (ID_KEY.to_string(), to_json_binary(&amp;self.0.id)?),
            (
                FUTURE_POOL_GOVERNOR_KEY.to_string(),
                to_json_binary(&amp;self.0.future_pool_governor)?,
            ),
            (
                TOTAL_WEIGHT_KEY.to_string(),
                to_json_binary(&amp;self.0.total_weight)?,
            ),
            (
                POOL_PARAMS_KEY.to_string(),
                to_json_binary(&amp;self.0.pool_params)?,
            ),
        ]);

        if let Some(shares) = &amp;self.0.total_shares {
            domain_specific_fields
                .insert(SHARES_DENOM_KEY.to_string(), to_json_binary(&amp;shares.denom)?);
        }

        for asset in &amp;self.0.pool_assets {
            if let Some(token) = &amp;asset.token {
                domain_specific_fields.insert(
                    format!("pool_asset_{}_weight", token.denom),
                    to_json_binary(&amp;asset.weight)?,
                );
            }
        }

        let mut assets = vec![];
        for asset in &amp;self.0.pool_assets {
            if let Some(t) = &amp;asset.token {
                assets.push(coin(u128::from_str(&amp;t.amount)?, t.denom.to_string()));
            }
        }

        let total_shares = self
            .0
            .total_shares
            .clone()
            .map(|shares| shares.amount)
            .unwrap_or_default();

        Ok(ValenceType::XykPool(ValenceXykPool {
            assets,
            total_shares,
            domain_specific_fields,
        }))
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="try_from_canonical"><a class="header" href="#try_from_canonical"><code>try_from_canonical</code></a></h4>
<p>Other part of enabling Valence Type integration is the implementation of <code>try_from_canonical</code>.
This method will be called when converting from canonical back to the native version of the types.
For osmosis gamm pool, the implementation may look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ValenceTypeAdapter for OsmosisXykPool {
    type External = Pool;

    fn try_from_canonical(canonical: ValenceType) -&gt; Result&lt;Self::External, MiddlewareError&gt; {
        let inner = match canonical {
            ValenceType::XykPool(pool) =&gt; pool,
            _ =&gt; {
                return Err(MiddlewareError::CanonicalConversionError(
                    "canonical inner type mismatch".to_string(),
                ))
            }
        };
        // unpack domain specific fields from inner type
        let address: String = inner.get_domain_specific_field(ADDRESS_KEY)?;
        let id: u64 = inner.get_domain_specific_field(ID_KEY)?;
        let future_pool_governor: String =
            inner.get_domain_specific_field(FUTURE_POOL_GOVERNOR_KEY)?;
        let pool_params: Option&lt;PoolParams&gt; = inner.get_domain_specific_field(POOL_PARAMS_KEY)?;
        let shares_denom: String = inner.get_domain_specific_field(SHARES_DENOM_KEY)?;
        let total_weight: String = inner.get_domain_specific_field(TOTAL_WEIGHT_KEY)?;

        // unpack the pool assets
        let mut pool_assets = vec![];
        for asset in &amp;inner.assets {
            let pool_asset = PoolAsset {
                token: Some(Coin {
                    denom: asset.denom.to_string(),
                    amount: asset.amount.into(),
                }),
                weight: inner
                    .get_domain_specific_field(&amp;format!("pool_asset_{}_weight", asset.denom))?,
            };
            pool_assets.push(pool_asset);
        }

        Ok(Pool {
            address,
            id,
            pool_params,
            future_pool_governor,
            total_shares: Some(Coin {
                denom: shares_denom,
                amount: inner.total_shares,
            }),
            pool_assets,
            total_weight,
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="valence-types-1"><a class="header" href="#valence-types-1">Valence Types</a></h1>
<p><strong>Valence Types</strong> are a set of canonical type wrappers to be used inside
Valence Programs.</p>
<p>Primary operational domain of Valence Protocol will need to consume, interpret,
and otherwise manipulate data from external domains. For that reason, canonical
representations of such types are defined in order to form an abstraction layer
that all Valence Programs can reason about.</p>
<h2 id="canonical-type-integrations"><a class="header" href="#canonical-type-integrations">Canonical Type integrations</a></h2>
<p>Canonical types to be used in Valence Programs are enabled by the Valence Protocol.</p>
<p>For instance, consider Astroport XYK and Osmosis GAMM pool types. These are two
distinct data types that represent the same underlying concept - a constant product
pool.</p>
<p>These types can be unified in the Valence Protocol context by being mapped to and
from the following Valence Type definition:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ValenceXykPool {
    /// assets in the pool
    pub assets: Vec&lt;Coin&gt;,

    /// total amount of shares issued
    pub total_shares: String,

    /// any other fields that are unique to the external pool type
    /// being represented by this struct
    pub domain_specific_fields: BTreeMap&lt;String, Binary&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>For a remote type to be integrated into the Valence Protocol means that there are
available adapters that map between the canonical and original type definitions.</p>
<p>These adapters can be implemented by following the design outlined by <a href="middleware/./type_registry.html"><em>type registries</em></a>.</p>
<h2 id="active-valence-types"><a class="header" href="#active-valence-types">Active Valence Types</a></h2>
<p>Active Valence types provide the interface for integrating remote domain representations
of the same underlying concepts. Remote types can be integrated into Valence Protocol
if and only if there is an enabled Valence Type representing the same underlying primitive.</p>
<blockquote>
<p>TODO: start a dedicated section for each Valence Type</p>
</blockquote>
<p>Currently enabled Valence types are:</p>
<ul>
<li>XYK pool</li>
<li>Balance response</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="valence-asserter-1"><a class="header" href="#valence-asserter-1">Valence Asserter</a></h1>
<p><strong>Valence Asserters</strong> provide the means to assert boolean conditions about <a href="middleware/./valence_types.html">Valence Types</a>.</p>
<p>Each Valence Type variant may provide different assertion queries. To offer a unified API, Valence Asserter
remains agnostic to the underlying type being queried and provides a common gateway to all available types.</p>
<h2 id="motivation"><a class="header" href="#motivation">Motivation</a></h2>
<p>Primary use case for Valence Type assertions is to enable <strong>conditional execution</strong> of functions.
A basic example of this may be expressed as "<em>provide liquidity if and only if the pool price is greater than X</em>".</p>
<p>While specific conditions like this could be internalized in each function that is to be executed, Valence Asserter
aims to:</p>
<ul>
<li>enable such assertions to be performed prior to any library function (system level)</li>
<li>not limit the assertions to a particular condition (generalize)</li>
</ul>
<p>With the following goals satisfied, arbitrary assertions can be performed on the <a href="middleware/./../authorizations_processors/processor.html">processor</a> level.</p>
<p>Each function call that the configured program wishes to execute only if a certain condition is met can then
be placed in a message batch and prepended with an assertion message.
This way, when the message batch is being processed, any assertions that do not evaluate to true (return an <code>Err</code>) will
prevent later messages from executing as expected. If the batch is <em>atomic</em>, the whole batch will abort.
If the batch is <em>non-atomic</em>, various <a href="middleware/./../authorizations_processors/authorization_contract.html">authorization</a> configuration
options will dictate the further behavior.</p>
<h2 id="high-level-flow-25"><a class="header" href="#high-level-flow-25">High-level flow</a></h2>
<pre class="mermaid">---
title: Forwarder Library
---
graph LR
  IA((Storage Account))
  P[Processor]
  S[Valence Asserter]
  P -- 1/Assert --&gt; S
  S -- 2/Query storage slot(s) --&gt; IA
  S -- 3/Evaluate the predicate --&gt; S
  S -- 4/Return OK/ERR --&gt; P
</pre>
<h2 id="api-4"><a class="header" href="#api-4">API</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Function</th><th>Parameters</th><th>Description</th><th>Return Value</th></tr></thead><tbody>
<tr><td><strong>Assert</strong></td><td><code>a: AssertionValue</code><br><code>predicate: Predicate</code><br><code>b: AssertionValue</code></td><td>Evaluate the given predicate <em>R(a, b)</em>.<br>If <em>a</em> or <em>b</em> are variables, they get fetched using the configuartion specified in the respective <code>QueryInfo</code>.<br>Both <em>a</em> and <em>b</em> must be deserializable into the same type.</td><td>- predicate evaluates to true: <code>Ok()</code><br>- predicate evaluates to false: <code>Err</code></td></tr>
</tbody></table>
</div>
<h2 id="design"><a class="header" href="#design">Design</a></h2>
<p>Assertions to be performed are expressed as <em>R(a, b)</em>, where:</p>
<ul>
<li><em>a</em> and <em>b</em> are values of the same type</li>
<li><em>R</em> is the predicate that applies to <em>a</em> and <em>b</em></li>
</ul>
<p>Valence Asserter design should enable such predicate evaluations to be performed in a generic manner within Valence Programs.</p>
<h3 id="assertion-values"><a class="header" href="#assertion-values">Assertion values</a></h3>
<p>Assertion values are defined as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum AssertionValue {
    // storage account slot query
    Variable(QueryInfo),
    // constant valence primitive value
    Constant(ValencePrimitive),
}
<span class="boring">}</span></code></pre></pre>
<p>Two values are required for any comparison. Both <em>a</em> and <em>b</em> can be configured to be obtained in one of two ways:</p>
<ol>
<li>Constant value (known before program instantiation)</li>
<li>Variable value (known during program runtime)</li>
</ol>
<p>Any combination of these values can be used for a given assertion:</p>
<ul>
<li>constant-constant (unlikely)</li>
<li>constant-variable</li>
<li>variable-variable</li>
</ul>
<h4 id="variable-assertion-values"><a class="header" href="#variable-assertion-values"><code>Variable</code> assertion values</a></h4>
<p>Variable assertion values are meant to be used for information that can only become known during runtime.</p>
<p>Such values will be obtained from Valence Types, which expose their own set of queries.</p>
<p>Valence Types reside in their dedicated storage slots in <a href="middleware/../accounts/storage_accounts.html">Storage Accounts</a>.</p>
<p>Valence Asserter uses the following type in order to obtain the Valence Type and query its state:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct QueryInfo {
    // addr of the storage account
    pub storage_account: String,
    // key to access the value in the storage account
    pub storage_slot_key: String,
    // b64 encoded query
    pub query: Binary,
}
<span class="boring">}</span></code></pre></pre>
<h4 id="constant-assertion-values"><a class="header" href="#constant-assertion-values"><code>Constant</code> assertion values</a></h4>
<p>Constant assertion values are meant to be used for assertions where one of the operands is known before runtime.</p>
<p>Valence Asserter expects constant values to be passed using the <code>ValencePrimitive</code> enum which wraps around the standard <code>cosmwasm_std</code> types:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum ValencePrimitive {
    Decimal(cosmwasm_std::Decimal),
    Uint64(cosmwasm_std::Uint64),
    Uint128(cosmwasm_std::Uint128),
    Uint256(cosmwasm_std::Uint256),
    String(String),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="predicates"><a class="header" href="#predicates">Predicates</a></h3>
<p>Predicates <em>R</em> are specified with the following type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Predicate {
    LT,  // &lt;
    LTE, // &lt;=
    EQ,  // ==
    GT,  // &gt;
    GTE, // &gt;=
}
<span class="boring">}</span></code></pre></pre>
<p>In the context of Valence Asserter, the predicate treats <code>a</code> as the left-hand-side and <code>b</code> as the right-hand-side variables (<code>a &lt; b</code>).</p>
<blockquote>
<p>While comparison of numeric types is pretty straightforward, it is important to note that string predicates are evaluated in lexicographical order and are case sensitive:</p>
<ul>
<li>"Z" &lt; "a"</li>
<li>"Assertion" != "assertion"</li>
</ul>
</blockquote>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>Consider that a Valence Program wants to provide liquidity to a liquidity pool if and only if
the pool price is above <code>10.0</code>.</p>
<p>Pool price can be obtained by querying a <code>ValenceXykPool</code> variant which exposes the following query:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ValenceXykQuery::GetPrice {} -&gt; Decimal
<span class="boring">}</span></code></pre></pre>
<p>The program is configured to store the respective <code>ValenceXykPool</code> in a Storage Account with address
<code>neutron123...</code>, under storage slot <code>pool</code>.</p>
<p>Filling in the blanks of <em>R(a, b)</em>, we have:</p>
<ul>
<li>variable <code>a</code> is obtained with the <code>GetPrice {}</code> query of <code>neutron123...</code> storage slot <code>pool</code></li>
<li>predicate <code>R</code> is known in advance: <code>&gt;</code></li>
<li>constant <code>b</code> is known in advance: <code>10.0</code></li>
</ul>
<p>Thefore the assertion message may look as follows:</p>
<pre><code class="language-json">"assert": {
  "a": {
    "variable": {
      "storage_account": "neutron123...",
      "storage_slot": "pool",
      "query": b64("GetPrice {}"),
    }
  },
  "predicate": Predicate::GT,
  "b": {
    "constant": "10.0",
  },
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="program-manager"><a class="header" href="#program-manager">Program manager</a></h1>
<p>The program manager is an off-chain tool that helps instantiate, update and migrate a program.</p>
<p><strong>Guides</strong></p>
<ul>
<li><a href="program_manager/./how_to.html">How to</a></li>
<li><a href="program_manager/./build_program_config.html">Build program config</a></li>
</ul>
<p><strong>Program manager components</strong>:</p>
<ul>
<li><a href="program_manager/./manager_config.html">Manager config</a></li>
<li><a href="program_manager/./program_configs/instantiate.html">Program config</a></li>
<li><a href="program_manager/./program_configs/update.html">Program config update</a></li>
<li><a href="program_manager/./program_configs/migrate.html">Program config migrate</a></li>
<li><a href="program_manager/./library_account_type.html">Library Account Type</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manager-config---before-the-manager-can-work"><a class="header" href="#manager-config---before-the-manager-can-work">Manager config - before the manager can work</a></h1>
<p>The manager is performing actions on chains included in the program, and for that the manager need to have certain information that will allow him to perform those actions.</p>
<p>You can read more about the <a href="program_manager/./manager_config.html">manager config here</a>.</p>
<h1 id="wallet"><a class="header" href="#wallet">Wallet</a></h1>
<p>The manager requires a funded wallet to perform actions on chain, it expects the mnemonic of the wallet to be included in the <strong>MANAGER_MNEMONIC</strong> environment variable.</p>
<ul>
<li>Note - This wallet should NOT be the owner of the program, this is a helper wallet that allows the manager to execute actions on chain, it should be funded with just enough funds to perform those actions.</li>
</ul>
<h1 id="how-to-use-program-manager"><a class="header" href="#how-to-use-program-manager">How to use program manager</a></h1>
<p>The program manager is a library, it can be used as dependency in any rust project.</p>
<p>There are 3 functions that allow you to interact with a program:</p>
<ol>
<li><code>init_program(&amp;mut ProgramConfig)</code> - Instantiate a new program</li>
<li><code>update_program(ProgramConfigUpdate)</code> - Update existing program</li>
<li><code>migrate_program(ProgramConfigMigrate)</code> - Migrate existing program to a new program</li>
</ol>
<h2 id="instantiate-a-program"><a class="header" href="#instantiate-a-program">Instantiate a program</a></h2>
<p><code>init_program()</code> takes a program config to instantiate and mutate it with the instantiated program config.</p>
<p>Read more in <a href="program_manager/./program_configs/instantiate.html">Program config</a></p>
<h2 id="update-a-program"><a class="header" href="#update-a-program">Update a program</a></h2>
<p><code>update_program()</code> takes a set of instructions to update an existing program and returns a set of messages that can be executed by the owner.</p>
<p>This is useful to batch update library configs and authorizations.</p>
<ul>
<li>Note - <code>update_program()</code> returns a set of messages that are needed to perform the update, those messages must be executed by the owner of the program.</li>
</ul>
<p>Read more in <a href="program_manager/./program_configs/update.html">Program config update</a></p>
<h2 id="migrate-a-program"><a class="header" href="#migrate-a-program">Migrate a program</a></h2>
<p><code>migrate_program()</code> allows the owner to "disable" an old program, and move all the funds to the new program.</p>
<p>This is useful when you want to disable an old program and move the funds to a new program.</p>
<ul>
<li>Note - <code>migrate_program()</code> returns a set of messages to move the funds and pause the program that must be executed by the owner.</li>
</ul>
<p>Read more in <a href="program_manager/./program_configs/migrate.html">Program config migrate</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manager-config"><a class="header" href="#manager-config">Manager config</a></h1>
<p>The program manager requires information like chain connection details and bridges details, this must be provided to the manager via a config.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Config {
    // Map of chain connections details
    pub chains: HashMap&lt;String, ChainInfo&gt;,
    // Contract information per chain for instantiation
    pub contracts: Contracts,
    // Map of bridges information
    pub bridges: HashMap&lt;String, HashMap&lt;String, Bridge&gt;&gt;,
    pub general: GeneralConfig,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<p>The manager config is a global mutateable config and can be read and set from anywhere in your project.</p>
<h3 id="get-config"><a class="header" href="#get-config">Get config</a></h3>
<p>You can get the config like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let manager_config = valence_program_manager::config::GLOBAL_CONFIG.lock().await
<span class="boring">}</span></code></pre></pre>
<h3 id="write-config"><a class="header" href="#write-config">Write config</a></h3>
<p>Writing to the config is possible with:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut manager_config = valence_program_manager::config::GLOBAL_CONFIG.lock().await

// Mutate field
manager_config.general.registry_addr = "addr1234".to_string();

// Write full config
*manager_config = new_manager_config;
<span class="boring">}</span></code></pre></pre>
<h3 id="non-async-functions"><a class="header" href="#non-async-functions">Non-async functions</a></h3>
<p>The manager config is using <code>tokio::sync::Mutex</code>, because of that, you need to use blocking operation in non-async functions, like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let rt = tokio::runtime::Builder::new_current_thread()
        .enable_all()
        .build()
        .unwrap();
rt.block_on(valence_program_manager::config::GLOBAL_CONFIG.lock())
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Note - You must be careful with blocking, the manager might be blocked from accessing the global config if not freed properly.</li>
</ul>
<h2 id="example-1"><a class="header" href="#example-1">Example</a></h2>
<p>We have a public repo that include configs for major persistant environments (like mainnet and testnet)</p>
<p>It can be used directly in the manager to deploy on those environments or as example to a working manager config layout.</p>
<p><a href="https://github.com/timewave-computer/valence-program-manager-config">Public manager configs</a></p>
<h2 id="config-fields"><a class="header" href="#config-fields">Config fields</a></h2>
<h3 id="chains"><a class="header" href="#chains">Chains</a></h3>
<p>This is a map of <code>chain_id =&gt; ChainInfo</code>.</p>
<p>It allows the manager to connect to chains that are required by your program and to execute actions on chain and query data.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ChainInfo {
    pub name: String,
    pub rpc: String,
    pub grpc: String,
    pub prefix: String,
    pub gas_price: String,
    pub gas_denom: String,
    pub coin_type: u64,
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>
<p>Note - Your program might require multiple chains, all chains must be included in the config or the manager will fail.</p>
</li>
<li>
<p>Note - Neutron chain must be included even if the program is not using it as a domain.</p>
</li>
</ul>
<h3 id="contracts"><a class="header" href="#contracts">Contracts</a></h3>
<p>Contracts field includes all the code ids of contract</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Contracts {
    pub code_ids: HashMap&lt;String, HashMap&lt;String, u64&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><code>code_ids</code> field is a map of <code>chain_id =&gt; map(contract_name =&gt; code_id)</code></p>
<p>This allows the manager to find the code id of a contract on a specific chain to instantiate it.</p>
<h3 id="bridges"><a class="header" href="#bridges">Bridges</a></h3>
<p>The bridge is a complex map of bridge information needed for cross-chain operations.</p>
<p>The easiest way to explain it is by <code>toml</code> format:</p>
<pre><code class="language-toml">[bridges.neutron.juno.polytone.neutron]
voice_addr      = "neutron15c0d3k8nf5t82zzkl8l7he3smx033hsr9dvzjeeuj7e8n46rqy5se0pn3e"
note_addr       = "neutron174ne8p7zh539sht8sfjsa9r6uwe3pzlvqedr0yquml9crfzsfnlshvlse8"
other_note_port = "wasm.juno1yt5kcplze0sark8f55fklk70uay3863t5q3j3a8kgvs3rlmjya9qys0d2y"
connection_id   = "connection-95"
channel_id      = "channel-4721"
[bridges.neutron.juno.polytone.juno]
voice_addr      = "juno1c9hx3q7sd2d0xgknc52ft6qsqxemkuxh3nt8d4rmdtdua25x5h0sdd2zm5"
note_addr       = "juno1yt5kcplze0sark8f55fklk70uay3863t5q3j3a8kgvs3rlmjya9qys0d2y"
other_note_port = "wasm.neutron174ne8p7zh539sht8sfjsa9r6uwe3pzlvqedr0yquml9crfzsfnlshvlse8"
connection_id   = "connection-530"
channel_id      = "channel-620"
</code></pre>
<p>We are providing a bridge information here between <code>neutron</code> and <code>juno</code> chains, the bridge we are using is <code>polytone</code>, and the first information is for the <code>neutron</code> "side", while the second information is for the <code>juno</code> "side".</p>
<h3 id="general"><a class="header" href="#general">General</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct GeneralConfig {
    pub registry_addr: String,
}
<span class="boring">}</span></code></pre></pre>
<p>General field holds general information that is needed for the manager to work:</p>
<ul>
<li><code>registry_addr</code> - The registry contract address on neutron.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="instantiate-program"><a class="header" href="#instantiate-program">Instantiate program</a></h1>
<p>The manager is using the program config to instantiate the full flow of the program on-chain.</p>
<p>After instantiation of a program, the program config will contain the instantiated data of the program.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ProgramConfig {
    pub id: u64,
    pub name: String,
    pub owner: String,
    pub links: BTreeMap&lt;Id, Link&gt;,
    pub accounts: BTreeMap&lt;Id, AccountInfo&gt;,
    pub libraries: BTreeMap&lt;Id, LibraryInfo&gt;,
    pub authorizations: Vec&lt;AuthorizationInfo&gt;,
    #[serde(default)]
    pub authorization_data: AuthorizationData,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="id"><a class="header" href="#id">Id</a></h2>
<p>Unique identifier of a program, it is used to save the program config on-chain.</p>
<p>Should be set to <code>0</code> when instantiating a new program.</p>
<h2 id="name"><a class="header" href="#name">Name</a></h2>
<p>A short description of the program to easily identify it.</p>
<h1 id="links"><a class="header" href="#links">Links</a></h1>
<p>A map of links between libraries and the connected input and output accounts.</p>
<p>This allows us to represent a program in a graph.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Link {
    /// List of input accounts by id
    pub input_accounts_id: Vec&lt;Id&gt;,
    /// List of output accounts by id
    pub output_accounts_id: Vec&lt;Id&gt;,
    /// The library id
    pub library_id: Id,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="accounts"><a class="header" href="#accounts">Accounts</a></h2>
<p>A list of accounts that are being used by the program</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AccountInfo {
    // The name of the account
    pub name: String,
    // The type of the account
    pub ty: AccountType,
    // The domain this account is on
    pub domain: Domain,
    // The instantiated address of the account
    pub addr: Option&lt;String&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="name-1"><a class="header" href="#name-1">Name</a></h3>
<p>Identifying name for this account</p>
<h3 id="accounttype"><a class="header" href="#accounttype">AccountType</a></h3>
<p>Account type allows the manager to know whether the account should be instantiated or not, and what type of account we should instantiate.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum AccountType {
    /// Existing address on chain
    Addr { addr: String },
    /// This is our base account implementation
    Base { admin: Option&lt;String&gt; },
}
<span class="boring">}</span></code></pre></pre>
<h3 id="domain"><a class="header" href="#domain">Domain</a></h3>
<p>On what domain the account exists or should be instantiated on.</p>
<h3 id="addr"><a class="header" href="#addr">Addr</a></h3>
<p>This field will be set by the manager once the account is intantiated.</p>
<h2 id="libraries-1"><a class="header" href="#libraries-1">Libraries</a></h2>
<p>A list of libraries that are being used by the program.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct LibraryInfo {
    pub name: String,
    pub domain: Domain,
    pub config: LibraryConfig,
    pub addr: Option&lt;String&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="name-2"><a class="header" href="#name-2">Name</a></h3>
<p>The identifying name of this specific library</p>
<h3 id="domain-1"><a class="header" href="#domain-1">Domain</a></h3>
<p>The specific domain this library is on.</p>
<h3 id="config"><a class="header" href="#config">Config</a></h3>
<p>The library specific config that will be used during instantiation.</p>
<p><code>LibraryConfig</code> is an enum of libraries that currently exist and can be used in programs.</p>
<h3 id="addr-1"><a class="header" href="#addr-1">Addr</a></h3>
<p>This will include the address of the library contract once instantiated</p>
<h2 id="authorizations"><a class="header" href="#authorizations">Authorizations</a></h2>
<p>This is a list of all authorizations that should be included in the authorization contract.</p>
<h2 id="authorization-data"><a class="header" href="#authorization-data">Authorization data</a></h2>
<p>This field includes all the data regarding authorization contract and processors on all chains.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AuthorizationData {
    /// authorization contract address on neutron
    pub authorization_addr: String,
    /// List of processor addresses by domain
    /// Key: domain name | Value: processor address
    pub processor_addrs: BTreeMap&lt;String, String&gt;,
    /// List of authorization bridge addresses by domain
    /// The addresses are on the specified domain
    /// Key: domain name | Value: authorization bridge address on that domain
    pub authorization_bridge_addrs: BTreeMap&lt;String, String&gt;,
    /// List of processor bridge addresses by domain on neutron chain
    pub processor_bridge_addrs: Vec&lt;String&gt;,
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>authorization_addr</code> - Authorization contract address on neutron</li>
<li><code>processor_addrs</code> - Map of all processors by domain</li>
<li><code>authorization_bridge_addrs</code> - Bridge account address of the authorization contract on all chains</li>
<li><code>processor_bridge_addrs</code> - List of bridge accounts of processors on neutron chain</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="update-a-program-1"><a class="header" href="#update-a-program-1">Update a program</a></h1>
<p>Updating a program allows you to:</p>
<ul>
<li>Change the owner of a program</li>
<li>Update libraries configs</li>
<li>Add/Modify/Enable/Disable authorizations</li>
</ul>
<p>The manager will NOT perform those operations directly, rather output a list of messages that needs to be executed by the owner to achieve the updated program.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ProgramConfigUpdate {
    /// The id of a program to update
    pub id: u64,
    /// New owner, if the owner is to be updated
    pub owner: Option&lt;String&gt;,
    /// The list of library config updates to perform
    pub libraries: BTreeMap&lt;Id, LibraryConfigUpdate&gt;,
    /// A list of authorizations
    pub authorizations: Vec&lt;AuthorizationInfoUpdate&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="id-1"><a class="header" href="#id-1">Id</a></h2>
<p>The id of the program to perform the update on, the manager will look for this id in the on-chain registry and pull the current program config that exists.</p>
<h2 id="owner"><a class="header" href="#owner">Owner</a></h2>
<p>Optional field to update the owner, it takes the new owner address.</p>
<h2 id="libraries-2"><a class="header" href="#libraries-2">Libraries</a></h2>
<p>A map of <code>library_id =&gt; library_config</code>.</p>
<p><code>LibraryConfigUpdate</code> is an enum that includes all possible libraries and their <code>LibraryConfigUpdate</code> type</p>
<h2 id="authorizations-1"><a class="header" href="#authorizations-1">Authorizations</a></h2>
<p>A list of operations to do on the authorizations table</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum AuthorizationInfoUpdate {
    Add(AuthorizationInfo),
    Modify {
        label: String,
        not_before: Option&lt;Expiration&gt;,
        expiration: Option&lt;Expiration&gt;,
        max_concurrent_executions: Option&lt;u64&gt;,
        priority: Option&lt;Priority&gt;,
    },
    /// Disable by label
    Disable(String),
    /// Disable by label
    Enable(String),
}
<span class="boring">}</span></code></pre></pre>
<h3 id="add"><a class="header" href="#add">Add</a></h3>
<p>Adds a new authorization with that info</p>
<h3 id="modify"><a class="header" href="#modify">Modify</a></h3>
<p>Modifies an existing authorization with that label</p>
<h3 id="disable"><a class="header" href="#disable">Disable</a></h3>
<p>Disables an existing authorization by label</p>
<h3 id="enable"><a class="header" href="#enable">Enable</a></h3>
<p>Enable a disabled authorization by label</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migrate-a-program-1"><a class="header" href="#migrate-a-program-1">Migrate a program</a></h1>
<p>Migrating a program allows you to pause an existing program and perform funds transfer from accounts that hold funds in an old program to accounts in the new program.</p>
<p>Like updating a program, the manager will not perform those actions but will output a set of instructions to be executed by the owner.</p>
<p>Unlike the update, migration requires 2 sets of actions:</p>
<ol>
<li>Transfer all funds from the old program to the new program</li>
<li>Pause the old program processors</li>
</ol>
<p>Pausing the program will not allow any actions to be done on the old program including transferring the funds, for this reason, we first transfer all the funds, and only then pausing the old program.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ProgramConfigMigrate {
    pub old_id: Id,
    /// The new program we instantiate
    pub new_program: ProgramConfig,
    /// Transfer funds details
    pub transfer_funds: Vec&lt;FundsTransfer&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="old-id"><a class="header" href="#old-id">Old id</a></h2>
<p>This is the id of the old program</p>
<h2 id="new-program"><a class="header" href="#new-program">New program</a></h2>
<p>This is the config of the new program to instantiate</p>
<h2 id="transfer-funds"><a class="header" href="#transfer-funds">Transfer funds</a></h2>
<p>A list of transfers to perform</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct FundsTransfer {
    pub from: String,
    pub to: LibraryAccountType,
    pub domain: Domain,
    pub funds: Coin,
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>from</code> - From what adress to move funds to, must be an account owned by the old program</li>
<li><code>to</code> - A <code>LibraryAccountType</code> can either be set as an address, or an account id of an account in the new program</li>
<li><code>domain</code> - On what domain to perform this transfer, both <code>from</code> and <code>to</code> must be on that domain</li>
<li><code>funds</code> - The amount of funds to transfer</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="build-a-program-config"><a class="header" href="#build-a-program-config">Build a program config</a></h1>
<p>The manager entry points are expecting a rust type, you can use any way you are familiar with to build this type, here are some examples</p>
<h2 id="using-deployer"><a class="header" href="#using-deployer">Using deployer</a></h2>
<p><a href="https://github.com/timewave-computer/program-deployer-template">Timewave Deployer</a> is an easy way of building programs, you can follow the README to set the deployer.</p>
<p>You can view <a href="https://github.com/timewave-computer/timewave-program-deployments">Timewave deployments</a> repository to see an example of already deployed programs using the deployer.</p>
<h2 id="program-builder"><a class="header" href="#program-builder">Program builder</a></h2>
<p>Our above deployer is using a rust builder to build a program, an example of this can be found in our <a href="https://github.com/timewave-computer/program-deployer-template/blob/main/programs/program_template/src/program_builder.rs">program template</a></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut builder = ProgramConfigBuilder::new("example-program", owner.as_str());
<span class="boring">}</span></code></pre></pre>
<p><code>ProgramConfigBuilder::new(NAME, OWNER)</code> provides an easy way to add accounts, libraries and authorizations to build the program config.</p>
<h2 id="json-file"><a class="header" href="#json-file">JSON file</a></h2>
<p>A program config can also be parsed from a JSON file to <code>ProgramConfig</code> type.</p>
<p>Here is an <a href="https://github.com/timewave-computer/timewave-program-deployments/blob/main/programs/2025-03-23-prod-dICS-ntrn-allocation/output/mainnet-2025-03-31_18%3A38%3A02-success/raw-program-config.json">example</a> from past deployments of a JSON file of a program config that can be provided to the manager to be intantiated.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="library-account-type"><a class="header" href="#library-account-type">Library account type</a></h1>
<p>When we build a new program, we don't yet have an on-chain address, but there are several components that require an address to operate, for example a library needs to know the input account address it should operate on.</p>
<p>When building a fresh program config, we are using ids instead of addresses, the manager first predicts all the addresses of to-be instantiated contracts, and replace the ID with the address where an id was used.</p>
<p>To achieve this we are using the <code>LibraryAccountType</code> that first uses an id, and allows us to replace it with an address later when this contract was instantiated.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum LibraryAccountType {
    #[serde(rename = "|library_account_addr|", alias = "library_account_addr")]
    Addr(String),
    #[serde(rename = "|account_id|", alias = "account_id")]
    AccountId(Id),
    #[serde(rename = "|library_id|", alias = "library_id")]
    LibraryId(Id),
}
<span class="boring">}</span></code></pre></pre>
<p><code>LibraryAccountType</code> is an enum that includes 3 options:</p>
<ul>
<li><code>Addr(String)</code> - Already instantiated on-chain address, this means we should not replace it</li>
<li><code>AccountId(Id)</code> - Account id that should be replaced with the address of an account</li>
<li><code>LibraryId(Id)</code> - Library id that should be replaced with the address of a library</li>
</ul>
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<h3 id="to_string---stdresult"><a class="header" href="#to_string---stdresult">to_string() -&gt; StdResult<Addr></a></h3>
<p>If <code>LibraryAccountType:Addr</code>, we return the address as a string.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let addr = LibraryAccountType::Addr("some_addr".to_string());

let addr_string = addr.to_string();

assert_eq!(addr_string, "some_addr")
<span class="boring">}</span></code></pre></pre>
<p>Will error if <code>LibraryAccountType</code> is an id.</p>
<h3 id="to_addrapi-dyn-cosmwasm_stdapi---stdresultcosmwasm_stdaddr"><a class="header" href="#to_addrapi-dyn-cosmwasm_stdapi---stdresultcosmwasm_stdaddr">to_addr(api: &amp;dyn cosmwasm_std::Api) -&gt; StdResult&lt;cosmwasm_std::Addr&gt;</a></h3>
<p>Returns the address in <code>cosmwasm_std::Addr</code> type</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let addr = LibraryAccountType::Addr("some_addr".to_string());
let api = mock_api();

let addr_as_addr = addr.to_addr(&amp;api);

assert_eq!(addr_as_addr, cosmwasm_std::Addr::unchecked("some_addr"))
<span class="boring">}</span></code></pre></pre>
<p>Will error if <code>LibraryAccountType</code> is an id.</p>
<h3 id="to_raw_placeholder---string"><a class="header" href="#to_raw_placeholder---string">to_raw_placeholder() -&gt; String</a></h3>
<p>Although it is encouraged for libraries to accept the <code>LibraryAccountType</code> directly as an address, some libraries may require a <code>Strin</code>.</p>
<p><code>to_raw_placeholder</code> allows us to still use account ids in library config where a <code>String</code> is expected.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct LibraryConfig {
    addr: String,
}
let addr_id = LibraryAccountType::AccountId(1);

let library_config = LibraryConfig { addr: addr_id.to_raw_placeholder() }

// Here is library config before passing to the manager:
// LibraryConfig { addr: "|lib_acc_placeholder|:1" }

init_program(&amp;mut program_config);

// Here is the library config after instantiation:
// LibraryConfig { addr: "addres_of_account_id_1" }
<span class="boring">}</span></code></pre></pre>
<h3 id="from_strinput-str---resultself-string"><a class="header" href="#from_strinput-str---resultself-string">from_str(input: &amp;str) -&gt; Result&lt;Self, String&gt;</a></h3>
<p>You can get <code>LibraryAccountType::Addr</code> from a string</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let addr = "some_addr";

let LAT = LibraryAccountType::from(addr);
let LAT: LibraryAccountType = addr.into();

// Both are equal to `LibraryAccountType::Addr("some_addr".to_string())`
<span class="boring">}</span></code></pre></pre>
<h3 id="get_account_idself---id"><a class="header" href="#get_account_idself---id">get_account_id(&amp;self) -&gt; Id</a></h3>
<p>Gets the id if <code>LibraryAccountType::AccountId</code>, else it panics.</p>
<h3 id="get_library_idself---id"><a class="header" href="#get_library_idself---id">get_library_id(&amp;self) -&gt; Id;</a></h3>
<p>Gets the id if <code>LibraryAccountType::LibraryId</code>, else it panics.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<p>Here are some examples of Valence Programs that you can use to get started.</p>
<ul>
<li><a href="examples/./token_swap.html">Token Swap</a></li>
<li><a href="examples/./crosschain_vaults.html">Crosschain Vaults</a>
<ul>
<li><a href="examples/./vault_strategist.html">Vault Strategist</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="token-swap-program"><a class="header" href="#token-swap-program">Token Swap Program</a></h1>
<p>This example demonstrates a simple <em>token swap</em> program whereby two parties wish to exchange specific amounts of (different) tokens they each hold, at a rate they have previously agreed on. The program ensures the swap happens atomically, so neither party can withdraw without completing the trade.</p>
<pre class="mermaid">---
title: Valence token swap program
---
graph LR
	InA((Party A Deposit))
	InB((Party B Deposit))
	OutA((Party A Withdraw))
	OutB((Party B Withdraw))
	SSA[Splitter A]
	SSB[Splitter B]
	subgraph Neutron
	InA --&gt; SSA --&gt; OutB
	InB --&gt; SSB --&gt; OutA
	end
</pre>
<p>The program is composed of the following components:</p>
<ul>
<li><strong>Party A Deposit account</strong>: a <a href="examples/../accounts/base_accounts.html">Valence Base account</a> which Party A will deposit their tokens into, to be exchanged with Party B's tokens.</li>
<li><strong>Splitter A</strong>: an instance of the <a href="examples/../libraries/cosmwasm/splitter.html">Splitter library</a> that will transfer Party A's tokens from its input account (i.e. the <strong>Party A Deposit account</strong>) to its output account (i.e. the <strong>Party B Withdraw account</strong>) upon execution of its <code>split</code> function.</li>
<li><strong>Party B Withdraw account</strong>: the account from which Party B can withdraw Party A's tokens after the swap has successfully completed. Note: this can be a <a href="examples/../accounts/base_accounts.html">Valence Base account</a>, but it could also be a regular chain account, or a smart contract.</li>
<li><strong>Party B Deposit account</strong>:  a <a href="examples/../accounts/base_accounts.html">Valence Base account</a> which Party B will deposit their funds into, to be exchanged with Party A's funds.</li>
<li><strong>Splitter B</strong>: an instance of the <a href="examples/../libraries/cosmwasm/splitter.html">Splitter library</a> that will transfer Party B's tokens from its input account (i.e. the <strong>Party B Deposit account</strong>) to its output account (i.e. the <strong>Party A Withdraw account</strong>) upon execution of its <code>split</code> function.</li>
<li><strong>Party A Withdraw account</strong>: the account from which Party A can withdraw Party B's tokens after the swap has successfully completed. Note: this can be a <a href="examples/../accounts/base_accounts.html">Valence Base account</a>, but it could also be a regular chain account, or a smart contract.</li>
</ul>
<p>The way the program is able to fulfil the requirement for an <em>atomic exchange of tokens</em> between the two parties is done by implementing an <strong>atomic subroutine</strong> composed of two function calls:</p>
<ol>
<li><strong>Splitter A</strong>'s <code>split</code> function</li>
<li><strong>Splitter B</strong>'s <code>split</code> function</li>
</ol>
<p>The Authorizations component will ensure that either both succeed, or none is executed, thereby ensuring that <strong>funds remain safe at all time</strong> (either remaining in the respective deposit accounts, or transferred to the respective withdraw accounts).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crosschain-vaults"><a class="header" href="#crosschain-vaults">Crosschain Vaults</a></h1>
<p><strong>Note:</strong> <em>This example is still in the design phase and includes new or experimental features of Valence Programs that may not be supported in the current production release.</em></p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>You can use Valence Programs to create crosschain vaults. Users interact with a vault on one chain while the tokens are held on another chain where yield is generated.</p>
<p>Note: In our initial implementation we use Neutron for co-processing and Hyperlane for general message passing between the co-processor and the target domain. Deployment of Valence programs as zk RISC-V co-processors with permissionless message passing will be available in the coming months.</p>
<p>In this example, we have made the following assumptions:</p>
<ul>
<li>Users can deposit tokens into a standard ERC-4626 vault on Ethereum.</li>
<li>ERC-20 shares are issued to users on Ethereum.</li>
<li>If a user wishes to redeem their tokens, they can issue a withdrawal request which will burn the user's shares when tokens are redeemed.</li>
<li>The redemption rate that tells us how many tokens can be redeemed per shares is given by: \( R = \frac{TotalAssets}{TotalIssuedShares} = \frac{TotalInVault + TotalInTransit + TotalInPostion}{TotalIssuedShares}\)</li>
<li>A permissioned actor called the "Strategist" is authorized to transport funds from Ethereum to Neutron where they are locked in some DeFi protocol. And vice-versa, the Strategist can withdraw from the position so the funds are redeemable on Ethereum. The redemption rate must be adjusted by the Strategist accordingly.</li>
</ul>
<pre class="mermaid">---
title: Crosschain Vaults Overview
---
graph LR
	User
	EV(Ethereum Vault)
	NP(Neutron Position)

	User -- Tokens --&gt; EV
	EV -- Shares --&gt; User
	EV -- Strategist Transport --&gt; NP
	NP -- Strategist Transport --&gt; EV
</pre>
<p>While we have chosen Ethereum and Neutron as examples here, one could similarly construct such vaults between any two chains as long as they are supported by Valence Programs.</p>
<h2 id="implementing-crosschain-vaults-as-a-valence-program"><a class="header" href="#implementing-crosschain-vaults-as-a-valence-program">Implementing Crosschain Vaults as a Valence Program</a></h2>
<p>Recall that Valence Programs are comprised of Libraries and Accounts. Libraries are a collection of Functions that perform token operations on the Accounts. Since there are two chains here, Libraries and Accounts will exist on both chains.</p>
<p>Since gas is cheaper on Neutron than on Ethereum, computationally expensive operations, such as constraining the Strategist actions will be done on Neutron. Authorized messages will then be executed by each chain's Processor. Hyperlane is used to pass messages from the Authorization contract on Neutron to the Processor on Ethereum.</p>
<pre class="mermaid">---
title: Program Control
---
graph TD
	Strategist
	subgraph Ethereum
		EP(Processor)
		EHM(Hyperlane Mailbox)
		EL(Ethereum Valence Libraries)
		EVA(Valence Accounts)
	end
	subgraph Neutron
		A(Authorizations)
		NP(Processor)
		EE(EVM Encoder)
		NHM(Hyperlane Mailbox)
		NL(Neutron Valence Libraries)
		NVA(Valence Accounts)
	end

	Strategist --&gt; A
	A --&gt; EE --&gt; NHM --&gt; Relayer --&gt; EHM --&gt; EP --&gt; EL --&gt; EVA
	A --&gt; NP --&gt; NL--&gt; NVA
</pre>
<h3 id="libraries-and-accounts-needed"><a class="header" href="#libraries-and-accounts-needed">Libraries and Accounts needed</a></h3>
<p>On Ethereum, we'll need Accounts for:</p>
<ul>
<li><strong>Deposit</strong>: To hold user deposited tokens. Tokens from this pool can be then transported to Neutron.</li>
<li><strong>Withdraw</strong>: To hold tokens received from Neutron. Tokens from this pool can then be redeemed for shares.</li>
</ul>
<p>On Neutron, we'll need Accounts for:</p>
<ul>
<li><strong>Deposit</strong>: To hold tokens bridged from Ethereum. Tokens from this pool can be used to enter into the position on Neutron.</li>
<li><strong>Position</strong>: Will hold the vouchers or shares associated with the position on Neutron.</li>
<li><strong>Withdraw</strong>: To hold the tokens that are withdrawn from the position. Tokens from this pool can be bridged back to Ethereum.</li>
</ul>
<p>We'll need the following Libraries on Ethereum:</p>
<ul>
<li><strong>Bridge Transfer</strong>: To transfer funds from the Ethereum Deposit Account to the Neutron Deposit Account.</li>
<li><strong>Forwarder</strong>: To transfer funds between the Deposit and Withdraw Accounts on Ethereum. Two instances of the Library will be required.</li>
</ul>
<p>We'll need the following Libraries on Neutron:</p>
<ul>
<li><strong>Position Depositor</strong>: To take funds in the Deposit and create a position with them. The position is held by the Position account.</li>
<li><strong>Position Withdrawer</strong>: To redeem a position for underlying funds that are then transferred to the Withdraw Account on Neutron.</li>
<li><strong>Bridge Transfer</strong>: To transfer funds from the Neutron Withdraw Account to the Ethereum Withdraw Account.</li>
</ul>
<p>Note that the Accounts mentioned here are the standard <a href="examples/../accounts/base_accounts.html">Valence Base Accounts</a>. The Bridge Transfer library will depend on the token being transferred, but will offer similar functionality to the <a href="examples/../libraries/cosmwasm/generic_ibc_transfer.html">IBC Transfer</a> library. The Position Depositor and Withdrawer will depend on the type of position, but can be similar to the <a href="examples/../libraries/cosmwasm/astroport_lper.html">Liquidity Provider</a> and <a href="examples/../libraries/cosmwasm/astroport_withdrawer.html">Liquidity Withdrawer</a>.</p>
<h3 id="vault-contract"><a class="header" href="#vault-contract">Vault Contract</a></h3>
<p>The Vault contract is a special contract on Ethereum that has an ERC-4626 interface.</p>
<h4 id="user-methods-to-deposit-funds"><a class="header" href="#user-methods-to-deposit-funds">User methods to deposit funds</a></h4>
<ul>
<li><strong>Deposit</strong>: Deposit funds into the registered Deposit Account. Receive shares back based on the redemption rate.
<pre><code>Deposit {
	amount: Uint256,
	receiver: String
}
</code></pre>
</li>
<li><strong>Mint</strong>: Mint shares from the vault. Expects the user to provide sufficient tokens to cover the cost of the shares based on the current redemption rate.
<pre><code>Mint {
	shares: Uint256,
	receiver: String
}
</code></pre>
</li>
</ul>
<pre class="mermaid">---
title: User Deposit and Share Mint Flow
---
graph LR
	User
	subgraph Ethereum
		direction LR
		EV(Vault)
		ED((Deposit))
	end

	User -- 1/ Deposit Tokens --&gt; EV
	EV -- 2/ Send Shares --&gt; User
	EV -- 3/ Send Tokens --&gt; ED
</pre>
<h4 id="user-methods-to-withdraw-funds"><a class="header" href="#user-methods-to-withdraw-funds">User methods to withdraw funds</a></h4>
<ul>
<li><strong>Redeem</strong>: Send shares to redeem assets. This creates a <code>WithdrawRecord</code> in a queue. This record is processed at the next <code>Epoch</code>
<pre><code>Redeem {
	shares: Uint256,
	receiver: String,
	max_loss_bps: u64
}
</code></pre>
</li>
<li><strong>Withdraw</strong>: Withdraw amount of assets. It expects the user to have sufficient shares. This creates a <code>WithdrawRecord</code> in a queue. This record is processed at the next <code>Epoch</code>.
<pre><code>Withdraw {
	amount: Uint256,
	receiver: String,
	max_loss_bps: u64
}
</code></pre>
</li>
</ul>
<p>Withdraws are subject to a lockup period after the user has initiated a redemption. During this time the redemption rate may change. Users can specify an acceptable loss in case the redemption rate decreases using the <code>max_loss_bps</code> parameter.</p>
<p>After the <code>Epoch</code> has completed, a user may complete the withdrawal by executing the following message:</p>
<ul>
<li><strong>CompleteWithdraw</strong>: Pop the <code>WithdrawRecord</code>. Pull funds from the Withdraw Account and send to user. Burn the user's deposited shares.</li>
</ul>
<pre class="mermaid">---
title: User Withdraw Flow
---
graph RL
	subgraph Ethereum
		direction RL
		EV(Vault)
		EW((Withdraw))
	end
	EW -- 2/ Send Tokens --&gt; EV -- 3/ Send Tokens --&gt; User
	User -- 1/ Deposit Shares --&gt; EV

</pre>
<h3 id="strategist-methods-to-manage-the-vault"><a class="header" href="#strategist-methods-to-manage-the-vault">Strategist methods to manage the vault</a></h3>
<p>The vault validates that the Processor is making calls to it. On Neutron, the Authorization contract limits the calls to be made only by a trusted Strategist. The Authorization contract can further constrain when or how Strategist actions can be taken.</p>
<ul>
<li><strong>Update</strong>: The strategist can update the current redemption rate.
<pre><code>Update {
  rate: Uint256
}
</code></pre>
</li>
<li><strong>Pause and Unpause</strong>: The strategist can pause and unpause vault operations.
<pre><code>Pause {}
</code></pre>
</li>
</ul>
<h3 id="program-subroutines"><a class="header" href="#program-subroutines">Program subroutines</a></h3>
<p>The program authorizes the Strategist to update the redemption rate and transport funds between various Accounts.</p>
<h4 id="allowing-the-strategist-to-transport-funds"><a class="header" href="#allowing-the-strategist-to-transport-funds">Allowing the Strategist to transport funds</a></h4>
<pre class="mermaid">---
title: From Ethereum Deposit Account to Neutron Position Account
---
graph LR
	subgraph Ethereum
		ED((Deposit))
		ET(Bridge Transfer)
	end
	subgraph Neutron
		NPH((Position Holder))
		NPD(Position Depositor)
		ND((Deposit))
	end

	ED --&gt; ET --&gt; ND --&gt; NPD --&gt; NPH
</pre>
<pre class="mermaid">---
title: From Neutron Position Account to Ethereum Withdraw Account
---
graph RL
	subgraph Ethereum
		EW((Withdraw))
	end
	subgraph Neutron
		NPH((Position Holder))
		NW((Withdraw))
		NT(Bridge Transfer)
		NPW(Position Withdrawer)
	end

	NPH --&gt; NPW --&gt; NW --&gt; NT --&gt; EW

</pre>
<pre class="mermaid">---
title: Between Ethereum Deposit and Ethereum Withdraw Accounts
---
graph
	subgraph Ethereum
		ED((Deposit))
		EW((Withdraw))
		FDW(Forwarder)
	end
	ED --&gt; FDW --&gt; EW
</pre>
<h2 id="design-notes"><a class="header" href="#design-notes">Design notes</a></h2>
<p>This is a simplified design to demonstrate how a crosschain vault can be implemented with Valence Programs. Production deployments will need to consider additional factors not covered here including:</p>
<ul>
<li>Fees for gas, bridging, and for entering/exiting the position on Neutron. It is recommend that the vault impose withdraw fee and platform for users.</li>
<li>How to constrain Strategist behavior to ensure they set redemption rates correctly.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vault-strategist"><a class="header" href="#vault-strategist">Vault Strategist</a></h1>
<p><strong>Note:</strong> <em>The Strategist is still in the design phase and includes new or experimental features of Valence Protocol that may not be supported in the current production release.</em></p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>Vault Strategist is a type of off-chain solver that performs operations needed in order to keep the <a href="examples/./crosschain_vaults.html">Valence Vaults</a> functioning and up to date.</p>
<p>Strategist is meant to be run as an independent process, only interacting with the domains relevant for its operations via (g)RPC requests submitted to respective nodes.</p>
<p>A complete on-chain flow of a cross-chain Valence Vault ‚Äî accepting deposits on Ethereum and entering a position on Neutron ‚Äî might look as follows:</p>
<pre class="mermaid">---
title: Vaults on-chain overview
---
flowchart BT
    ica_ibc_transfer --&gt; noble_inbound --&gt; ntrn_deposit
    ica_cctp_transfer --&gt; noble_outbound --&gt; eth_withdraw
    neutron_ibc_forwarder --&gt; ntrn_withdraw --&gt; noble_outbound
    cctp_forwarder --&gt; eth_deposit --&gt; noble_inbound

    subgraph Ethereum
        direction LR
        style Ethereum fill:#f0f0f0,stroke:#333,stroke-width:1px
        eth_deposit((Deposit acc));
        eth_withdraw((Withdraw acc));
        user(User);
        vault[Valence Vault];
        cctp_forwarder[CCTP Forwarder];
        user --&gt; vault --&gt; user
        vault --&gt; eth_deposit
        vault --&gt; eth_withdraw --&gt; user
    end


    subgraph Neutron
        direction RL
        style Neutron fill:#d6f5d6,stroke:#333,stroke-width:1px
        ntrn_deposit((Deposit acc));
        ntrn_position((Position acc));
        ntrn_withdraw((Withdraw acc));
        ica_ibc_transfer;
        astroport_lper;
        astroport_withdrawer;
        astroport_swap;
        neutron_ibc_forwarder;
        ica_cctp_transfer;

        ntrn_deposit --&gt; astroport_lper --&gt; ntrn_position
        ntrn_position --&gt; astroport_withdrawer --&gt; ntrn_withdraw
        ntrn_withdraw --&gt; astroport_swap --&gt; ntrn_withdraw
    end

    subgraph Noble
        direction LR
        style Noble fill:#d0e4ff,stroke:#333,stroke-width:1px
        noble_outbound((Noble Outbound ICA));
        noble_inbound((Noble Inbound ICA));
    end
</pre>
<h2 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h2>
<p>There are some prerequisites for a strategist to be able to carry out its entire order of operations.</p>
<p>These prerequisites will fit into the following broad categories:</p>
<ul>
<li>ability to submit (g)RPC requests to target domains</li>
<li>instantiated smart contracts on both Neutron and Ethereum that authorize the strategist to execute their methods</li>
<li>liveness of the transport protocol (CCTP) and the domains themselves</li>
</ul>
<h3 id="neutron-domain"><a class="header" href="#neutron-domain">Neutron Domain</a></h3>
<p>Neutron side of the cross-chain vaults flow will involve a set of accounts and libraries authorizing the strategist to perform certain restricted actions.</p>
<p><strong>Smart Contracts</strong>:</p>
<ul>
<li><em>Noble ICA ibc transfer</em> - transferring funds from Noble inbound ICA to Neutron Deposit account</li>
<li><em>Astroport Liquidity provider</em> - entering into position</li>
<li><em>Astroport Withdrawer</em> - exiting from a position</li>
<li><em>Neutron IBC forwarder</em> - transferring funds from Neutron Withdraw account to Noble outbound ICA</li>
<li><em>Noble CCTP transfer</em> - CCTP transferring funds from Noble outbound ICA to Ethereum withdraw account</li>
</ul>
<p><strong>Accounts</strong>:</p>
<ul>
<li><em>Noble Inbound Interchain Account</em></li>
<li><em>Noble Outbound Interchain Account</em></li>
<li><em>Deposit account</em></li>
<li><em>Position account</em></li>
<li><em>Withdraw account</em></li>
</ul>
<h3 id="ethereum-domain"><a class="header" href="#ethereum-domain">Ethereum Domain</a></h3>
<p>The Ethereum domain hosts the entry and exit point for user interaction. The strategist interacts with the vault and the CCTP forwarder to deposit or redeem tokens.</p>
<p><strong>Smart Contracts</strong>:</p>
<ul>
<li><em>CCTP Forwarder</em> - routing USDC from Ethereum to Noble</li>
<li><em>Valence Vault</em> - Vault based on ERC-4626</li>
</ul>
<p><strong>Accounts</strong>:</p>
<ul>
<li><em>Deposit account</em> - holding funds due to be routed to Noble</li>
<li><em>Withdraw account</em> - holding funds due to be distributed to users who initiated a withdrawal</li>
</ul>
<h3 id="noble-domain"><a class="header" href="#noble-domain">Noble Domain</a></h3>
<p>Noble acts as the intermediate bridging domain and handles both IBC and CCTP transfers.</p>
<p>Noble will host the inbound and outbound interchain accounts created by Valence Interchain Accounts deployed on Neutron.</p>
<p><strong>Inbound ICA</strong> is meant for:</p>
<ol>
<li>receiving tokens deposited from Ethereum via CCTP Forwarder</li>
<li>IBC Transferring those tokens from Noble to the Neutron deposit account</li>
</ol>
<p><strong>Outbound ICA</strong> is meant for:</p>
<ol>
<li>receiving withdrawn tokens from Neutron withdraw account</li>
<li>routing those tokens from Noble to the Ethereum withdraw account by submitting a CCTP request</li>
</ol>
<h3 id="valence-domain-clients"><a class="header" href="#valence-domain-clients">Valence Domain Clients</a></h3>
<p>The Strategist interacts with target domains by submitting (g)RPC requests.</p>
<p>These requests are constructed and submitted using <a href="https://github.com/timewave-computer/valence-domain-clients">Valence Domain Clients</a>, which support <code>async</code>/<code>await</code>, batched requests spanning an arbitrary number of domains, encoding schemes, and other domain-specific semantics in a standardized manner.</p>
<h3 id="cctp-attestation-service"><a class="header" href="#cctp-attestation-service">CCTP Attestation Service</a></h3>
<p>CCTP (Circle Cross-Chain Transfer Protocol) transfers require an attestation before assets can be minted on the destination chain.</p>
<p>Unfortunately the attestation service is closed-source and centralized. The only responsibility of the Strategist regarding it is to monitor its liveness, which is critical to Vault operation.</p>
<h2 id="strategist-operations"><a class="header" href="#strategist-operations">Strategist Operations</a></h2>
<p>The Strategist has a limited set of operations required to keep the Vault functioning properly.</p>
<p>There are various ways to orchestrate these operations. Some may be triggered by circuit breakers, event listeners, or other events.</p>
<p>To keep things simple, the following describes a basic strategy where actions are performed at fixed intervals (e.g., once per day):</p>
<h3 id="1-routing-funds-from-neutron-to-ethereum"><a class="header" href="#1-routing-funds-from-neutron-to-ethereum">1. Routing funds from Neutron to Ethereum</a></h3>
<p>Routing funds back to the Vault chain would involve the following steps:</p>
<ol>
<li>Neutron IBC Forwarder <code>transfer</code> call to IBC send the tokens from Neutron Withdraw account to Noble outbound ICA</li>
<li>Wait until the funds have arrived to the Noble outbound ICA</li>
<li>Noble CCTP transfer <code>transfer</code> call to CCTP transfer the tokens from Noble outbound ICA to the Ethereum withdraw account</li>
<li>Wait until the funds have arrived to the Ethereum withdraw account</li>
</ol>
<h3 id="2-update-the-vault-state"><a class="header" href="#2-update-the-vault-state">2. Update the Vault state</a></h3>
<p>Updating the Vault state is the most involved action that the strategist must take.</p>
<p>It involves three substeps and the final <code>update</code> call:</p>
<ol>
<li>Calculating the <em>netting amount <strong>N</strong></em>
<ol>
<li>Query the Ethereum Valence Vault for total amount due for withdrawal <em>S</em> (expressed in USDC)</li>
<li>Query the Ethereum deposit account balance $d$
$$N = min(d, S)$$</li>
</ol>
</li>
<li>Calculating the <em>redemption rate <strong>R</strong></em>
<ol>
<li>Query the Ethereum Valence Vault for total shares issued (<em>s</em>)</li>
<li>Query pending deposits in Neutron deposit account</li>
<li>Simulate the shares liquidation into the deposit denom
$$R = a / s$$</li>
</ol>
</li>
<li>Calculating the <em>total fee <strong>F</strong></em>
<ol>
<li>Query the Ethereum Valence Vault for the constant vault fee <em>F_c</em></li>
<li>Query the Neutron Astroport pool for the position fee <em>F_p</em>
$$F = F_c + F_p$$</li>
</ol>
</li>
<li>Ethereum Valence Vault update call: <code>update(R, P, S)</code></li>
</ol>
<h3 id="3-routing-funds-from-ethereum-to-neutron"><a class="header" href="#3-routing-funds-from-ethereum-to-neutron">3. Routing funds from Ethereum to Neutron</a></h3>
<p>Routing funds from Ethereum to Neutron is performed as follows:</p>
<ol>
<li>Ethereum CCTP transfer <code>transfer</code> call to CCTP transfer the tokens from Ethereum deposit account to Noble inbound ICA</li>
<li>Wait until the funds have arrived to the Noble inbound ICA</li>
<li>Noble ICA IBC transfer call to pull the funds from Noble inbound ICA to the Neutron Deposit account</li>
<li>Wait until the funds have arrived to the Neutron Deposit account</li>
</ol>
<h3 id="4-enter-the-position-on-neutron"><a class="header" href="#4-enter-the-position-on-neutron">4. Enter the position on Neutron</a></h3>
<p>Entering the position on Neutron is performed as follows:</p>
<ol>
<li>Query Neutron Deposit account balance of the deposit token</li>
<li>Astroport Liquidity provider <code>provide_single_sided_liquidity</code> call to enter into the position</li>
</ol>
<h3 id="5-exit-the-position-on-neutron"><a class="header" href="#5-exit-the-position-on-neutron">5. Exit the position on Neutron</a></h3>
<p>Exiting the position on Neutron is performed as follows:</p>
<ol>
<li>Astroport Liquidity withdrawer <code>withdraw_liquidity</code> call to trigger the liquidity withdrawal which will deposit the underlying tokens into the Withdraw account.
Note that this action may be subject to a lockup period!</li>
<li>Astroport Swapper <code>swap</code> call to swap the counterparty denom obtained from withdrawing the position into USDC</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-your-programs"><a class="header" href="#testing-your-programs">Testing your programs</a></h1>
<p>Our testing infrastructure is built on several tools that work together to provide a comprehensive local testing environment:</p>
<h3 id="core-testing-framework"><a class="header" href="#core-testing-framework">Core Testing Framework</a></h3>
<p>We use <a href="https://github.com/strangelove-ventures/interchaintest/tree/main/local-interchain">local-interchain</a>, a component of the <a href="https://github.com/strangelove-ventures/interchaintest">interchaintest</a> developer toolkit. This allows you to deploy and run chains in a local environment, providing a controlled testing space for your blockchain applications.</p>
<h3 id="localic-utils"><a class="header" href="#localic-utils">Localic Utils</a></h3>
<p>To make these tools more accessible in Rust, we've developed <a href="https://github.com/timewave-computer/localic-utils">localic-utils</a>. This Rust library provides convenient interfaces to interact with the local-interchain testing framework.</p>
<h3 id="program-manager-1"><a class="header" href="#program-manager-1">Program Manager</a></h3>
<p>We provide a tool called <code>Program Manager</code> that helps you manage your programs. We've created all the abstractions and helper functions to create your programs more efficiently together with local-interchain.</p>
<p>The Program Manager use is optional, it abstracts a lot of functionality and allows creating programs in much less code. But if you want to have more fine-grained control over your programs, we provide helper functions to create and interact with your programs directly without it. In this section, we'll show you two different examples on how to test your programs, one using the Program Manager and the other without it. There are also many more examples each of them for different use cases. They are all in the <code>examples</code> folder of <a href="https://github.com/timewave-computer/valence-protocol/tree/main/e2e">our e2e folder</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="initial-testing-set-up"><a class="header" href="#initial-testing-set-up">Initial Testing Set Up</a></h1>
<p>For testing your programs, no matter if you want to use the manager or not, there is a common set up that needs to be done. This set up is necessary to initialize the testing context with all the required information of the local-interchain environment.</p>
<h2 id="1-setting-the-testcontext-using-the-testcontextbuilder"><a class="header" href="#1-setting-the-testcontext-using-the-testcontextbuilder">1. Setting the TestContext using the TestContextBuilder</a></h2>
<p>The <code>TestContext</code> is the interchain environment in which your program will run. Let's say you want to configure the Neutron chain and Osmosis chain, you may set it up as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let mut test_ctx = TestContextBuilder::default()
        .with_unwrap_raw_logs(true)
        .with_api_url(LOCAL_IC_API_URL)
        .with_artifacts_dir(VALENCE_ARTIFACTS_PATH)
        .with_chain(ConfigChainBuilder::default_neutron().build()?)
        .with_chain(ConfigChainBuilder::default_osmosis().build()?)
        .with_log_file_path(LOGS_FILE_PATH)
        .with_transfer_channels(NEUTRON_CHAIN_NAME, OSMOSIS_CHAIN_NAME)
        .build()?;
<span class="boring">}</span></code></pre></pre>
<p>This will instantiate a <code>TestContext</code> with two chains, Neutron and Osmosis, that are connected via IBC by providing the <code>transfer_channels</code> parameter. The <code>api_url</code> is the URL of the local-interchain API, and the <code>artifacts_dir</code> is the path where the compiled programs are stored. The <code>log_file_path</code> is the path where the logs will be stored. The most important part here are the chains, which are created using the <code>ConfigChainBuilder</code> with the default configurations for Neutron and Osmosis and the transfer channels between them. We provide builders for most chains but you can also create your own configurations.</p>
<h2 id="2-custom-chain-specific-setup"><a class="header" href="#2-custom-chain-specific-setup">2. Custom chain-specific setup</a></h2>
<p>Some chains require additional setup to interact with others. For example, if you are going to use a liquid staking chain like Persistence, you need to register and activate the host zone to allow liquid staking of its native token. We provide helper functions that do this for you, here's an example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    info!("Registering host zone...");
    register_host_zone(
        test_ctx
            .get_request_builder()
            .get_request_builder(PERSISTENCE_CHAIN_NAME),
        NEUTRON_CHAIN_ID,
        &amp;connection_id,
        &amp;channel_id,
        &amp;native_denom,
        DEFAULT_KEY,
    )?;


    info!("Activating host zone...");
    activate_host_zone(NEUTRON_CHAIN_ID)?;
<span class="boring">}</span></code></pre></pre>
<p>Other examples of this would be deploying Astroport contracts, creating Osmosis pools... We provider helper functions for pretty much all of them and we have examples for all of them in the <code>examples</code> folder.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-without-program-manager"><a class="header" href="#example-without-program-manager">Example without Program Manager</a></h1>
<p>This example demonstrates how to test your program without the Program Manager after your initial testing set up has been completed as described in the <a href="testing/./setup.html">Initial Testing Set Up</a> section.</p>
<blockquote>
<p><strong>Use-case</strong>: In this particular example, we will show you how to create a program that liquid stakes NTRN tokens on a Persistence chain directly from a base account without the need of using libraries. Note that this example is just for demonstrating purposes. In a real-world scenario, you would not liquid stake NTRN as it is not a staking token. We also are not using a liquid staking library for this example, although one could be creating for this purpose.</p>
</blockquote>
<p>The full code for this example can be found in the <a href="https://github.com/timewave-computer/valence-protocol/blob/main/e2e/examples/persistence_ls.rs">Persistence Liquid Staking example</a>.</p>
<ol>
<li>Set up the Authorization contract and processor on the <code>Main Domain</code> (Neutron).</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let now = SystemTime::now();
    let salt = hex::encode(
        now.duration_since(SystemTime::UNIX_EPOCH)?
            .as_secs()
            .to_string(),
    );

    let (authorization_contract_address, _) =
        set_up_authorization_and_processor(&amp;mut test_ctx, salt.clone())?;
<span class="boring">}</span></code></pre></pre>
<p>This code sets up the Authorization contract and processor on Neutron. We use a time based salt to ensure that each test run the generated contract addresses are different. The <code>set_up_authorization_and_processor</code> function is a helper function instantiates both the Processor and Authorization contracts on Neutron and provides the contract addresses to interact with both. As you can see, we are not using the Processor on Neutron here, but we are still setting it up.</p>
<ol start="2">
<li>Set up an external domain and create a channel to start relaying messages.</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let processor_on_persistence = set_up_external_domain_with_polytone(
        &amp;mut test_ctx,
        PERSISTENCE_CHAIN_NAME,
        PERSISTENCE_CHAIN_ID,
        PERSISTENCE_CHAIN_ADMIN_ADDR,
        LOCAL_CODE_ID_CACHE_PATH_PERSISTENCE,
        "neutron-persistence",
        salt,
        &amp;authorization_contract_address,
    )?;
<span class="boring">}</span></code></pre></pre>
<p>This function does the following:</p>
<ul>
<li>Instantiates all the Polytone contracts on both the main domain and the new external domain. The information of the external domain is provided in the function arguments.</li>
<li>Creates a channel between the Polytone contracts that the relayer will use to relay messages between the Authorization contract and the processor.</li>
<li>Instantiates the Processor contract on the external domain with the correct Polytone information and the Authorization contract address.</li>
<li>Adds the external domain to Authorization contract with the Polytone information and the processor address on the external domain.</li>
</ul>
<p>After this is done, we can start creating authorizations for that external domain and when we send messages to the Authorization contract, the relayer will relay the messages to the processor on the external domain and return the callbacks.</p>
<ol start="3">
<li>Create one or more base accounts on a domain.</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let base_accounts = create_base_accounts(
        &amp;mut test_ctx,
        DEFAULT_KEY,
        PERSISTENCE_CHAIN_NAME,
        base_account_code_id,
        PERSISTENCE_CHAIN_ADMIN_ADDR.to_string(),
        vec![processor_on_persistence.clone()],
        1,
        None,
    );
    let persistence_base_account = base_accounts.first().unwrap();
<span class="boring">}</span></code></pre></pre>
<p>This function creates a base account on the external domain and grants permission to the processor address to execute messages on its behalf. If we were using a library instead, we would be granting permission to the library contract instead of the processor address in the array provided.</p>
<ol start="4">
<li>Create the authorization</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let authorizations = vec![AuthorizationBuilder::new()
        .with_label("execute")
        .with_subroutine(
            AtomicSubroutineBuilder::new()
                .with_function(
                    AtomicFunctionBuilder::new()
                        .with_domain(Domain::External(PERSISTENCE_CHAIN_NAME.to_string()))
                        .with_contract_address(LibraryAccountType::Addr(
                            persistence_base_account.clone(),
                        ))
                        .with_message_details(MessageDetails {
                            message_type: MessageType::CosmwasmExecuteMsg,
                            message: Message {
                                name: "execute_msg".to_string(),
                                params_restrictions: None,
                            },
                        })
                        .build(),
                )
                .build(),
        )
        .build()];

    info!("Creating execute authorization...");
    let create_authorization = valence_authorization_utils::msg::ExecuteMsg::PermissionedAction(
        valence_authorization_utils::msg::PermissionedMsg::CreateAuthorizations { authorizations },
    );

    contract_execute(
        test_ctx
            .get_request_builder()
            .get_request_builder(NEUTRON_CHAIN_NAME),
        &amp;authorization_contract_address,
        DEFAULT_KEY,
        &amp;serde_json::to_string(&amp;create_authorization).unwrap(),
        GAS_FLAGS,
    )
    .unwrap();
    std::thread::sleep(std::time::Duration::from_secs(3));
    info!("Execute authorization created!");
<span class="boring">}</span></code></pre></pre>
<p>In this code snippet, we are creating an authorization to execute a message on the persistence base account. For this particular example, since we are going to execute a <code>CosmosMsg::Stargate</code> directly on the account passing the protobuf message, we are not going to set up any param restrictions. If we were using a library, we could potentially set up restrictions for the json message that the library would expect.</p>
<ol start="5">
<li>Send message to the Authorization contract</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>info!("Send the messages to the authorization contract...");

    let msg_liquid_stake = MsgLiquidStake {
        amount: Some(Coin {
            denom: neutron_on_persistence.clone(),
            amount: amount_to_liquid_stake.to_string(),
        }),
        delegator_address: persistence_base_account.clone(),
    };
    #[allow(deprecated)]
    let liquid_staking_message = CosmosMsg::Stargate {
        type_url: msg_liquid_stake.to_any().type_url,
        value: Binary::from(msg_liquid_stake.to_proto_bytes()),
    };

    let binary = Binary::from(
        serde_json::to_vec(&amp;valence_account_utils::msg::ExecuteMsg::ExecuteMsg {
            msgs: vec![liquid_staking_message],
        })
        .unwrap(),
    );
    let message = ProcessorMessage::CosmwasmExecuteMsg { msg: binary };
    let send_msg = valence_authorization_utils::msg::ExecuteMsg::PermissionlessAction(
        valence_authorization_utils::msg::PermissionlessMsg::SendMsgs {
            label: "execute".to_string(),
            messages: vec![message],
            ttl: None,
        },
    );

    contract_execute(
        test_ctx
            .get_request_builder()
            .get_request_builder(NEUTRON_CHAIN_NAME),
        &amp;authorization_contract_address,
        DEFAULT_KEY,
        &amp;serde_json::to_string(&amp;send_msg).unwrap(),
        GAS_FLAGS,
    )
    .unwrap();
    std::thread::sleep(std::time::Duration::from_secs(3));
<span class="boring">}</span></code></pre></pre>
<p>In this code snippet, we are sending a message to the Authorization contract to execute the liquid staking message on the base account on Persistence. Note that we are using the same label that we used in the authorization creation. This is important because the Authorization contract will check if the label matches the one in the authorization. If it does not match, the execution will fail. The Authorization contract will send the message to the corresponding Polytone contract that will send it via IBC to the processor on the external domain.</p>
<ol start="6">
<li>Tick the processor</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    tick_processor(
        &amp;mut test_ctx,
        PERSISTENCE_CHAIN_NAME,
        DEFAULT_KEY,
        &amp;processor_on_persistence,
    );
    std::thread::sleep(std::time::Duration::from_secs(3));
<span class="boring">}</span></code></pre></pre>
<p>The message must now be sitting on the processor on Persistence, therefore we need to tick the processor to trigger the execution. This will execute the message and send a callback with the result to the Authorization contract, which completes the full testing cycle.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example-with-program-manager"><a class="header" href="#example-with-program-manager">Example with Program Manager</a></h1>
<p>This example demonstrates how to test your program using the Program Manager after your initial testing set up has been completed as described in the <a href="testing/./setup.html">Initial Testing Set Up</a> section.</p>
<blockquote>
<p><strong>Use-case:</strong> This example outlines the steps needed to create a program that provides and withdraws liquidity from an Osmosis Concentrated Liquidity pool using two library contracts: a CL Liquidity Provider and a CL Liquidity Withdrawer.</p>
</blockquote>
<h2 id="prerequisites-2"><a class="header" href="#prerequisites-2">Prerequisites</a></h2>
<p>Before proceeding, ensure you have:</p>
<ul>
<li>A basic understanding of Osmosis, Neutron, CosmWasm, and Valence</li>
<li>Completed the initial testing setup as described in the setup section</li>
<li>Installed all necessary dependencies and have a working development environment</li>
</ul>
<h2 id="solution-overview"><a class="header" href="#solution-overview">Solution Overview</a></h2>
<p>Full working code for this example can be found in the <a href="https://github.com/timewave-computer/valence-protocol/blob/main/examples/osmo_cl/src">Osmosis Concentrated Liquidity example</a>.</p>
<p>Our solution includes the following:</p>
<ul>
<li>We create three accounts on Osmosis
<ul>
<li>CL Input holds tokens ready to join the pool</li>
<li>CL Output holds the position of the pool</li>
<li>Final Output holds tokens after they've been withdrawn from the pool</li>
</ul>
</li>
<li>We instantiate the Concentrated Liquidity Provider and Concentrated Liquidity Withdrawer libraries on Osmosis
<ul>
<li>The Liquidity Provider library will draw tokens from the CL Input account and use them to enter the pool</li>
<li>The Liquidity Withdrawer library will exit the pool from the position held in the CL Output account and deposit redeemed tokens to the Final Output account</li>
</ul>
</li>
<li>We add two permissionless authorizations on Neutron:
<ul>
<li>Provide Liquidity: When executed, it'll call the provide liquidity function</li>
<li>Withdraw Liquidity: When executed, it'll call the withdraw liquidity function</li>
</ul>
</li>
</ul>
<p>The following is a visual representation of the system we are building:</p>
<pre class="mermaid">graph TD;
    subgraph Osmosis
        A1((CL Input))
        A2((CL Output))
        A3((Final Output))
        L1[Liquidity Provider]
        L2[Liquidity Withdrawer]
        EP[Processor]
    end

    subgraph Neutron
        A[Authorizations]
        MP[Processor]
    end

    A1 --&gt; L1 --&gt; A2
    A2 --&gt; L2 --&gt; A3

    User --Execute Msg--&gt; A --Enqueue Batch --&gt; EP
    EP --&gt; L1
    EP --&gt; L2
</pre>
<h2 id="code-walkthrough"><a class="header" href="#code-walkthrough">Code walkthrough</a></h2>
<p>Before we begin, we set up the <code>TestContext</code> as explained in the previous <a href="testing/setup.html">setup section</a>. Then we can move on to steps pertinent to testing this example.</p>
<h3 id="1-setting-up-the-program"><a class="header" href="#1-setting-up-the-program">1. Setting up the program</a></h3>
<h4 id="11-set-up-the-concentrated-liquidity-pool-on-osmosis"><a class="header" href="#11-set-up-the-concentrated-liquidity-pool-on-osmosis">1.1 Set up the Concentrated Liquidity pool on Osmosis</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ntrn_on_osmo_denom = test_ctx
    .get_ibc_denom()
    .base_denom(NEUTRON_CHAIN_DENOM.to_owned())
    .src(NEUTRON_CHAIN_NAME)
    .dest(OSMOSIS_CHAIN_NAME)
    .get();

let pool_id = setup_cl_pool(&amp;mut test_ctx, &amp;ntrn_on_osmo_denom, OSMOSIS_CHAIN_DENOM)?;
<span class="boring">}</span></code></pre></pre>
<p>This sets up a CL pool on Osmosis using NTRN and OSMO as the trading pair.
Because NTRN on Osmosis will be transferred over IBC, a helper function is used to get the correct denom on Osmosis.</p>
<h4 id="12-set-up-the-program-config-builder-and-prepare-the-relevant-accounts"><a class="header" href="#12-set-up-the-program-config-builder-and-prepare-the-relevant-accounts">1.2 Set up the Program config builder and prepare the relevant accounts</a></h4>
<p>The Program Manager uses a builder pattern to construct the program configuration. We set up the three accounts that will be used in the liquidity provision and withdrawal flow.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut builder = ProgramConfigBuilder::new(NEUTRON_CHAIN_ADMIN_ADDR.to_string());
let osmo_domain = Domain::CosmosCosmwasm(OSMOSIS_CHAIN_NAME.to_string());
let ntrn_domain = Domain::CosmosCosmwasm(NEUTRON_CHAIN_NAME.to_string());

// Create account information for LP input, LP output and final (LW) output accounts
let cl_input_acc_info = AccountInfo::new("cl_input".to_string(), &amp;osmo_domain, AccountType::default());
let cl_output_acc_info = AccountInfo::new("cl_output".to_string(), &amp;osmo_domain, AccountType::default());
let final_output_acc_info = AccountInfo::new("final_output".to_string(), &amp;osmo_domain, AccountType::default());

// Add accounts to builder
let cl_input_acc = builder.add_account(cl_input_acc_info);
let cl_output_acc = builder.add_account(cl_output_acc_info);
let final_output_acc = builder.add_account(final_output_acc_info);
<span class="boring">}</span></code></pre></pre>
<h4 id="13-configure-the-libraries"><a class="header" href="#13-configure-the-libraries">1.3 Configure the libraries</a></h4>
<p>Next we configure the libraries for providing and withdrawing liquidity. Each library is configured with input and output accounts and specific parameters for their operation.</p>
<p>Note how <code>cl_output_acc</code> serves a different purpose for each of those libraries:</p>
<ul>
<li>for liquidity provider library it is the output account</li>
<li>for liquidity withdrawer library it is the input account</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Configure Liquidity Provider library
let cl_lper_config = LibraryConfig::ValenceOsmosisClLper({
    input_addr: cl_input_acc.clone(),
    output_addr: cl_output_acc.clone(),
    lp_config: LiquidityProviderConfig {
        pool_id: pool_id.into(),
        pool_asset_1: ntrn_on_osmo_denom.to_string(),
        pool_asset_2: OSMOSIS_CHAIN_DENOM.to_string(),
        global_tick_range: TickRange {
            lower_tick: Int64::from(-1_000_000),
            upper_tick: Int64::from(1_000_000),
        },
    },
});

// Configure Liquidity Withdrawer library
let cl_lwer_config = LibraryConfig::ValenceOsmosisClWithdrawer({
    input_addr: cl_output_acc.clone(),
    output_addr: final_output_acc.clone(),
    pool_id: pool_id.into(),
});

// Add libraries to builder
let cl_lper_library = builder.add_library(LibraryInfo::new(
    "test_cl_lper".to_string(),
    &amp;osmo_domain,
    cl_lper_config,
));

let cl_lwer_library = builder.add_library(LibraryInfo::new(
    "test_cl_lwer".to_string(),
    &amp;osmo_domain,
    cl_lwer_config,
));
<span class="boring">}</span></code></pre></pre>
<h4 id="14-create-links-between-accounts-and-libraries"><a class="header" href="#14-create-links-between-accounts-and-libraries">1.4 Create links between accounts and libraries</a></h4>
<p>Input links (first array in the <code>add_link()</code> call) are meant to enable libraries permission to execute on the specified accounts. Output links specify where the fungible results of a given function execution should be routed to.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Link input account -&gt; liquidity provider -&gt; output account
builder.add_link(&amp;cl_lper_library, vec![&amp;cl_input_acc], vec![&amp;cl_output_acc]);
// Link output account -&gt; liquidity withdrawer -&gt; final output account
builder.add_link(&amp;cl_lwer_library, vec![&amp;cl_output_acc], vec![&amp;final_output_acc]);
<span class="boring">}</span></code></pre></pre>
<h4 id="15-create-authorizations"><a class="header" href="#15-create-authorizations">1.5 Create authorizations</a></h4>
<p>Next we create authorizations for both providing and withdrawing liquidity. Each authorization contains a subroutine that specifies which function to call on which library. By default, calling these subroutines will be permissionless, however using the <code>AuthorizationBuilder</code> we can constrain the authorizations as necessary.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>builder.add_authorization(
    AuthorizationBuilder::new()
        .with_label("provide_liquidity")
        .with_subroutine(
            AtomicSubroutineBuilder::new()
                .with_function(cl_lper_function)
                .build(),
        )
        .build(),
);

builder.add_authorization(
    AuthorizationBuilder::new()
        .with_label("withdraw_liquidity")
        .with_subroutine(
            AtomicSubroutineBuilder::new()
                .with_function(cl_lwer_function)
                .build(),
        )
        .build(),
);
<span class="boring">}</span></code></pre></pre>
<h4 id="16-set-up-the-polytone-connections"><a class="header" href="#16-set-up-the-polytone-connections">1.6 Set up the Polytone connections</a></h4>
<p>In order for cross-domain Programs to be able to communicate between
different domains, we instantiate the Polytone contracts and save the
configuration in our Program Manager.</p>
<p><code>setup_polytone</code> sets up the connection between two domains and therefore expects the following parameters:</p>
<ul>
<li>source and destination chain names</li>
<li>source and destination chain ids</li>
<li>source and destination chain native denoms</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// prior to initializing the manager, we do the middleware plumbing
setup_polytone(
    &amp;mut test_ctx,
    NEUTRON_CHAIN_NAME,
    OSMOSIS_CHAIN_NAME,
    NEUTRON_CHAIN_ID,
    OSMOSIS_CHAIN_ID,
    NEUTRON_CHAIN_DENOM,
    OSMOSIS_CHAIN_DENOM,
)?;
<span class="boring">}</span></code></pre></pre>
<h4 id="17-initialize-the-program"><a class="header" href="#17-initialize-the-program">1.7 Initialize the program</a></h4>
<p>Calling <code>builder.build()</code> here acts as a snapshot of the existing builder state.</p>
<p>That state is then passed on to the <code>use_manager_init()</code> call, which consumes it and builds the final program configuration before initializing it.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut program_config = builder.build();
use_manager_init(&amp;mut program_config)?;
<span class="boring">}</span></code></pre></pre>
<p>Congratulations! The program is now initialized across the two chains!</p>
<h3 id="2-executing-the-program"><a class="header" href="#2-executing-the-program">2. Executing the Program</a></h3>
<p>After the initialization, we are ready to start processing  messages. For a message to be executed, it first needs to be enqueued to the processor.</p>
<h4 id="21-providing-liquidity"><a class="header" href="#21-providing-liquidity">2.1 Providing Liquidity</a></h4>
<p>If there are tokens available in the CL Input account, we are ready to provide liquidity. To enqueue provide liquidity message:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// build the processor message for providing liquidity
let lp_message = ProcessorMessage::CosmwasmExecuteMsg {
    msg: Binary::from(serde_json::to_vec(
        &amp;valence_library_utils::msg::ExecuteMsg::&lt;_, ()&gt;::ProcessFunction(
            valence_osmosis_cl_lper::msg::FunctionMsgs::ProvideLiquidityDefault {
                bucket_amount: Uint64::new(10),
            },
        ),
    )?),
};

// wrap the processor message in an authorization module call
let provide_liquidity_msg = valence_authorization_utils::msg::ExecuteMsg::PermissionlessAction(
    valence_authorization_utils::msg::PermissionlessMsg::SendMsgs {
        label: "provide_liquidity".to_string(),
        messages: vec![lp_message],
        ttl: None,
    },
);

contract_execute(
    test_ctx
        .get_request_builder()
        .get_request_builder(NEUTRON_CHAIN_NAME),
    &amp;authorization_contract_address,
    DEFAULT_KEY,
    &amp;serde_json::to_string(&amp;provide_liquidity_msg)?,
    GAS_FLAGS,
)?;
<span class="boring">}</span></code></pre></pre>
<p>Now anyone can tick the processor to execute the message. After receiving a <code>tick</code>, the processor will execute the message at the head of the queue and send a callback to the Authorization contract with the result.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>contract_execute(
    test_ctx
        .get_request_builder()
        .get_request_builder(OSMOSIS_CHAIN_NAME),
    &amp;osmo_processor_contract_address,
    DEFAULT_KEY,
    &amp;serde_json::to_string(
        &amp;valence_processor_utils::msg::ExecuteMsg::PermissionlessAction(
            valence_processor_utils::msg::PermissionlessMsg::Tick {},
        ),
    )?,
    &amp;format!(
        "--gas=auto --gas-adjustment=3.0 --fees {}{}",
        5_000_000, OSMOSIS_CHAIN_DENOM
    ),
)?;
<span class="boring">}</span></code></pre></pre>
<h4 id="22-withdraw-liquidity"><a class="header" href="#22-withdraw-liquidity">2.2 Withdraw Liquidity</a></h4>
<p>To enqueue withdraw liquidity message:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// build the processor message for withdrawing liquidity
let lw_message = ProcessorMessage::CosmwasmExecuteMsg {
    msg: Binary::from(serde_json::to_vec(
        &amp;valence_library_utils::msg::ExecuteMsg::&lt;_, ()&gt;::ProcessFunction(
            valence_osmosis_cl_withdrawer::msg::FunctionMsgs::WithdrawLiquidity {
                position_id: output_acc_cl_position.position_id.into(),
                liquidity_amount: Some(liquidity_amount),
            },
        ),
    )?),
};

// wrap the processor message in an authorization module call
let withdraw_liquidity_msg = valence_authorization_utils::msg::ExecuteMsg::PermissionlessAction(
    valence_authorization_utils::msg::PermissionlessMsg::SendMsgs {
        label: "withdraw_liquidity".to_string(),
        messages: vec![lw_message],
        ttl: None,
    },
);

contract_execute(
    test_ctx
        .get_request_builder()
        .get_request_builder(NEUTRON_CHAIN_NAME),
    &amp;authorization_contract_address,
    DEFAULT_KEY,
    &amp;serde_json::to_string(&amp;withdraw_liquidity_msg)?,
    GAS_FLAGS,
)?;
<span class="boring">}</span></code></pre></pre>
<p>The above enqueues the message to withdraw liquidity. The processor will execute it next time it is ticked.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>contract_execute(
    test_ctx
        .get_request_builder()
        .get_request_builder(OSMOSIS_CHAIN_NAME),
    &amp;osmo_processor_contract_address,
    DEFAULT_KEY,
    &amp;serde_json::to_string(
        &amp;valence_processor_utils::msg::ExecuteMsg::PermissionlessAction(
            valence_processor_utils::msg::PermissionlessMsg::Tick {},
        ),
    )?,
    &amp;format!(
        "--gas=auto --gas-adjustment=3.0 --fees {}{}",
        5_000_000, OSMOSIS_CHAIN_DENOM
    ),
)?;
<span class="boring">}</span></code></pre></pre>
<p>This concludes the walkthrough. You have now initialized the program and used it to provide and withdraw liquidity on Osmosis from Neutron!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="security"><a class="header" href="#security">Security</a></h1>
<p>Valence Programs have been independently audited. Please find audit reports <a href="https://github.com/timewave-computer/valence-protocol/tree/main/audits/">here</a>.</p>
<p>If you believe you've found a security-related issue with Valence Programs, please disclose responsibly by contacting the Timewave team at <a href="mailto:security@timewave.computer">security@timewave.computer</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deployment"><a class="header" href="#deployment">Deployment</a></h1>
<p>This section contains a detailed explanation of how to deploy programs on different environments.</p>
<p><strong>Environments</strong></p>
<ul>
<li><a href="deployment/./local.html">Local</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="local-interchain-deployment"><a class="header" href="#local-interchain-deployment">Local interchain deployment</a></h1>
<p>In order to test a program locally, we use the local interchaintest suite to spin up chains.</p>
<h2 id="1-installing-local-interchain"><a class="header" href="#1-installing-local-interchain">1. Installing local-interchain</a></h2>
<p>Before you can run the tests, you need to install local interchain. This is a one-time operation. NOTE: your binary will link back to the location where you install, if you remove the folder, you need to run <code>make install</code> again.</p>
<pre><code class="language-bash">git clone https://github.com/strangelove-ventures/interchaintest &amp;&amp; cd interchaintest/local-interchain &amp;&amp; make install
</code></pre>
<h2 id="2-running-chains-locally"><a class="header" href="#2-running-chains-locally">2. Running chains locally</a></h2>
<p>Run one of the set-up configs we have in the <code>e2e/chains</code> folder. For example, to run the <code>neutron.json</code> config, run the following command from the <code>e2e</code> folder:</p>
<pre><code class="language-bash">cd e2e
local-ic start neutron --api-port 42069
</code></pre>
<p>This will start a local environment with a Gaia chain and a Neutron (using ICS) chain. The <code>--api-port</code> will expose the API on port 42069, we are using this port in our local-ic-utils crate so let's use the same to reuse some of the utils there.</p>
<p>This process also writes the API endpoints of each chain to <code>e2e/chains/configs/logs.json</code>. The setup script will use this file to determine which RPCs to use.</p>
<h2 id="3-optimize-contracts"><a class="header" href="#3-optimize-contracts">3. Optimize Contracts</a></h2>
<p>From the root directory, use CosmWasm optimizer to optimize contracts. The output will be written to an <code>artifacts</code> folder in the project root.</p>
<pre><code class="language-bash">just optimize
</code></pre>
<p>Or</p>
<pre><code class="language-bash">./devtools/optimize.sh
</code></pre>
<h2 id="4-generate-manager-config"><a class="header" href="#4-generate-manager-config">4. Generate manager config</a></h2>
<p>Before deploying a program, some initial setup is required. The below script will deploy all required contracts to the chain, instantiate a registry contract, and set up polytone bridges.</p>
<pre><code class="language-bash">cargo run -p generate_local_ic_config
</code></pre>
<p>The script will write all related code IDs, addresses, and RPC endpoints at  <code>deployment/configs/local/config.toml</code>, to be used by the program manager.</p>
<p>The default chain config that is used in this script is the <code>neutron.json</code> config, if in step 2 you started local-ic with a different chain config, please use the same config here.</p>
<p>Example with <code>neutron_juno.json</code> chain config:</p>
<pre><code class="language-bash">cargo run -p generate_local_ic_config -- -c neutron_juno.json
</code></pre>
<h2 id="5-build-program-config"><a class="header" href="#5-build-program-config">5. Build program config</a></h2>
<p>Before deploying a program, we need to build the program config.</p>
<p>This script will take the program you build using the Program Builder in <code>my_program.rs</code> and output the program config in a JSON format in <code>output_program/program.json</code>.</p>
<pre><code class="language-bash">cargo run -p build_program
</code></pre>
<ul>
<li>This script is a helper to generate a program config in JSON format using our program builder in rust, a program config in JSON format can be generated in any other method.</li>
</ul>
<h2 id="6-deploy-a-program"><a class="header" href="#6-deploy-a-program">6. Deploy a program</a></h2>
<p>To deploy a program, you can use the <code>deploy_program</code> script.</p>
<p>To run this script you need a manager config and a program config:</p>
<ul>
<li>Manager config is generated by <code>generate_local_ic_config</code> script for local environment at <code>deployment/configs/local/config.toml</code></li>
<li>Program config can be generated using the <code>build_program</code> script or any other method at <code>deployment/output_program/program.json</code></li>
</ul>
<pre><code class="language-bash">cargo run -p deploy_program
</code></pre>
<p>By default it will look for the program config generated by the <code>build_program</code> script in <code>deployment/output_program/program.json</code>. You can pass a different path to the config with:</p>
<pre><code class="language-bash">cargo run -p deploy_program -- -p path/to/program_config.json
</code></pre>
<h2 id="7-program-instantiated"><a class="header" href="#7-program-instantiated">7. Program Instantiated</a></h2>
<p>After a program was instantiated successfully, you will see a success message in the console and the program config file path that was generated.</p>
<p>The name of the file will end with the program id, for example: <code>program_1.json</code>.</p>
<p>You will be able to find this file under the <code>deployment/results</code> folder.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
