<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Type Registry - Valence Protocol Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "ayu";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Valence Protocol Documentation</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/timewave-computer/valence-protocol" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="middleware-type-registry"><a class="header" href="#middleware-type-registry">Middleware Type Registry</a></h1>
<p>Middleware type registries are static components that define how primitives
external to the Valence Protocol are adapted to be used within Valence programs.</p>
<p>While type registries can be used independently, they are typically meant to be
registered into and used via <a href="./broker.html"><em>brokers</em></a> to ensure versioning is
kept up to date.</p>
<h2 id="type-registry-lifecycle"><a class="header" href="#type-registry-lifecycle">Type Registry lifecycle</a></h2>
<p>Type Registries are static contracts that define their primitives during compile time.</p>
<p>Once a registry is deployed, it is expected to remain unchanged.
If a type change is needed, a new registry should be compiled, deployed,
and registered into the broker to offer the missing or updated functionality.</p>
<h2 id="api"><a class="header" href="#api">API</a></h2>
<p>All type registry instances must implement the same interface defined in middleware-utils.</p>
<p>Type registries function in a read-only manner - all of their functionality is exposed
with the <code>RegistryQueryMsg</code>. Currently, the following primitive conversions are enabled:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum RegistryQueryMsg {
    /// serialize a message to binary
    #[returns(NativeTypeWrapper)]
    FromCanonical { obj: ValenceType },
    /// deserialize a message from binary/bytes
    #[returns(Binary)]
    ToCanonical { type_url: String, binary: Binary },

    /// get the kvkey used for registering an interchain query
    #[returns(KVKey)]
    KVKey {
        type_id: String,
        params: BTreeMap&lt;String, Binary&gt;,
    },

    #[returns(NativeTypeWrapper)]
    ReconstructProto {
        type_id: String,
        icq_result: InterchainQueryResult,
    },
}
<span class="boring">}</span></code></pre></pre>
<p><code>RegistryQueryMsg</code> can be seen as the <em>superset</em> of all primitives that Valence Programs
can expect. No particular type being integrated into the system is required to implement
all available functionality, although that is possible.</p>
<p>To maintain a unified interface across all type registries, they have to adhere to the same
API as all other type registries. This means that if a particular type is enabled in a type
registry and only provides the means to perform native &lt;-&gt; canonical conversion, attempting
to call <code>ReconstructProto</code> on that type will return an error stating that reconstructing
protobuf for this type is not enabled.</p>
<h2 id="module-organization"><a class="header" href="#module-organization">Module organization</a></h2>
<p>Primitives defined in type registries should be outlined in a domain-driven manner.
Types, encodings, and any other functionality should be grouped by their domain and
are expected to be self-contained, not leaking into other primitives.</p>
<p>For instance, an osmosis type registry is expected to contain all registry instances related to
the Osmosis domain. Different registry instances should be versioned by <code>semver</code>, following that
of the external domain of which the primitives are being integrated.</p>
<h2 id="enabled-primitives"><a class="header" href="#enabled-primitives">Enabled primitives</a></h2>
<p>Currently, the following type registry primitives are enabled:</p>
<ul>
<li>Neutron Interchain Query types:
<ul>
<li>reconstructing native types from protobuf</li>
<li>obtaining the <code>KVKey</code> used to initiate the query for a given type</li>
</ul>
</li>
<li>Valence Canonical Types:
<ul>
<li>reconstructing native types from Valence Types</li>
<li>mapping native types into Valence Types</li>
</ul>
</li>
</ul>
<h2 id="example-integration"><a class="header" href="#example-integration">Example integration</a></h2>
<p>For an example, consider the integration of the osmosis gamm pool.</p>
<h3 id="neutron-interchain-query-integration"><a class="header" href="#neutron-interchain-query-integration">Neutron Interchain Query integration</a></h3>
<p>Neutron Interchain Query integration for a given type is achieved by implementing
the <code>IcqIntegration</code> trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait IcqIntegration {
    fn get_kv_key(params: BTreeMap&lt;String, Binary&gt;) -&gt; Result&lt;KVKey, MiddlewareError&gt;;
    fn decode_and_reconstruct(
        query_id: String,
        icq_result: InterchainQueryResult,
    ) -&gt; Result&lt;Binary, MiddlewareError&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h4 id="get_kv_key"><a class="header" href="#get_kv_key"><code>get_kv_key</code></a></h4>
<p>Implementing the <code>get_kv_key</code> will provide the means to obtain the <code>KVKey</code> needed
to register the interchain query. For osmosis gamm pool, the implementation may look
like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>impl IcqIntegration for OsmosisXykPool {
    fn get_kv_key(params: BTreeMap&lt;String, Binary&gt;) -&gt; Result&lt;KVKey, MiddlewareError&gt; {
        let pool_prefix_key: u8 = 0x02;

        let id: u64 = try_unpack_domain_specific_value("pool_id", &amp;params)?;

        let mut pool_access_key = vec![pool_prefix_key];
        pool_access_key.extend_from_slice(&amp;id.to_be_bytes());

        Ok(KVKey {
            path: STORAGE_PREFIX.to_string(),
            key: Binary::new(pool_access_key),
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="decode_and_reconstruct"><a class="header" href="#decode_and_reconstruct"><code>decode_and_reconstruct</code></a></h4>
<p>Other part of enabling interchain queries is the implementation of <code>decode_and_reconstruct</code>.
This method will be called upon ICQ relayer posting the query result back to the <code>interchainqueries</code>
module on Neutron. For osmosis gamm pool, the implementation may look
like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl IcqIntegration for OsmosisXykPool {
    fn decode_and_reconstruct(
        _query_id: String,
        icq_result: InterchainQueryResult,
    ) -&gt; Result&lt;Binary, MiddlewareError&gt; {
        let any_msg: Any = Any::decode(icq_result.kv_results[0].value.as_slice())
            .map_err(|e| MiddlewareError::DecodeError(e.to_string()))?;

        let osmo_pool: Pool = any_msg
            .try_into()
            .map_err(|_| StdError::generic_err("failed to parse into pool"))?;

        to_json_binary(&amp;osmo_pool)
            .map_err(StdError::from)
            .map_err(MiddlewareError::Std)
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="valence-type-integration"><a class="header" href="#valence-type-integration">Valence Type integration</a></h3>
<p>Valence Type integration for a given type is achieved by implementing
the <code>ValenceTypeAdapter</code> trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait ValenceTypeAdapter {
    type External;

    fn try_to_canonical(&amp;self) -&gt; Result&lt;ValenceType, MiddlewareError&gt;;
    fn try_from_canonical(canonical: ValenceType) -&gt; Result&lt;Self::External, MiddlewareError&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>Ideally, Valence Types should represent the minimal amount of information needed and
avoid any domain-specific logic or identifiers. In practice, this is a hard problem:
native types that are mapped into Valence types may need to be sent back to the remote
domains. For that reason, we cannot afford leaking any domain-specific fields and instead
store them in the Valence Type itself for later reconstruction.</p>
<p>In case of <code>ValenceXykPool</code>, this storage is kept in its <code>domain_specific_fields</code> field.
Any fields that are logically common across all possible integrations into this type
should be kept in their dedicated fields. In the case of constant product pools, such
fields are the assets in the pool, and the shares issued that represent those assets:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cw_serde]
pub struct ValenceXykPool {
    /// assets in the pool
    pub assets: Vec&lt;Coin&gt;,

    /// total amount of shares issued
    pub total_shares: String,

    /// any other fields that are unique to the external pool type
    /// being represented by this struct
    pub domain_specific_fields: BTreeMap&lt;String, Binary&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h4 id="try_to_canonical"><a class="header" href="#try_to_canonical"><code>try_to_canonical</code></a></h4>
<p>Implementing the <code>try_from_canonical</code> will provide the means of mapping a native remote type
into the canonical Valence Type to be used in Valence Protocol.
For osmosis gamm pool, the implementation may look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ValenceTypeAdapter for OsmosisXykPool {
    type External = Pool;

    fn try_to_canonical(&amp;self) -&gt; Result&lt;ValenceType, MiddlewareError&gt; {
        // pack all the domain-specific fields
        let mut domain_specific_fields = BTreeMap::from([
            (ADDRESS_KEY.to_string(), to_json_binary(&amp;self.0.address)?),
            (ID_KEY.to_string(), to_json_binary(&amp;self.0.id)?),
            (
                FUTURE_POOL_GOVERNOR_KEY.to_string(),
                to_json_binary(&amp;self.0.future_pool_governor)?,
            ),
            (
                TOTAL_WEIGHT_KEY.to_string(),
                to_json_binary(&amp;self.0.total_weight)?,
            ),
            (
                POOL_PARAMS_KEY.to_string(),
                to_json_binary(&amp;self.0.pool_params)?,
            ),
        ]);

        if let Some(shares) = &amp;self.0.total_shares {
            domain_specific_fields
                .insert(SHARES_DENOM_KEY.to_string(), to_json_binary(&amp;shares.denom)?);
        }

        for asset in &amp;self.0.pool_assets {
            if let Some(token) = &amp;asset.token {
                domain_specific_fields.insert(
                    format!("pool_asset_{}_weight", token.denom),
                    to_json_binary(&amp;asset.weight)?,
                );
            }
        }

        let mut assets = vec![];
        for asset in &amp;self.0.pool_assets {
            if let Some(t) = &amp;asset.token {
                assets.push(coin(u128::from_str(&amp;t.amount)?, t.denom.to_string()));
            }
        }

        let total_shares = self
            .0
            .total_shares
            .clone()
            .map(|shares| shares.amount)
            .unwrap_or_default();

        Ok(ValenceType::XykPool(ValenceXykPool {
            assets,
            total_shares,
            domain_specific_fields,
        }))
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="try_from_canonical"><a class="header" href="#try_from_canonical"><code>try_from_canonical</code></a></h4>
<p>Other part of enabling Valence Type integration is the implementation of <code>try_from_canonical</code>.
This method will be called when converting from canonical back to the native version of the types.
For osmosis gamm pool, the implementation may look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ValenceTypeAdapter for OsmosisXykPool {
    type External = Pool;

    fn try_from_canonical(canonical: ValenceType) -&gt; Result&lt;Self::External, MiddlewareError&gt; {
        let inner = match canonical {
            ValenceType::XykPool(pool) =&gt; pool,
            _ =&gt; {
                return Err(MiddlewareError::CanonicalConversionError(
                    "canonical inner type mismatch".to_string(),
                ))
            }
        };
        // unpack domain specific fields from inner type
        let address: String = inner.get_domain_specific_field(ADDRESS_KEY)?;
        let id: u64 = inner.get_domain_specific_field(ID_KEY)?;
        let future_pool_governor: String =
            inner.get_domain_specific_field(FUTURE_POOL_GOVERNOR_KEY)?;
        let pool_params: Option&lt;PoolParams&gt; = inner.get_domain_specific_field(POOL_PARAMS_KEY)?;
        let shares_denom: String = inner.get_domain_specific_field(SHARES_DENOM_KEY)?;
        let total_weight: String = inner.get_domain_specific_field(TOTAL_WEIGHT_KEY)?;

        // unpack the pool assets
        let mut pool_assets = vec![];
        for asset in &amp;inner.assets {
            let pool_asset = PoolAsset {
                token: Some(Coin {
                    denom: asset.denom.to_string(),
                    amount: asset.amount.into(),
                }),
                weight: inner
                    .get_domain_specific_field(&amp;format!("pool_asset_{}_weight", asset.denom))?,
            };
            pool_assets.push(pool_asset);
        }

        Ok(Pool {
            address,
            id,
            pool_params,
            future_pool_governor,
            total_shares: Some(Coin {
                denom: shares_denom,
                amount: inner.total_shares,
            }),
            pool_assets,
            total_weight,
        })
    }
}
<span class="boring">}</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../middleware/broker.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../middleware/valence_types.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../middleware/broker.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../middleware/valence_types.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>


    </div>
    </body>
</html>
