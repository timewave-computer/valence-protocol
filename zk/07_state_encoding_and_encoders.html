<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>State Encoding and Encoders - Valence Protocol Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "ayu";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Valence Protocol Documentation</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/timewave-computer/valence-protocol" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="state-encoding-and-encoders"><a class="header" href="#state-encoding-and-encoders">State Encoding and Encoders</a></h1>
<p>This document explains how the Valence ZK Coprocessor handles state encoding for zero-knowledge proofs and cross-chain state synchronization. Understanding these concepts is essential for building applications that work across multiple blockchains.</p>
<blockquote>
<p><strong>Implementation Status:</strong> The state encoding mechanisms described in this document represent the design goals and architecture for the Valence ZK Coprocessor. While the core coprocessor infrastructure exists (as shown in the <a href="https://github.com/timewave-computer/valence-coprocessor-app">valence-coprocessor-app template</a>), the full state encoding and cross-chain coordination features are still in active development.</p>
</blockquote>
<h2 id="the-state-encoding-challenge"><a class="header" href="#the-state-encoding-challenge">The State Encoding Challenge</a></h2>
<p>The core challenge in ZK coprocessor design lies in encoding state. ZK applications are pure functions that must utilize existing state as arguments to produce an evaluated output state. This means we need a way to compress blockchain state into a format suitable for zero-knowledge proofs.</p>
<p>For any state transition, we can describe it as a pure function: <code>f(A) = B</code>, where <code>A</code> is the initial state and <code>B</code> is the resulting state after applying function <code>f</code>.</p>
<h2 id="pure-functions-in-zkvms"><a class="header" href="#pure-functions-in-zkvms">Pure Functions in zkVMs</a></h2>
<p>The Valence ZK Coprocessor leverages zero-knowledge virtual machines (zkVMs) to execute Rust programs and generate proofs of their execution. Specifically, Valence uses a RISC-V zkVM, currently Succinct's SP1. For state encoding purposes, these applications must be structured as pure functions <code>f(x) = y</code>.</p>
<p>The zkVM workflow for state transitions follows the following pattern:</p>
<ol>
<li><strong>Application definition</strong>: The state transition logic is written in Rust as a pure function</li>
<li><strong>Key generation</strong>: The compiled application produces a proving key <code>pk</code> and verifying key <code>vk</code></li>
<li><strong>Proof generation</strong>: Given inputs <code>x</code>, the zkVM calls <code>prove(pk, x)</code> to generate proof <code>p</code></li>
<li><strong>Verification</strong>: The proof is verified by calling <code>verify(vk, x, y, p)</code></li>
</ol>
<p>This pure function constraint is what necessitates the state encoding mechanisms described in this document - we must compress mutable blockchain state into immutable inputs and outputs suitable for zero-knowledge proving.</p>
<h2 id="unary-encoder"><a class="header" href="#unary-encoder">Unary Encoder</a></h2>
<p>The Unary Encoder compresses account state transitions into zero-knowledge proofs. It handles the transformation from on-chain state mutations to ZK-provable computations.</p>
<h3 id="basic-state-transition-example"><a class="header" href="#basic-state-transition-example">Basic State Transition Example</a></h3>
<p>Consider an account with a key-value store that maps addresses to balances. A traditional on-chain transfer function might look like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn transfer(&amp;mut self, signature: Signature, from: Address, to: Address, value: u64) {
    assert!(signature.verify(&amp;from));
    assert!(value &gt; 0);
    
    let balance_from = self.get(&amp;from).unwrap();
    let balance_to = self.get(&amp;to).unwrap_or(0);
    
    self.insert(from, balance_from.checked_sub(value).unwrap());
    self.insert(to, balance_to.checked_add(value).unwrap());
}
<span class="boring">}</span></code></pre></pre>
<p>For ZK execution, we can create a trusted version that delegates signature verification to the ZK circuit:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn transfer_trusted(&amp;mut self, from: Address, to: Address, value: u64) {
    let balance_from = self.get(&amp;from).unwrap();
    let balance_to = self.get(&amp;to).unwrap_or(0);
    
    self.insert(from, balance_from - value);
    self.insert(to, balance_to + value);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="zk-application-structure"><a class="header" href="#zk-application-structure">ZK Application Structure</a></h3>
<p>In the current Valence Coprocessor template, ZK applications consist of two components: a controller and a circuit. The controller processes inputs and generates witnesses, while the circuit performs the ZK-provable computation.</p>
<p><strong>Controller (processes JSON inputs and generates witnesses):</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn get_witnesses(args: Value) -&gt; anyhow::Result&lt;Vec&lt;Witness&gt;&gt; {
    let (signature, from, to, value) = parse_transfer_args(args);
    
    // Verify signature off-chain and prepare witness data
    signature.verify(&amp;from)?;
    
    let witness_data = TransferWitness {
        from,
        to, 
        value,
        initial_state: get_current_state(),
    };
    
    Ok(vec![Witness::Data(witness_data.encode())])
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Circuit (performs ZK computation):</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn circuit(witnesses: Vec&lt;Witness&gt;) -&gt; Vec&lt;u8&gt; {
    let witness_data = TransferWitness::decode(witnesses[0].as_data().unwrap());
    let mut state = witness_data.initial_state;
    
    // Perform trusted transfer (signature already verified in controller)
    state.transfer_trusted(witness_data.from, witness_data.to, witness_data.value);
    
    // Return state commitment for on-chain verification
    state.commitment().encode()
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Note:</strong> The above examples show the conceptual structure for state encoding. The current template implementation uses simpler examples (like incrementing a counter), as the full state encoding mechanisms are still in development.</p>
</blockquote>
<h3 id="on-chain-verification"><a class="header" href="#on-chain-verification">On-Chain Verification</a></h3>
<p>When the target chain receives the proof and circuit output, it can verify execution correctness:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn verify(&amp;self, proof: Proof, circuit_output: Vec&lt;u8&gt;) {
    let current_commitment = self.state.commitment();
    
    // Extract the new state commitment from circuit output
    let new_commitment = StateCommitment::decode(circuit_output);
    
    // Verify the ZK proof
    proof.verify(&amp;self.vk, &amp;[current_commitment, new_commitment].concat());
    
    // Apply the proven state transition
    self.state.apply_commitment(new_commitment);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="merkleized-encoder"><a class="header" href="#merkleized-encoder">Merkleized Encoder</a></h2>
<p>For cross-chain applications, the Merkleized Encoder handles state transition dependencies across multiple domains. This enables parallel execution while maintaining correctness for chains that depend on each other's state.</p>
<h3 id="cross-chain-state-dependencies"><a class="header" href="#cross-chain-state-dependencies">Cross-Chain State Dependencies</a></h3>
<p>Consider three chains where:</p>
<ul>
<li>Chain 1 executes independently</li>
<li>Chain 2 executes independently</li>
<li>Chain 3 depends on the result from Chain 1</li>
</ul>
<p>The Merklelized Encoder creates a Merkle tree structure:</p>
<pre><code class="language-text">        R (Root)
       /         \
     M1           M2
    /  \         /  \
   C1   C2      C3   0
   |    |       |
Chain1 Chain2 Chain3
</code></pre>
<p>Each leaf contains the encoded state transition for its respective chain:</p>
<ul>
<li><code>C1</code>: <code>(S1 → T1), K1</code> (Chain 1 transition)</li>
<li><code>C2</code>: <code>(S2 → T2), K2</code> (Chain 2 transition)</li>
<li><code>C3</code>: <code>(S3 → T3), K3</code> (Chain 3 transition, depends on T1)</li>
</ul>
<h3 id="parallel-and-sequential-execution"><a class="header" href="#parallel-and-sequential-execution">Parallel and Sequential Execution</a></h3>
<p>The ZK coprocessor can execute proofs in parallel where possible:</p>
<ol>
<li><strong>Independent execution</strong>: Chain 1 and Chain 2 can execute in parallel</li>
<li><strong>Sequential dependency</strong>: Chain 3 waits for Chain 1's result <code>T1</code></li>
<li><strong>State sharing</strong>: Chain 3 receives <code>T1</code> and validates the foreign state while processing</li>
</ol>
<h3 id="optimized-verification"><a class="header" href="#optimized-verification">Optimized Verification</a></h3>
<p>The Merkle tree structure provides logarithmic verification efficiency. Each chain only needs:</p>
<ul>
<li>Its own state transition arguments</li>
<li>The Merkle path to the root <code>R</code></li>
<li>Any dependent state from other chains</li>
</ul>
<p>For example, Chain 2 only needs <code>C1</code> and <code>M2</code> for its Merkle proof, not the complete state data from Chains 1 and 3.</p>
<h3 id="on-chain-proof-distribution"><a class="header" href="#on-chain-proof-distribution">On-Chain Proof Distribution</a></h3>
<p>Each chain receives the minimal data needed for verification:</p>
<ul>
<li><strong>Chain 1</strong>: <code>(R1, T1)</code></li>
<li><strong>Chain 2</strong>: <code>(R2, T2)</code></li>
<li><strong>Chain 3</strong>: <code>(R3, T3, R1, T1, C2)</code></li>
</ul>
<p>Chain 3's verification process includes:</p>
<ol>
<li>Verify its own transition: <code>verify(R3, T3)</code></li>
<li>Verify the dependency: <code>verify(R1, T1)</code></li>
<li>Query the foreign state: <code>query(T1)</code></li>
<li>Reconstruct the commitments and validate the Merkle root</li>
</ol>
<p>This architecture enables the Valence Coprocessor to securely and efficiently coordinate complex cross-chain programs.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../zk/06_guest_environment.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../authorizations_processors/_overview.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../zk/06_guest_environment.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../authorizations_processors/_overview.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>


    </div>
    </body>
</html>
